[{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/app.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····?·input⏎····:·typeof·input·===·'string'⏎······?·input.split(',')⏎·····` with `·?·input·:·typeof·input·===·'string'·?·input.split(',')`","line":93,"column":39,"nodeType":null,"messageId":"replace","endLine":97,"endColumn":6,"fix":{"range":[5307,5382],"text":" ? input : typeof input === 'string' ? input.split(',')"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import express, { type Express } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport morgan from 'morgan';\nimport cookieParser from 'cookie-parser';\nimport rateLimit from 'express-rate-limit';\nimport mongoSanitize from 'express-mongo-sanitize';\nimport swaggerUi from 'swagger-ui-express';\n\nimport { requestIdMiddleware } from './middlewares/request-id.middleware.js';\nimport { appErrorHandler, notFoundHandler } from './middlewares/error-handler.js';\nimport { loggerStream } from './utils/logger.js';\nimport { startAnnouncementScheduler } from './services/announcementScheduler.service.js';\nimport { startBannerScheduler } from './services/bannerScheduler.service.js';\nimport cronJobsService from './services/cronJobs.service.js';\nimport swaggerSpec from './config/swagger.config.js';\nimport logger from './utils/logger.js';\nimport metricsMiddleware from './middlewares/metrics.middleware.js';\nimport metricsService from './services/metrics.service.js';\n\ntype RouterModule = { default?: express.Router } | express.Router;\n\ninterface RouteDefinition {\n  mountPath: string;\n  modulePath: string;\n}\n\nconst routeDefinitions: RouteDefinition[] = [\n  { mountPath: '/', modulePath: './routes/health.routes.js' },\n  { mountPath: '/api/auth', modulePath: './routes/auth.routes.js' },\n  { mountPath: '/api/account', modulePath: './routes/account.routes.js' },\n  { mountPath: '/api/users', modulePath: './routes/users.routes.js' },\n  { mountPath: '/api', modulePath: './routes/providers.routes.js' },\n  { mountPath: '/api', modulePath: './routes/announcements.routes.js' },\n  { mountPath: '/api', modulePath: './routes/banners.routes.js' },\n  { mountPath: '/api', modulePath: './routes/membershipPlans.routes.js' },\n  { mountPath: '/api', modulePath: './routes/membershipBenefits.routes.js' },\n  { mountPath: '/api', modulePath: './routes/contentTexts.routes.js' },\n  { mountPath: '/api', modulePath: './routes/auditLogs.routes.js' },\n  { mountPath: '/api', modulePath: './routes/importExport.routes.js' },\n  { mountPath: '/api/ai', modulePath: './routes/ai.route.js' },\n  { mountPath: '/api/admin/kb', modulePath: './routes/admin/kb.route.js' },\n  { mountPath: '/api/admin/uploads', modulePath: './routes/admin/uploads.route.js' },\n  { mountPath: '/api/admin/features', modulePath: './routes/feature-catalog.routes.js' },\n  { mountPath: '/api/admin/ui', modulePath: './routes/ui.routes.js' },\n  { mountPath: '/api/admin/pipeline-schemas', modulePath: './routes/pipelineSchemas.routes.js' },\n  {\n    mountPath: '/api/admin/pipeline-execution',\n    modulePath: './routes/pipelineExecution.routes.js'\n  },\n  { mountPath: '/api/admin/mcp-endpoints', modulePath: './routes/mcpEndpoints.routes.js' },\n  { mountPath: '/api/buildingai', modulePath: './routes/buildingai-adaptor.routes.js' },\n  { mountPath: '/api/membership', modulePath: './routes/membership.routes.js' },\n  { mountPath: '/api/media', modulePath: './routes/media.routes.js' },\n  { mountPath: '/api/task', modulePath: './routes/task.routes.js' },\n  // 前台功能列表与表单Schema\n  { mountPath: '/api/features', modulePath: './routes/feature.routes.js' },\n  { mountPath: '/api/assets', modulePath: './routes/asset.routes.js' },\n  { mountPath: '/api/admin', modulePath: './routes/admin.routes.js' },\n  { mountPath: '/api/system-config', modulePath: './routes/systemConfig.routes.js' },\n  { mountPath: '/api/scf', modulePath: './routes/scfCallback.routes.js' },\n  { mountPath: '/api/cache', modulePath: './routes/cache.routes.js' },\n  { mountPath: '/api/distribution', modulePath: './routes/distribution.routes.js' },\n  { mountPath: '/api/circuit-breaker', modulePath: './routes/circuitBreaker.routes.js' },\n  { mountPath: '/api/payment', modulePath: './routes/payment.routes.js' },\n  { mountPath: '/api/auth/wechat', modulePath: './routes/wechat-login.routes.js' },\n  { mountPath: '/api/ai', modulePath: './routes/buildingai-adaptor.routes.js' },\n  { mountPath: '/api/invite-codes', modulePath: './routes/invite-code.routes.js' },\n  { mountPath: '/api/user-profile', modulePath: './routes/user-profile.routes.js' },\n  { mountPath: '/api/referral-validation', modulePath: './routes/referral-validation.routes.js' },\n  { mountPath: '/api/kms', modulePath: './routes/kms.routes.js' },\n  { mountPath: '/api/admin/errors', modulePath: './routes/error-management.routes.js' },\n  { mountPath: '/api/docs', modulePath: './routes/docs.routes.js' },\n  { mountPath: '/api/ui', modulePath: './routes/ui.routes.js' },\n  { mountPath: '/api/cms/features', modulePath: './routes/cmsFeatures.routes.js' },\n  { mountPath: '/api/cms/providers', modulePath: './routes/cmsProviders.routes.js' },\n  { mountPath: '/api/pipeline-schemas', modulePath: './routes/pipelineSchemas.routes.js' },\n  { mountPath: '/api/pipeline-executions', modulePath: './routes/pipelineExecution.routes.js' },\n  { mountPath: '/api/mcp-endpoints', modulePath: './routes/mcpEndpoints.routes.js' },\n  { mountPath: '/api/prompt-templates', modulePath: './routes/promptTemplates.routes.js' }\n];\n\nconst normalizeOrigin = (origin: string): string | null => {\n  try {\n    const parsed = new URL(origin);\n    return `${parsed.protocol}//${parsed.host}`;\n  } catch {\n    return null;\n  }\n};\n\nconst buildCorsWhitelist = (input?: string | string[]): Set<string> => {\n  const rawList = Array.isArray(input)\n    ? input\n    : typeof input === 'string'\n      ? input.split(',')\n      : [];\n  const normalized = rawList\n    .map((origin) => normalizeOrigin(origin.trim()))\n    .filter((value): value is string => Boolean(value));\n  if (normalized.length === 0) {\n    normalized.push('http://localhost:3001');\n  }\n  return new Set(normalized);\n};\n\nconst loadRouter = async (modulePath: string): Promise<express.Router> => {\n  const module = (await import(modulePath)) as RouterModule;\n  const rawRouter = module && 'default' in module ? module.default : module;\n  const router = rawRouter as express.Router | undefined;\n  if (!router) {\n    throw new Error(`模块 ${modulePath} 未导出 Router`);\n  }\n  return router;\n};\n\nconst registerRoutes = async (app: Express): Promise<void> => {\n  for (const { mountPath, modulePath } of routeDefinitions) {\n    const router = await loadRouter(modulePath);\n    app.use(mountPath, router);\n  }\n};\n\nconst createRateLimiter = () =>\n  rateLimit({\n    legacyHeaders: false,\n    standardHeaders: true,\n    windowMs: Number.parseInt(process.env.RATE_LIMIT_WINDOW_MS ?? '60000', 10),\n    limit: Number.parseInt(process.env.RATE_LIMIT_MAX_REQUESTS ?? '100', 10),\n    message: '请求过于频繁，请稍后再试'\n  });\n\nexport interface CreateAppOptions {\n  corsOrigins?: string[] | string;\n}\n\nexport async function createApp(options: CreateAppOptions = {}): Promise<Express> {\n  const app = express();\n\n  app.disable('x-powered-by');\n  app.use(requestIdMiddleware);\n  app.use(helmet());\n\n  // 防止NoSQL注入（艹！虽然用的是MySQL，但防患于未然）\n  app.use(mongoSanitize());\n\n  const originConfig = options.corsOrigins ?? process.env.FRONTEND_URL;\n  const corsWhitelist = buildCorsWhitelist(originConfig);\n\n  app.use(\n    cors({\n      origin: (origin, callback) => {\n        if (!origin) {\n          return callback(null, true);\n        }\n        const normalized = normalizeOrigin(origin);\n        if (normalized && corsWhitelist.has(normalized)) {\n          return callback(null, true);\n        }\n        logger.warn(`[CORS] 拦截来源: ${origin}`);\n        return callback(new Error('Not allowed by CORS'));\n      },\n      credentials: true,\n      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n      allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'Accept', 'Origin'],\n      exposedHeaders: ['X-Request-ID'],\n      maxAge: 600\n    })\n  );\n\n  app.use(express.json({ limit: '10mb' }));\n  app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n  app.use(cookieParser());\n  app.use(morgan('combined', { stream: loggerStream }));\n  app.use(createRateLimiter());\n\n  // P1-014: Prometheus指标收集中间件（艹！监控HTTP请求）\n  app.use(metricsMiddleware);\n\n  app.get('/', (_req, res) => {\n    res.json({\n      message: '欢迎使用AI照片处理后端API',\n      version: '1.0.0',\n      status: 'running',\n      timestamp: new Date().toISOString()\n    });\n  });\n\n  app.get('/health', (_req, res) => {\n    res.json({ status: 'ok', timestamp: new Date().toISOString() });\n  });\n\n  // P1-014: Prometheus指标暴露端点（艹！Prometheus从这个接口抓取指标）\n  app.get('/metrics', async (req, res) => {\n    try {\n      res.set('Content-Type', metricsService.getContentType());\n      const metrics = await metricsService.getMetrics();\n      res.end(metrics);\n    } catch (error) {\n      logger.error('[Metrics] 获取指标失败:', error);\n      res.status(500).end('Error collecting metrics');\n    }\n  });\n\n  // P1-013: Swagger API文档（艹！所有API文档一目了然，访问 /api-docs 查看）\n  app.use(\n    '/api-docs',\n    swaggerUi.serve,\n    swaggerUi.setup(swaggerSpec, {\n      customSiteTitle: 'AI Photo API文档',\n      customCss: '.swagger-ui .topbar { display: none }',\n      swaggerOptions: {\n        persistAuthorization: true, // 持久化认证信息\n        docExpansion: 'none', // 默认折叠所有接口\n        filter: true, // 启用搜索过滤\n        tryItOutEnabled: true // 启用\"Try it out\"功能\n      }\n    })\n  );\n\n  // Swagger JSON规范\n  app.get('/api-docs.json', (req, res) => {\n    res.setHeader('Content-Type', 'application/json');\n    res.send(swaggerSpec);\n  });\n\n  await registerRoutes(app);\n\n  app.use(notFoundHandler);\n  app.use(appErrorHandler);\n\n  return app;\n}\n\nlet announcementScheduler: NodeJS.Timeout | null = null;\nlet bannerScheduler: NodeJS.Timeout | null = null;\n\nexport const startSchedulers = (): void => {\n  announcementScheduler = startAnnouncementScheduler();\n  bannerScheduler = startBannerScheduler();\n  // 启动基于 node-cron 的定时任务集合\n  try {\n    cronJobsService.startAll();\n  } catch (err) {\n    // 这个SB错误别阻塞主进程，打个日志继续跑\n    console.error('[App] 启动cron失败', err);\n  }\n};\n\nexport const stopSchedulers = (): void => {\n  if (announcementScheduler) {\n    clearInterval(announcementScheduler);\n    announcementScheduler = null;\n  }\n  if (bannerScheduler) {\n    clearInterval(bannerScheduler);\n    bannerScheduler = null;\n  }\n  try {\n    cronJobsService.stopAll();\n  } catch (err) {\n    console.error('[App] 停止cron失败', err);\n  }\n};\n\n// 艹，创建默认app实例供测试和老版本代码使用！\nconst defaultApp = await createApp();\nexport default defaultApp;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/cache/config-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/bullmq.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/cos.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/env.validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/error-codes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/i18n-messages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/knex-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/payment.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/swagger.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/config/wechat.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/account.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/featureWizard.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/admin/featureWizard.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const controller: {\n  createFeatureFromWizard: any;\n};\nexport default controller;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/featureWizard.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/formSchemas.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/pipelines-validate.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/admin/pipelines-validate.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const controller: {\n  validatePipeline: any;\n  getTopologicalOrder: any;\n};\nexport default controller;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/pipelines-validate.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/prompts.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/admin/prompts.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const controller: {\n  previewPrompt: any;\n  validatePrompt: any;\n  getHelpers: any;\n};\nexport default controller;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/admin/prompts.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/announcements.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(401)` with `⏎··········.status(401)⏎··········`","line":104,"column":12,"nodeType":null,"messageId":"replace","endLine":104,"endColumn":24,"fix":{"range":[3031,3043],"text":"\n          .status(401)\n          "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Announcements Controller\n * 艹，公告管理控制器！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport * as announcementRepo from '../repositories/announcements.repo.js';\nimport type { CreateAnnouncementInput, Announcement } from '../repositories/announcements.repo.js';\n\ntype TargetAudience = Announcement['target_audience'] | undefined;\n\nconst parseTargetAudience = (value: unknown): TargetAudience => {\n  if (value === 'all' || value === 'member' || value === 'vip') {\n    return value;\n  }\n  return undefined;\n};\n\nexport class AnnouncementsController {\n  /**\n   * 列出公告（管理端）\n   */\n  async listAnnouncements(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { status, position, limit = 50, offset = 0, includeExpired } = req.query;\n\n      const announcements = await announcementRepo.listAnnouncements({\n        status: status as string,\n        position: position as string,\n        limit: parseInt(limit as string),\n        offset: parseInt(offset as string),\n        includeExpired: includeExpired === 'true'\n      });\n\n      res.json({\n        success: true,\n        data: {\n          items: announcements,\n          limit: parseInt(limit as string),\n          offset: parseInt(offset as string)\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AnnouncementsController] 列出公告失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取当前有效公告（前台）\n   */\n  async getActiveAnnouncements(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { position, target_audience } = req.query;\n\n      const announcements = await announcementRepo.getActiveAnnouncements({\n        position: position as string,\n        target_audience: parseTargetAudience(target_audience) ?? 'all'\n      });\n\n      res.json({\n        success: true,\n        data: announcements\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AnnouncementsController] 获取有效公告失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取单个公告\n   */\n  async getAnnouncement(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const announcement = await announcementRepo.getAnnouncementById(id);\n\n      if (!announcement) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '公告不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, data: announcement });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AnnouncementsController] 获取公告失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 创建公告\n   */\n  async createAnnouncement(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n\n      const payload = req.body as CreateAnnouncementInput;\n      const input: CreateAnnouncementInput = {\n        ...payload,\n        created_by: userId\n      };\n\n      // 艹，基础校验\n      if (!input.title?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '标题不能为空' }\n        });\n        return;\n      }\n\n      if (!input.content?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '内容不能为空' }\n        });\n        return;\n      }\n\n      const announcement = await announcementRepo.createAnnouncement(input);\n\n      res.status(201).json({ success: true, data: announcement });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AnnouncementsController] 创建公告失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 更新公告\n   */\n  async updateAnnouncement(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const updates = req.body;\n\n      const announcement = await announcementRepo.updateAnnouncement(id, updates);\n\n      res.json({ success: true, data: announcement });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      if (err.message.includes('不存在')) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: err.message }\n        });\n        return;\n      }\n      console.error('[AnnouncementsController] 更新公告失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 删除公告\n   */\n  async deleteAnnouncement(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const deleted = await announcementRepo.deleteAnnouncement(id);\n\n      if (!deleted) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '公告不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, message: '公告已删除' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AnnouncementsController] 删除公告失败:', err.message);\n      next(err);\n    }\n  }\n}\n\nexport default new AnnouncementsController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/asset.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(401)` with `⏎··········.status(401)⏎··········`","line":30,"column":12,"nodeType":null,"messageId":"replace","endLine":30,"endColumn":24,"fix":{"range":[620,632],"text":"\n          .status(401)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(401)` with `⏎··········.status(401)⏎··········`","line":55,"column":12,"nodeType":null,"messageId":"replace","endLine":55,"endColumn":24,"fix":{"range":[1407,1419],"text":"\n          .status(401)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·······`","line":78,"column":75,"nodeType":null,"messageId":"insert","endLine":78,"endColumn":75,"fix":{"range":[2360,2360],"text":"\n       "}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport assetService from '../services/asset.service.js';\nimport logger from '../utils/logger.js';\n\n/**\n * 资产查询参数类型\n */\ninterface AssetQueryParams {\n  type?: string;\n  featureId?: string;\n  startDate?: string;\n  endDate?: string;\n  page?: string | number;\n  limit?: string | number;\n  userId?: string;\n}\n\n/**\n * 资产错误对象类型\n */\ninterface AssetError extends Error {\n  errorCode?: number;\n}\n\nclass AssetController {\n  async getAssets(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n      const { type, featureId, startDate, endDate, page, limit } = req.query as AssetQueryParams;\n      const result = await assetService.getAssets({\n        userId,\n        type,\n        featureId,\n        startDate,\n        endDate,\n        page,\n        limit\n      });\n      res.json({ success: true, ...result });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[AssetController] 获取素材列表失败: ${err?.message}`, err);\n      next(err);\n    }\n  }\n\n  async deleteAsset(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n      const { assetId } = req.params as { assetId?: string };\n      if (!assetId) {\n        res.status(400).json({ success: false, error: { code: 4001, message: '缺少素材ID' } });\n        return;\n      }\n      await assetService.deleteAsset(assetId, userId);\n      res.json({ success: true, message: '素材已删除' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      if ((err as AssetError).errorCode === 4004) {\n        res.status(404).json({ success: false, error: { code: 4004, message: err.message } });\n        return;\n      }\n      logger.error(`[AssetController] 删除素材失败: ${err?.message}`, err);\n      next(err);\n    }\n  }\n\n  async getAllAssets(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId, type, featureId, startDate, endDate, page, limit } = req.query as AssetQueryParams;\n      const result = await assetService.getAllAssets({\n        ...(userId ? { userId } : {}),\n        type,\n        featureId,\n        startDate,\n        endDate,\n        page,\n        limit\n      });\n      res.json({ success: true, ...result });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[AssetController] 管理员获取素材列表失败: ${err?.message}`, err);\n      next(err);\n    }\n  }\n}\n\nexport default new AssetController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/auditLogs.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/auth.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·(req·as·unknown·as·{·userId?:·string·}).userId·??` with `⏎········(req·as·unknown·as·{·userId?:·string·}).userId·??⏎·······`","line":498,"column":21,"nodeType":null,"messageId":"replace","endLine":498,"endColumn":71,"fix":{"range":[13121,13171],"text":"\n        (req as unknown as { userId?: string }).userId ??\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `tokenService·as·unknown·as·{·getTokenRemainingTime?:·(token:·unknown)·=>·unknown·}` with `⏎········tokenService·as·unknown·as·{·getTokenRemainingTime?:·(token:·unknown)·=>·unknown·}⏎······`","line":527,"column":38,"nodeType":null,"messageId":"replace","endLine":527,"endColumn":120,"fix":{"range":[14137,14219],"text":"\n        tokenService as unknown as { getTokenRemainingTime?: (token: unknown) => unknown }\n      "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\n * Auth Controller\n * 艹，这个tm负责所有认证相关操作！登录、注册、刷新、登出！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport bcrypt from 'bcryptjs';\nimport { nanoid } from 'nanoid';\nimport * as userRepo from '../repositories/users.repo.js';\nimport authService from '../services/auth.service.js';\nimport tokenService from '../services/token.service.js';\nimport { verifyToken } from '../utils/jwt.js';\nimport cacheService from '../services/cache.service.js';\n\n/**\n * Cookie配置\n * 艹，httpOnly防止XSS攻击！secure在生产环境启用！\n */\nconst COOKIE_OPTIONS = {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === 'production', // 生产环境用HTTPS\n  sameSite: 'lax' as const,\n  maxAge: 7 * 24 * 60 * 60 * 1000 // 7天\n};\n\nexport class AuthController {\n  /**\n   * 发送验证码\n   * POST /api/auth/send-code\n   */\n  async sendCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { phone } = req.body as { phone?: string };\n      if (!phone || !/^1[3-9]\\d{9}$/.test(phone)) {\n        res.status(400).json({ success: false, error: { code: 2000, message: '手机号格式错误' } });\n        return;\n      }\n      const ip = (req.ip || (req.socket?.remoteAddress ?? '')) as string;\n      const result = await authService.sendCode(phone, ip);\n      res.json({ success: true, data: result, message: '验证码已发送' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 发送邮箱验证码\n   * POST /api/auth/email/send-code\n   */\n  async sendEmailCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { email } = req.body as { email?: string };\n      if (!email) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'EMAIL_REQUIRED',\n            message: '邮箱不能为空'\n          }\n        });\n        return;\n      }\n      const ip = (req.ip || (req.socket?.remoteAddress ?? '')) as string;\n      const result = await authService.sendEmailCode(email, ip);\n      res.json({ success: true, data: result, message: '验证码已发送' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 用户注册\n   * POST /api/auth/register\n   */\n  async register(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { phone, password, referrer_id } = req.body;\n\n      // 艹，基础校验\n      if (!phone || !password) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '手机号和密码不能为空'\n          }\n        });\n        return;\n      }\n\n      // 手机号格式校验\n      if (!/^1[3-9]\\d{9}$/.test(phone)) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '手机号格式不正确'\n          }\n        });\n        return;\n      }\n\n      // 密码长度校验\n      if (password.length < 6) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '密码长度不能少于6位'\n          }\n        });\n        return;\n      }\n\n      // 检查手机号是否已存在\n      const exists = await userRepo.phoneExists(phone);\n      if (exists) {\n        res.status(409).json({\n          success: false,\n          error: {\n            code: 'PHONE_EXISTS',\n            message: '手机号已被注册'\n          }\n        });\n        return;\n      }\n\n      // 艹，密码加密！\n      const hashedPassword = await bcrypt.hash(password, 10);\n\n      // 创建用户\n      const user = await userRepo.createUser({\n        id: nanoid(32),\n        phone,\n        password: hashedPassword,\n        role: 'user', // 默认普通用户\n        isMember: false,\n        quota_remaining: 0,\n        referrer_id: referrer_id || null\n      });\n\n      // 生成Token\n      const { accessToken, refreshToken } = tokenService.generateTokenPair({\n        id: user.id,\n        phone: user.phone,\n        role: user.role\n      });\n\n      // 艹，设置Cookie！\n      res.cookie('access_token', accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', user.role, { ...COOKIE_OPTIONS, httpOnly: false }); // roles可以被JS读取\n\n      // 返回用户信息（不含密码）\n      const safeUser = userRepo.toSafeUser(user);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          user: safeUser,\n          access_token: accessToken,\n          refresh_token: refreshToken\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AuthController] 注册失败:', err.message);\n      next(error);\n    }\n  }\n\n  /**\n   * 邮箱注册\n   * POST /api/auth/email/register\n   */\n  async registerWithEmail(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { email, code, password, referrer_id } = req.body as {\n        email?: string;\n        code?: string;\n        password?: string;\n        referrer_id?: string | null;\n      };\n\n      if (!email || !code || !password) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '邮箱、验证码和密码不能为空'\n          }\n        });\n        return;\n      }\n\n      if (password.length < 6) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'INVALID_PASSWORD',\n            message: '密码长度不能少于6位'\n          }\n        });\n        return;\n      }\n\n      const result = await authService.registerWithEmail(\n        email,\n        code,\n        password,\n        referrer_id ?? null\n      );\n\n      res.cookie('access_token', result.accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', result.refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', result.user.role, { ...COOKIE_OPTIONS, httpOnly: false });\n\n      res.status(201).json({\n        success: true,\n        data: {\n          user: result.user,\n          access_token: result.accessToken,\n          refresh_token: result.refreshToken\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 用户登录\n   * POST /api/auth/login\n   */\n  async loginPassword(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { phone, password } = req.body;\n\n      // 艹，基础校验\n      if (!phone || !password) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '手机号和密码不能为空'\n          }\n        });\n        return;\n      }\n\n      // 查找用户\n      const user = await userRepo.findUserByPhone(phone);\n      if (!user) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'INVALID_CREDENTIALS',\n            message: '手机号或密码错误'\n          }\n        });\n        return;\n      }\n\n      // 艹，验证密码！\n      if (!user.password) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'PASSWORD_NOT_SET',\n            message: '该账号未设置密码，请联系管理员'\n          }\n        });\n        return;\n      }\n\n      const passwordMatch = await bcrypt.compare(password, user.password);\n      if (!passwordMatch) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'INVALID_CREDENTIALS',\n            message: '手机号或密码错误'\n          }\n        });\n        return;\n      }\n\n      // 生成Token\n      const { accessToken, refreshToken } = tokenService.generateTokenPair({\n        id: user.id,\n        phone: user.phone,\n        role: user.role\n      });\n\n      // 艹，设置Cookie！\n      res.cookie('access_token', accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', user.role, { ...COOKIE_OPTIONS, httpOnly: false }); // roles可以被JS读取\n\n      // 返回用户信息（不含密码）\n      const safeUser = userRepo.toSafeUser(user);\n\n      res.json({\n        success: true,\n        data: {\n          user: safeUser,\n          access_token: accessToken,\n          refresh_token: refreshToken\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AuthController] 登录失败:', err.message);\n      next(error);\n    }\n  }\n\n  /**\n   * 邮箱验证码登录\n   * POST /api/auth/email/login\n   */\n  async loginWithEmailCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { email, code, referrer_id } = req.body as {\n        email?: string;\n        code?: string;\n        referrer_id?: string | null;\n      };\n\n      if (!email || !code) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '邮箱和验证码不能为空'\n          }\n        });\n        return;\n      }\n\n      const result = await authService.loginWithEmailCode(email, code, referrer_id ?? null);\n\n      res.cookie('access_token', result.accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', result.refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', result.user.role, { ...COOKIE_OPTIONS, httpOnly: false });\n\n      res.json({\n        success: true,\n        data: {\n          user: result.user,\n          access_token: result.accessToken,\n          refresh_token: result.refreshToken\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 刷新Token\n   * POST /api/auth/refresh\n   */\n  async refresh(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 艹，从Cookie获取refresh token\n      const refreshToken = req.cookies?.refresh_token;\n\n      if (!refreshToken) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'NO_REFRESH_TOKEN',\n            message: '未找到刷新Token'\n          }\n        });\n        return;\n      }\n\n      // 验证refresh token\n      let payload;\n      try {\n        payload = verifyToken(refreshToken);\n      } catch (error: unknown) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'REFRESH_TOKEN_INVALID',\n            message: 'Refresh Token无效或已过期'\n          }\n        });\n        return;\n      }\n\n      // 查找用户（确保用户仍然存在）\n      const user = await userRepo.findUserById(payload.userId);\n      if (!user) {\n        res.status(401).json({\n          success: false,\n          error: {\n            code: 'USER_NOT_FOUND',\n            message: '用户不存在'\n          }\n        });\n        return;\n      }\n\n      // 统一通过token服务刷新\n      const pair = await tokenService.refreshTokens(refreshToken);\n      if (!pair) {\n        res.status(401).json({\n          success: false,\n          error: { code: 'REFRESH_TOKEN_INVALID', message: 'Refresh Token无效或已过期' }\n        });\n        return;\n      }\n\n      // 更新Cookie\n      res.cookie('access_token', pair.accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', pair.refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', user.role, { ...COOKIE_OPTIONS, httpOnly: false });\n\n      res.json({\n        success: true,\n        data: {\n          access_token: pair.accessToken,\n          refresh_token: pair.refreshToken\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AuthController] 刷新Token失败:', err.message);\n      next(error);\n    }\n  }\n\n  /**\n   * 用户登出\n   * POST /api/auth/logout\n   */\n  async logout(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 清除Cookie\n      res.clearCookie('access_token', COOKIE_OPTIONS);\n      res.clearCookie('refresh_token', COOKIE_OPTIONS);\n      res.clearCookie('roles', { ...COOKIE_OPTIONS, httpOnly: false });\n\n      res.json({ success: true, message: '登出成功' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[AuthController] 登出失败:', err.message);\n      next(error);\n    }\n  }\n\n  /**\n   * 验证码登录\n   * POST /api/auth/login\n   */\n  async loginCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { phone, code, referrer_id } = req.body as {\n        phone?: string;\n        code?: string;\n        referrer_id?: string | null;\n      };\n      if (!phone || !/^1[3-9]\\d{9}$/.test(phone)) {\n        res.status(400).json({ success: false, error: { code: 2000, message: '手机号格式错误' } });\n        return;\n      }\n      if (!code || !/^\\d{6}$/.test(code)) {\n        res.status(400).json({ success: false, error: { code: 2002, message: '验证码格式错误' } });\n        return;\n      }\n      const result = await authService.loginWithCode(phone, code, referrer_id ?? null);\n      res.cookie('access_token', result.accessToken, COOKIE_OPTIONS);\n      res.cookie('refresh_token', result.refreshToken, COOKIE_OPTIONS);\n      res.cookie('roles', result.user.role, { ...COOKIE_OPTIONS, httpOnly: false });\n      res.json({\n        success: true,\n        data: {\n          user: result.user,\n          access_token: result.accessToken,\n          refresh_token: result.refreshToken\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 获取当前用户信息（需要认证）\n   * GET /api/auth/me\n   */\n  async getMe(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = (req as unknown as { userId?: string }).userId ?? (req.user as { id?: string } | undefined)?.id;\n      if (!userId) {\n        res\n          .status(401)\n          .json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n      const user = await authService.getUser(userId);\n      res.json({ success: true, data: user });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 验证Token状态（需要认证）\n   * GET /api/auth/verify\n   */\n  async verify(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = (req.user as { id?: string } | undefined)?.id as string | undefined;\n      const jti = (req.user as { jti?: string } | undefined)?.jti as string | undefined;\n      if (!userId) {\n        res\n          .status(401)\n          .json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n      const ok = await authService.verifyTokenStatus(userId, jti);\n      const getTokenRemainingTime = (tokenService as unknown as { getTokenRemainingTime?: (token: unknown) => unknown }).getTokenRemainingTime;\n      const token = (req as unknown as { token?: unknown }).token;\n      const iat = (req.user as { iat?: unknown } | undefined)?.iat;\n      const exp = (req.user as { exp?: unknown } | undefined)?.exp;\n      res.json({\n        success: ok,\n        data: {\n          user: req.user,\n          remainingTime: getTokenRemainingTime?.(token) ?? null,\n          iat,\n          exp\n        },\n        message: ok ? 'Token有效' : 'Token无效'\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 设置/修改密码\n   * POST /api/auth/set-password\n   * 艹！用户首次设置密码或修改密码！\n   */\n  async setPassword(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { newPassword, oldPassword } = req.body;\n      const userId = (req.user as { userId?: string } | undefined)?.userId;\n\n      if (!userId) {\n        res.status(401).json({\n          success: false,\n          error: { code: 'UNAUTHORIZED', message: '未登录' }\n        });\n        return;\n      }\n\n      if (!newPassword || newPassword.length < 6) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'INVALID_PASSWORD', message: '密码至少6位' }\n        });\n        return;\n      }\n\n      const user = await userRepo.findUserById(userId);\n      if (!user) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'USER_NOT_FOUND', message: '用户不存在' }\n        });\n        return;\n      }\n\n      // 如果已有密码，需要验证旧密码\n      if (user.password) {\n        if (!oldPassword) {\n          res.status(400).json({\n            success: false,\n            error: { code: 'OLD_PASSWORD_REQUIRED', message: '请输入旧密码' }\n          });\n          return;\n        }\n        const isOldPasswordValid = await bcrypt.compare(oldPassword, user.password);\n        if (!isOldPasswordValid) {\n          res.status(400).json({\n            success: false,\n            error: { code: 'INVALID_OLD_PASSWORD', message: '旧密码错误' }\n          });\n          return;\n        }\n      }\n\n      // 设置新密码\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\n      await userRepo.updateUser(userId, { password: hashedPassword });\n\n      res.json({\n        success: true,\n        message: user.password ? '密码修改成功' : '密码设置成功'\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * 重置密码\n   * POST /api/auth/reset-password\n   * 艹！忘记密码用验证码重置！\n   */\n  async resetPassword(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { phone, email, code, newPassword } = req.body as {\n        phone?: string;\n        email?: string;\n        code?: string;\n        newPassword?: string;\n      };\n\n      if (!code || !newPassword || (!phone && !email)) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'MISSING_PARAMS', message: '缺少必要参数' }\n        });\n        return;\n      }\n\n      if (newPassword.length < 6) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'INVALID_PASSWORD', message: '密码至少6位' }\n        });\n        return;\n      }\n\n      if (email) {\n        await authService.resetPasswordWithEmail(email, code, newPassword);\n        res.json({\n          success: true,\n          message: '密码重置成功'\n        });\n        return;\n      }\n\n      if (!phone) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'MISSING_PARAMS', message: '请提供手机号或邮箱' }\n        });\n        return;\n      }\n\n      const cachedCode = await cacheService.get<string>(`sms:${phone}`);\n      if (!cachedCode || cachedCode !== code) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'INVALID_CODE', message: '验证码错误或已过期' }\n        });\n        return;\n      }\n\n      const user = await userRepo.findUserByPhone(phone);\n      if (!user) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'USER_NOT_FOUND', message: '用户不存在' }\n        });\n        return;\n      }\n\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\n      await userRepo.updateUser(user.id, { password: hashedPassword });\n      await cacheService.delete(`sms:${phone}`);\n\n      res.json({\n        success: true,\n        message: '密码重置成功'\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nexport default new AuthController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/banners.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(401)` with `⏎··········.status(401)⏎··········`","line":102,"column":12,"nodeType":null,"messageId":"replace","endLine":102,"endColumn":24,"fix":{"range":[2772,2784],"text":"\n          .status(401)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎········`","line":287,"column":21,"nodeType":null,"messageId":"insert","endLine":287,"endColumn":21,"fix":{"range":[7808,7808],"text":"\n        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":288,"column":1,"nodeType":null,"messageId":"insert","endLine":288,"endColumn":1,"fix":{"range":[7827,7827],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎······`","line":289,"column":7,"nodeType":null,"messageId":"replace","endLine":289,"endColumn":8,"fix":{"range":[7908,7909],"text":"  }\n      "}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"/**\n * Banners Controller\n * 艹，轮播图控制器！支持拖拽排序！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport * as bannerRepo from '../repositories/banners.repo.js';\nimport type { CreateBannerInput, Banner } from '../repositories/banners.repo.js';\nimport * as cosService from '../services/cos.service.js';\n\ntype TargetAudience = Banner['target_audience'] | undefined;\n\nconst parseTargetAudience = (value: unknown): TargetAudience => {\n  if (value === 'all' || value === 'member' || value === 'vip') {\n    return value;\n  }\n  return undefined;\n};\n\nexport class BannersController {\n  /**\n   * 列出轮播图（管理端）\n   */\n  async listBanners(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { status, limit = 50, offset = 0 } = req.query;\n\n      const banners = await bannerRepo.listBanners({\n        status: status as string,\n        limit: parseInt(limit as string),\n        offset: parseInt(offset as string)\n      });\n\n      res.json({\n        success: true,\n        data: {\n          items: banners,\n          limit: parseInt(limit as string),\n          offset: parseInt(offset as string)\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 列出轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取当前有效轮播图（前台）\n   */\n  async getActiveBanners(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { target_audience } = req.query;\n\n      const banners = await bannerRepo.getActiveBanners({\n        target_audience: parseTargetAudience(target_audience) ?? 'all'\n      });\n\n      res.json({\n        success: true,\n        data: banners\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 获取有效轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取单个轮播图\n   */\n  async getBanner(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const banner = await bannerRepo.getBannerById(id);\n\n      if (!banner) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '轮播图不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, data: banner });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 获取轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 创建轮播图\n   */\n  async createBanner(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n        return;\n      }\n\n      const payload = req.body as CreateBannerInput;\n      const input: CreateBannerInput = {\n        ...payload,\n        created_by: userId\n      };\n\n      // 艹，基础校验\n      if (!input.title?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '标题不能为空' }\n        });\n        return;\n      }\n\n      if (!input.image_url?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '图片URL不能为空' }\n        });\n        return;\n      }\n\n      const banner = await bannerRepo.createBanner(input);\n\n      res.status(201).json({ success: true, data: banner });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 创建轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 更新轮播图\n   */\n  async updateBanner(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const updates = req.body;\n\n      const banner = await bannerRepo.updateBanner(id, updates);\n\n      res.json({ success: true, data: banner });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      if (err.message.includes('不存在')) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: err.message }\n        });\n        return;\n      }\n      console.error('[BannersController] 更新轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 批量更新排序\n   * 艹，拖拽排序用这个！\n   */\n  async updateSortOrder(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const sortOrders: { id: number; sort_order: number }[] = req.body.sortOrders;\n\n      if (!Array.isArray(sortOrders) || sortOrders.length === 0) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'sortOrders必须是非空数组' }\n        });\n        return;\n      }\n\n      // 艹，验证每个元素\n      for (const item of sortOrders) {\n        if (typeof item.id !== 'number' || typeof item.sort_order !== 'number') {\n          res.status(400).json({\n            success: false,\n            error: { code: 'VALIDATION_ERROR', message: 'sortOrders格式错误' }\n          });\n          return;\n        }\n      }\n\n      await bannerRepo.updateBannersSortOrder(sortOrders);\n\n      res.json({ success: true, message: '排序更新成功' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 更新排序失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 删除轮播图\n   */\n  async deleteBanner(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const deleted = await bannerRepo.deleteBanner(id);\n\n      if (!deleted) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '轮播图不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, message: '轮播图已删除' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 删除轮播图失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取COS上传凭证（推荐方式）\n   * 艹，前端拿到凭证后直接上传到COS！\n   */\n  async getUploadCredentials(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 检查COS是否配置\n      if (!cosService.isCOSConfigured()) {\n        res.status(503).json({\n          success: false,\n          error: { code: 'COS_NOT_CONFIGURED', message: 'COS未配置' }\n        });\n        return;\n      }\n\n      const { filename } = req.body;\n\n      if (!filename?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '文件名不能为空' }\n        });\n        return;\n      }\n\n      // 生成安全的文件Key\n      const key = cosService.generateBannerKey(filename);\n\n      // 生成上传凭证\n      const credentials = await cosService.getUploadCredentials({\n        key,\n        expiresInSeconds: 1800 // 30分钟\n      });\n\n      res.json({\n        success: true,\n        data: credentials\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 获取上传凭证失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 后端直接上传图片到COS（备选方案）\n   * 艹，小文件可以用这个！\n   */\n  async uploadImage(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 检查COS是否配置\n      if (!cosService.isCOSConfigured()) {\n        res.status(503).json({\n          success: false,\n          error: { code: 'COS_NOT_CONFIGURED', message: 'COS未配置' }\n        });\n        return;\n      }\n\n      // 这里需要使用multer等中间件处理文件上传\n      // 暂时假设文件已经通过body传过来（需要配置multer）\n      const file = (req as Request & {\n        file?: { originalname: string; buffer: Buffer; mimetype: string };\n      }).file;\n\n      if (!file) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: '未找到上传文件' }\n        });\n        return;\n      }\n\n      // 生成安全的文件Key\n      const key = cosService.generateBannerKey(file.originalname);\n\n      // 上传到COS\n      const url = await cosService.uploadFile({\n        key,\n        body: file.buffer,\n        contentType: file.mimetype\n      });\n\n      res.json({\n        success: true,\n        data: { url, key }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[BannersController] 上传图片失败:', err.message);\n      next(err);\n    }\n  }\n}\n\nexport default new BannersController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/buildingai-adaptor.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/circuitBreaker.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.status(500)⏎········` with `.status(500)`","line":104,"column":10,"nodeType":null,"messageId":"replace","endLine":106,"endColumn":9,"fix":{"range":[3993,4023],"text":".status(500)"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.status(500)⏎········` with `.status(500)`","line":132,"column":10,"nodeType":null,"messageId":"replace","endLine":134,"endColumn":9,"fix":{"range":[5121,5151],"text":".status(500)"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.status(500)⏎········` with `.status(500)`","line":146,"column":10,"nodeType":null,"messageId":"replace","endLine":148,"endColumn":9,"fix":{"range":[5648,5678],"text":".status(500)"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.status(500)⏎········` with `.status(500)`","line":171,"column":10,"nodeType":null,"messageId":"replace","endLine":173,"endColumn":9,"fix":{"range":[6588,6618],"text":".status(500)"}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport logger from '../utils/logger.js';\nimport circuitBreakerService from '../services/circuit-breaker.service.js';\nimport providerWrapperService from '../services/provider-wrapper.service.js';\nimport providerRegistryService from '../services/provider-registry.service.js';\n\nclass CircuitBreakerController {\n  async getAllCircuitBreakers(_req: Request, res: Response): Promise<void> {\n    try {\n      const states = circuitBreakerService.getAllCircuitBreakerStates();\n      res.json({ success: true, data: states, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取熔断器状态失败:', error);\n      res.status(500).json({ success: false, error: '获取熔断器状态失败', message: err.message });\n    }\n  }\n\n  async getCircuitBreaker(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const state = circuitBreakerService.getCircuitBreakerState(name);\n      if (!state) {\n        res.status(404).json({ success: false, error: '熔断器不存在', name });\n        return;\n      }\n      res.json({ success: true, data: state, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取熔断器状态失败:', error);\n      res.status(500).json({ success: false, error: '获取熔断器状态失败', message: err.message });\n    }\n  }\n\n  async openCircuitBreaker(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const { reason } = (req.body ?? {}) as { reason?: string };\n      const success = circuitBreakerService.openCircuitBreaker(name, reason);\n      if (!success) {\n        res.status(404).json({ success: false, error: '熔断器不存在', name });\n        return;\n      }\n      res.json({\n        success: true,\n        message: `熔断器 ${name} 已手动打开`,\n        reason: reason || 'manual',\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 打开熔断器失败:', error);\n      res.status(500).json({ success: false, error: '打开熔断器失败', message: err.message });\n    }\n  }\n\n  async closeCircuitBreaker(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const success = circuitBreakerService.closeCircuitBreaker(name);\n      if (!success) {\n        res.status(404).json({ success: false, error: '熔断器不存在', name });\n        return;\n      }\n      res.json({\n        success: true,\n        message: `熔断器 ${name} 已手动关闭`,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 关闭熔断器失败:', error);\n      res.status(500).json({ success: false, error: '关闭熔断器失败', message: err.message });\n    }\n  }\n\n  async resetCircuitBreaker(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const success = circuitBreakerService.resetCircuitBreaker(name);\n      if (!success) {\n        res.status(404).json({ success: false, error: '熔断器不存在', name });\n        return;\n      }\n      res.json({\n        success: true,\n        message: `熔断器 ${name} 已重置`,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 重置熔断器失败:', error);\n      res.status(500).json({ success: false, error: '重置熔断器失败', message: err.message });\n    }\n  }\n\n  async getProviderStates(_req: Request, res: Response): Promise<void> {\n    try {\n      const states = providerWrapperService.getAllProviderStates();\n      res.json({ success: true, data: states, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取Provider状态失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: '获取Provider状态失败', message: err.message });\n    }\n  }\n\n  async getRegisteredProviders(_req: Request, res: Response): Promise<void> {\n    try {\n      const providers = providerRegistryService.getRegisteredProviders();\n      const states = providerRegistryService.getAllProviderStates();\n      res.json({ success: true, data: { providers, states }, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取已注册Provider失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: '获取已注册Provider失败', message: err.message });\n    }\n  }\n\n  async getProviderState(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const state = providerWrapperService.getProviderStats(name);\n      res.json({ success: true, data: state, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取Provider状态失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: '获取Provider状态失败', message: err.message });\n    }\n  }\n\n  async resetProviderStats(req: Request, res: Response): Promise<void> {\n    try {\n      const { name } = req.params as { name: string };\n      const success = providerWrapperService.resetProviderStats(name);\n      res.json({ success, message: success ? '重置成功' : '重置失败' });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 重置Provider统计失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: '重置Provider统计失败', message: err.message });\n    }\n  }\n\n  async executeProviderMethod(req: Request, res: Response): Promise<void> {\n    try {\n      const { providerName, methodName } = req.params as {\n        providerName: string;\n        methodName: string;\n      };\n      const { args = [], options = {} } = (req.body ?? {}) as {\n        args?: unknown[];\n        options?: Record<string, unknown>;\n      };\n      if (!providerRegistryService.isProviderRegistered(providerName)) {\n        res.status(404).json({ success: false, error: 'Provider未注册', providerName });\n        return;\n      }\n      const result = await providerRegistryService.execute(providerName, methodName, args, options);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 执行Provider方法失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: '执行Provider方法失败', message: err.message });\n    }\n  }\n\n  async healthCheck(_req: Request, res: Response): Promise<void> {\n    try {\n      const [circuitBreakerHealth, providerHealth, registryHealth] = await Promise.all([\n        circuitBreakerService.healthCheck(),\n        providerWrapperService.healthCheck(),\n        providerRegistryService.healthCheck()\n      ]);\n\n      const overallStatus = [circuitBreakerHealth, providerHealth, registryHealth]\n        .map((h) => h?.status)\n        .some((s) => s === 'unhealthy' || s === 'degraded')\n        ? 'degraded'\n        : 'healthy';\n\n      res.json({\n        success: true,\n        data: {\n          status: overallStatus,\n          services: {\n            circuitBreaker: circuitBreakerHealth,\n            providerWrapper: providerHealth,\n            providerRegistry: registryHealth\n          }\n        },\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 健康检查失败:', error);\n      res.status(500).json({\n        success: false,\n        error: '健康检查失败',\n        message: err.message,\n        status: 'unhealthy'\n      });\n    }\n  }\n\n  async getCircuitBreakerStats(_req: Request, res: Response): Promise<void> {\n    try {\n      const stats = circuitBreakerService.getStats();\n      res.json({ success: true, data: stats, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 获取熔断器统计失败:', error);\n      res.status(500).json({ success: false, error: '获取熔断器统计失败', message: err.message });\n    }\n  }\n\n  async cleanupInactiveCircuitBreakers(req: Request, res: Response): Promise<void> {\n    try {\n      const { inactiveThresholdMs = '3600000' } = req.query as Record<string, unknown>;\n      const cleanedCount = circuitBreakerService.cleanupInactiveCircuitBreakers(\n        Number(inactiveThresholdMs)\n      );\n      res.json({\n        success: true,\n        message: `清理完成，删除了 ${cleanedCount} 个不活跃的熔断器`,\n        cleanedCount,\n        thresholdMs: Number(inactiveThresholdMs),\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 清理熔断器失败:', error);\n      res.status(500).json({ success: false, error: '清理熔断器失败', message: err.message });\n    }\n  }\n\n  async batchOperateCircuitBreakers(req: Request, res: Response): Promise<void> {\n    try {\n      const { operation, names } = (req.body ?? {}) as { operation?: string; names?: string[] };\n      if (!operation || !Array.isArray(names) || names.length === 0) {\n        res\n          .status(400)\n          .json({ success: false, error: '参数错误', message: '需要提供 operation 和 names 数组' });\n        return;\n      }\n      const results: Array<{\n        name: string;\n        success: boolean;\n        operation: string;\n        error?: string;\n      }> = [];\n      let successCount = 0;\n      let failureCount = 0;\n      for (const name of names) {\n        try {\n          let success = false;\n          switch (operation) {\n            case 'open':\n              success = circuitBreakerService.openCircuitBreaker(name, 'batch operation');\n              break;\n            case 'close':\n              success = circuitBreakerService.closeCircuitBreaker(name);\n              break;\n            case 'reset':\n              success = circuitBreakerService.resetCircuitBreaker(name);\n              break;\n            default:\n              throw new Error(`不支持的操作: ${operation}`);\n          }\n          results.push({ name, success, operation });\n          if (success) successCount++;\n          else failureCount++;\n        } catch (error) {\n          const err = error as Error;\n          results.push({ name, success: false, operation, error: err.message });\n          failureCount++;\n        }\n      }\n      res.json({\n        success: true,\n        data: { operation, results, summary: { total: names.length, successCount, failureCount } },\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[CircuitBreakerController] 批量操作熔断器失败:', error);\n      res.status(500).json({ success: false, error: '批量操作熔断器失败', message: err.message });\n    }\n  }\n}\n\nexport default new CircuitBreakerController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/cmsFeature.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":83,"column":12,"nodeType":null,"messageId":"replace","endLine":83,"endColumn":24,"fix":{"range":[2829,2841],"text":"\n          .status(400)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":87,"column":12,"nodeType":null,"messageId":"replace","endLine":87,"endColumn":24,"fix":{"range":[3047,3059],"text":"\n          .status(400)\n          "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport cmsFeatureService from '../services/cmsFeature.service.js';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport type { Knex } from 'knex';\nimport type {\n  FeatureStatus,\n  CreateFeatureData,\n  UpdateFeatureData\n} from '../types/cms-feature.types.js';\n\nconst parseFeatureStatus = (value: unknown): FeatureStatus | undefined => {\n  if (value === 'draft' || value === 'published' || value === 'archived') {\n    return value;\n  }\n  return undefined;\n};\n\nconst parseSortOrder = (value: unknown): 'asc' | 'desc' | undefined => {\n  if (value === 'asc' || value === 'desc') {\n    return value;\n  }\n  return undefined;\n};\n\nconst parseBooleanFlag = (value: unknown): boolean | undefined => {\n  if (value === 'true') return true;\n  if (value === 'false') return false;\n  if (typeof value === 'boolean') return value;\n  return undefined;\n};\n\nconst requireUserId = (req: Request): string => {\n  const userId = req.user?.id;\n  if (!userId) {\n    throw AppError.custom(ERROR_CODES.UNAUTHORIZED, '未授权操作');\n  }\n  return userId;\n};\n\nclass CmsFeatureController {\n  async getFeatures(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const query = req.query as Record<string, string | undefined>;\n      const page = Number.parseInt(query.page ?? '1', 10) || 1;\n      const limit = Number.parseInt(query.limit ?? '20', 10) || 20;\n      const sortBy = query.sortBy ?? 'created_at';\n      const sortOrder = parseSortOrder(query.sortOrder) ?? 'desc';\n      const result = await cmsFeatureService.getFeatures({\n        page,\n        limit,\n        category: query.category,\n        status: parseFeatureStatus(query.status),\n        enabled: parseBooleanFlag(query.enabled),\n        search: query.search,\n        sortBy,\n        sortOrder\n      });\n      res.json({ success: true, data: result, requestId: req.id });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Get features failed:', error);\n      next(error);\n    }\n  }\n\n  async getFeatureById(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const feature = await cmsFeatureService.getFeatureById(id);\n      res.json({ success: true, data: feature, requestId: req.id });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Get feature by ID failed:', error);\n      next(error);\n    }\n  }\n\n  async createFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = requireUserId(req);\n      const payload = req.body as Partial<CreateFeatureData>;\n      if (!payload.key || typeof payload.key !== 'string' || !payload.key.trim()) {\n        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: 'key不能为空' } });\n        return;\n      }\n      if (!payload.name || typeof payload.name !== 'string' || !payload.name.trim()) {\n        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: 'name不能为空' } });\n        return;\n      }\n      const featureData: CreateFeatureData = {\n        key: payload.key,\n        name: payload.name,\n        description: payload.description,\n        category: payload.category,\n        config: payload.config,\n        menu: payload.menu,\n        metadata: payload.metadata,\n        enabled: payload.enabled\n      };\n      const feature = await cmsFeatureService.createFeature(featureData, userId);\n      res.status(201).json({\n        success: true,\n        data: feature,\n        message: '功能创建成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Create feature failed:', error);\n      next(error);\n    }\n  }\n\n  async updateFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const userId = requireUserId(req);\n      const updateData = req.body as UpdateFeatureData;\n      const feature = await cmsFeatureService.updateFeature(id, updateData, userId);\n      res.json({\n        success: true,\n        data: feature,\n        message: '功能更新成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Update feature failed:', error);\n      next(error);\n    }\n  }\n\n  async deleteFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const userId = requireUserId(req);\n      await cmsFeatureService.deleteFeature(id, userId);\n      res.json({ success: true, message: '功能删除成功', requestId: req.id });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Delete feature failed:', error);\n      next(error);\n    }\n  }\n\n  async publishFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const userId = requireUserId(req);\n      const feature = await cmsFeatureService.publishFeature(id, userId);\n      res.json({\n        success: true,\n        data: feature,\n        message: '功能发布成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Publish feature failed:', error);\n      next(error);\n    }\n  }\n\n  async rollbackFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const { version } = req.body as { version?: string };\n      const userId = requireUserId(req);\n      if (!version) throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '版本号不能为空');\n      const feature = await cmsFeatureService.rollbackFeature(id, version, userId);\n      res.json({\n        success: true,\n        data: feature,\n        message: `功能已回滚到版本 ${version}`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Rollback feature failed:', error);\n      next(error);\n    }\n  }\n\n  async getFeatureHistory(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const { page = '1', limit = '20' } = req.query as Record<string, string>;\n      const result = await cmsFeatureService.getFeatureHistory(id, {\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10)\n      });\n      res.json({ success: true, data: result, requestId: req.id });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Get feature history failed:', error);\n      next(error);\n    }\n  }\n\n  async batchUpdateFeatures(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { ids, updates } = req.body as { ids?: string[]; updates?: UpdateFeatureData };\n      const userId = requireUserId(req);\n      if (!Array.isArray(ids) || ids.length === 0)\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '功能ID列表不能为空');\n      const result = await cmsFeatureService.batchUpdateFeatures(ids, updates ?? {}, userId);\n      res.json({\n        success: true,\n        data: result,\n        message: `批量更新完成: ${result.success.length} 成功, ${result.failed.length} 失败`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Batch update features failed:', error);\n      next(error);\n    }\n  }\n\n  async toggleFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const { enabled } = req.body as { enabled?: boolean };\n      const userId = requireUserId(req);\n      const feature = await cmsFeatureService.updateFeature(id, { enabled }, userId);\n      res.json({\n        success: true,\n        data: feature,\n        message: `功能已${enabled ? '启用' : '禁用'}`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Toggle feature failed:', error);\n      next(error);\n    }\n  }\n\n  async getFeatureCategories(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { db } = await import('../config/database.js');\n      const categories = (await (db as Knex)('cms_features')\n        .distinct('category')\n        .select('category')\n        .whereNotNull('category')\n        .orderBy('category')) as Array<{ category: string }>;\n      res.json({\n        success: true,\n        data: categories.map((c) => c.category),\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[CmsFeatureController] Get feature categories failed:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new CmsFeatureController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/cmsProvider.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/contentTexts.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎`","line":10,"column":1,"nodeType":null,"messageId":"delete","endLine":11,"endColumn":1,"fix":{"range":[254,255],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Content Texts Controller\n * 艹，文案配置控制器！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport * as textRepo from '../repositories/contentTexts.repo.js';\nimport type { CreateTextInput } from '../repositories/contentTexts.repo.js';\n\n\nexport class ContentTextsController {\n  /**\n   * 列出文案（管理端）\n   */\n  async listTexts(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { page, section, language, status, limit = 50, offset = 0 } = req.query;\n\n      const texts = await textRepo.listTexts({\n        page: page as string,\n        section: section as string,\n        language: language as string,\n        status: status as string,\n        limit: parseInt(limit as string),\n        offset: parseInt(offset as string)\n      });\n\n      res.json({\n        success: true,\n        data: {\n          items: texts,\n          limit: parseInt(limit as string),\n          offset: parseInt(offset as string)\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 列出文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取页面文案（前台）\n   */\n  async getPageTexts(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { page } = req.params;\n      const { language } = req.query;\n\n      const texts = await textRepo.getPageTexts({\n        page,\n        language: (language as string) || 'zh-CN'\n      });\n\n      res.json({\n        success: true,\n        data: texts\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 获取页面文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 获取单个文案\n   */\n  async getText(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const text = await textRepo.getTextById(id);\n\n      if (!text) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '文案不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, data: text });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 获取文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 创建文案\n   */\n  async createText(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const input = req.body as CreateTextInput;\n\n      // 艹，基础校验\n      if (!input.page?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'page不能为空' }\n        });\n        return;\n      }\n\n      if (!input.key?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'key不能为空' }\n        });\n        return;\n      }\n\n      if (!input.value?.trim()) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'value不能为空' }\n        });\n        return;\n      }\n\n      const text = await textRepo.createText(input);\n\n      res.status(201).json({ success: true, data: text });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 创建文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 更新文案\n   */\n  async updateText(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const updates = req.body as Partial<CreateTextInput>;\n\n      const text = await textRepo.updateText(id, updates);\n\n      res.json({ success: true, data: text });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      if (err.message.includes('不存在')) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: err.message }\n        });\n        return;\n      }\n      console.error('[TextsController] 更新文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 删除文案\n   */\n  async deleteText(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const id = parseInt(req.params.id);\n      const deleted = await textRepo.deleteText(id);\n\n      if (!deleted) {\n        res.status(404).json({\n          success: false,\n          error: { code: 'NOT_FOUND', message: '文案不存在' }\n        });\n        return;\n      }\n\n      res.json({ success: true, message: '文案已删除' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 删除文案失败:', err.message);\n      next(err);\n    }\n  }\n\n  /**\n   * 批量导入/更新文案\n   * 艹，支持批量upsert！\n   */\n  async batchUpsertTexts(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { texts } = req.body;\n\n      if (!Array.isArray(texts) || texts.length === 0) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'texts必须是非空数组' }\n        });\n        return;\n      }\n\n      const result = await textRepo.batchUpsertTexts(texts);\n\n      res.json({\n        success: true,\n        data: result,\n        message: `批量导入成功: 创建${result.created}条, 更新${result.updated}条`\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[TextsController] 批量导入文案失败:', err.message);\n      next(err);\n    }\n  }\n}\n\nexport default new ContentTextsController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/distribution.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/feature-catalog.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········(req.user·as·unknown·as·Record<string,·unknown>)?.roles⏎········` with `(req.user·as·unknown·as·Record<string,·unknown>)?.roles`","line":182,"column":37,"nodeType":null,"messageId":"replace","endLine":184,"endColumn":9,"fix":{"range":[4934,5009],"text":"(req.user as unknown as Record<string, unknown>)?.roles"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎············req.user·as·unknown·as·Record<string,·unknown>⏎··········` with `req.user·as·unknown·as·Record<string,·unknown>`","line":188,"column":19,"nodeType":null,"messageId":"replace","endLine":190,"endColumn":11,"fix":{"range":[5160,5230],"text":"req.user as unknown as Record<string, unknown>"}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎················`","line":191,"column":64,"nodeType":null,"messageId":"delete","endLine":192,"endColumn":17,"fix":{"range":[5320,5337],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········(req.user·as·unknown·as·Record<string,·unknown>)?.roles⏎······` with `(req.user·as·unknown·as·Record<string,·unknown>)?.roles`","line":391,"column":35,"nodeType":null,"messageId":"replace","endLine":393,"endColumn":7,"fix":{"range":[11586,11657],"text":"(req.user as unknown as Record<string, unknown>)?.roles"}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎··········`","line":397,"column":64,"nodeType":null,"messageId":"delete","endLine":398,"endColumn":11,"fix":{"range":[11847,11858],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎··············`","line":399,"column":62,"nodeType":null,"messageId":"delete","endLine":400,"endColumn":15,"fix":{"range":[11945,11960],"text":""}}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":6,"fixableWarningCount":0,"source":"import type { Request, Response } from 'express';\nimport { validationResult } from 'express-validator';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport type { SupportedLanguageCode } from '../config/i18n-messages.js';\nimport featureCatalogService from '../services/feature-catalog.service.js';\n\ntype FeatureListQuery = {\n  category?: string;\n  type?: string;\n  is_public?: string;\n  tags?: string;\n  limit?: string;\n  offset?: string;\n  sort_by?: string;\n  sort_order?: string;\n};\n\ntype FeatureUsageBody = {\n  usageCount?: number;\n  metrics?: Record<string, unknown>;\n  cost?: number;\n  status?: string;\n  errorDetails?: unknown;\n};\n\nconst timestamp = (): string => new Date().toISOString();\n\nconst respondValidationError = (\n  req: Request,\n  res: Response,\n  code: number = ERROR_CODES.INVALID_PARAMETERS,\n  fallback = 'Invalid parameters'\n): boolean => {\n  const errors = validationResult(req);\n  if (errors.isEmpty()) {\n    return false;\n  }\n\n  res.status(400).json({\n    success: false,\n    error: {\n      code,\n      message: req.i18n?.getErrorMessage?.(code) ?? fallback,\n      details: errors.array()\n    },\n    timestamp: timestamp()\n  });\n  return true;\n};\n\nconst respondUnauthorized = (req: Request, res: Response): void => {\n  res.status(401).json({\n    success: false,\n    error: {\n      code: ERROR_CODES.UNAUTHORIZED,\n      message: req.i18n?.getErrorMessage?.(ERROR_CODES.UNAUTHORIZED) ?? 'Authentication required'\n    },\n    timestamp: timestamp()\n  });\n};\n\nconst respondNotFound = (req: Request, res: Response, code: number, fallback: string): void => {\n  res.status(404).json({\n    success: false,\n    error: {\n      code,\n      message: req.i18n?.getErrorMessage?.(code) ?? fallback\n    },\n    timestamp: timestamp()\n  });\n};\n\nconst respondForbidden = (req: Request, res: Response, code: number, fallback: string): void => {\n  res.status(403).json({\n    success: false,\n    error: {\n      code,\n      message: req.i18n?.getErrorMessage?.(code) ?? fallback\n    },\n    timestamp: timestamp()\n  });\n};\n\nconst respondGenericSuccess = (\n  res: Response,\n  data?: unknown,\n  message?: string\n): Response<Record<string, unknown>> => {\n  return res.json({\n    success: true,\n    ...(data !== undefined ? { data } : {}),\n    ...(message ? { message } : {}),\n    timestamp: timestamp()\n  });\n};\n\nconst parseBoolean = (value: string | undefined): boolean | undefined => {\n  if (value === 'true') return true;\n  if (value === 'false') return false;\n  return undefined;\n};\n\nconst parseInteger = (value: string | undefined, fallback: number): number => {\n  const parsed = Number.parseInt(value ?? '', 10);\n  return Number.isFinite(parsed) ? parsed : fallback;\n};\n\nconst getLocale = (req: Request): SupportedLanguageCode | undefined => {\n  const locale = req.i18n?.locale;\n  if (locale === 'zh-CN' || locale === 'en-US' || locale === 'ja-JP') {\n    return locale;\n  }\n  return undefined;\n};\n\nclass FeatureCatalogController {\n  async getFeatures(req: Request, res: Response) {\n    try {\n      if (respondValidationError(req, res)) {\n        return;\n      }\n\n      const {\n        category,\n        type,\n        is_public,\n        tags,\n        limit = '20',\n        offset = '0',\n        sort_by = 'name',\n        sort_order = 'asc'\n      } = req.query as FeatureListQuery;\n\n      const normalizedSortOrder: 'asc' | 'desc' =\n        (sort_order?.toLowerCase() as 'asc' | 'desc') === 'desc' ? 'desc' : 'asc';\n\n      const options = {\n        category,\n        type,\n        isPublic: parseBoolean(is_public),\n        tags: tags ? tags.split(',').map((tag) => tag.trim()) : undefined,\n        limit: parseInteger(limit, 20),\n        offset: parseInteger(offset, 0),\n        sortBy: sort_by ?? 'name',\n        sortOrder: normalizedSortOrder\n      };\n\n      const features = await featureCatalogService.getFeatures(options);\n\n      respondGenericSuccess(\n        res,\n        {\n          features,\n          pagination: {\n            limit: options.limit,\n            offset: options.offset,\n            total: features.length\n          }\n        },\n        req.i18n?.getMessage?.('features.retrieved_success') ?? 'Features retrieved successfully'\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get features:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async getFeatureByKey(req: Request<{ featureKey: string }>, res: Response) {\n    try {\n      const { featureKey } = req.params;\n\n      const feature = await featureCatalogService.getFeatureByKey(featureKey);\n      if (!feature) {\n        respondNotFound(req, res, ERROR_CODES.TASK_NOT_FOUND, 'Feature not found');\n        return;\n      }\n\n      if (req.user) {\n        const roles = Array.isArray(\n          (req.user as unknown as Record<string, unknown>)?.roles\n        )\n          ? ((req.user as unknown as Record<string, unknown>).roles as string[])\n          : undefined;\n        const membership =\n          typeof (\n            req.user as unknown as Record<string, unknown>\n          )?.membership === 'string'\n            ? ((req.user as unknown as Record<string, unknown>)\n                .membership as string)\n            : undefined;\n\n        const hasAccess = await featureCatalogService.checkFeatureAccess(featureKey, req.user.id, {\n          roles,\n          membership,\n          ...req.user\n        });\n\n        if (!hasAccess) {\n          respondForbidden(req, res, ERROR_CODES.PERMISSION_DENIED, 'Access denied');\n          return;\n        }\n      }\n\n      const [configurations, permissions] = await Promise.all([\n        featureCatalogService.getFeatureConfigurations(feature.id),\n        featureCatalogService.getFeaturePermissions(feature.id)\n      ]);\n\n      respondGenericSuccess(res, {\n        ...feature,\n        configurations,\n        permissions,\n        hasAccess: true\n      });\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get feature by key:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async getFeatureById(req: Request<{ id: string }>, res: Response) {\n    try {\n      const featureKey = req.params.id;\n\n      const feature = await featureCatalogService.getFeatureByKey(featureKey);\n      if (!feature) {\n        respondNotFound(req, res, ERROR_CODES.TASK_NOT_FOUND, 'Feature not found');\n        return;\n      }\n\n      const [configurations, permissions] = await Promise.all([\n        featureCatalogService.getFeatureConfigurations(feature.id),\n        featureCatalogService.getFeaturePermissions(feature.id)\n      ]);\n\n      respondGenericSuccess(res, {\n        ...feature,\n        configurations,\n        permissions\n      });\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get feature by id:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async createFeature(req: Request, res: Response) {\n    try {\n      if (\n        respondValidationError(req, res, ERROR_CODES.DATA_VALIDATION_FAILED, 'Validation failed')\n      ) {\n        return;\n      }\n\n      if (!req.user) {\n        respondUnauthorized(req, res);\n        return;\n      }\n\n      const featureData = {\n        ...req.body,\n        created_by: req.user.id\n      };\n\n      const feature = await featureCatalogService.createFeature(featureData);\n\n      res.status(201).json({\n        success: true,\n        data: feature,\n        message:\n          req.i18n?.getMessage?.('feature.created_success') ?? 'Feature created successfully',\n        timestamp: timestamp()\n      });\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to create feature:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.TASK_CREATION_FAILED);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async updateFeature(req: Request<{ featureKey: string }>, res: Response) {\n    try {\n      if (\n        respondValidationError(req, res, ERROR_CODES.DATA_VALIDATION_FAILED, 'Validation failed')\n      ) {\n        return;\n      }\n\n      if (!req.user) {\n        respondUnauthorized(req, res);\n        return;\n      }\n\n      const { featureKey } = req.params;\n\n      const updateData = {\n        ...req.body,\n        updated_by: req.user.id,\n        updated_at: new Date()\n      };\n\n      const feature = await featureCatalogService.updateFeature(featureKey, updateData);\n\n      respondGenericSuccess(\n        res,\n        feature,\n        req.i18n?.getMessage?.('feature.updated_success') ?? 'Feature updated successfully'\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to update feature:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async deleteFeature(req: Request<{ featureKey: string }>, res: Response) {\n    try {\n      const { featureKey } = req.params;\n\n      const result = await featureCatalogService.deleteFeature(featureKey);\n\n      respondGenericSuccess(\n        res,\n        { deleted: result },\n        req.i18n?.getMessage?.('feature.deleted_success') ?? 'Feature deleted successfully'\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to delete feature:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async setFeatureConfigurations(req: Request<{ featureKey: string }>, res: Response) {\n    try {\n      const { featureKey } = req.params;\n      const { configurations } = req.body as { configurations?: unknown };\n\n      if (!Array.isArray(configurations)) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: ERROR_CODES.INVALID_PARAMETERS,\n            message:\n              req.i18n?.getErrorMessage?.(ERROR_CODES.INVALID_PARAMETERS) ??\n              'Configurations must be an array'\n          },\n          timestamp: timestamp()\n        });\n        return;\n      }\n\n      const feature = await featureCatalogService.getFeatureByKey(featureKey);\n      if (!feature) {\n        respondNotFound(req, res, ERROR_CODES.TASK_NOT_FOUND, 'Feature not found');\n        return;\n      }\n\n      const result = await featureCatalogService.setFeatureConfigurations(\n        feature.id,\n        configurations\n      );\n\n      respondGenericSuccess(\n        res,\n        result,\n        req.i18n?.getMessage?.('feature.configurations_set_success') ??\n          'Feature configurations set successfully'\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to set feature configurations:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async checkFeatureAccess(req: Request<{ featureKey: string }>, res: Response) {\n    try {\n      if (!req.user) {\n        respondUnauthorized(req, res);\n        return;\n      }\n\n      const { featureKey } = req.params;\n\n      const roles = Array.isArray(\n        (req.user as unknown as Record<string, unknown>)?.roles\n      )\n        ? ((req.user as unknown as Record<string, unknown>).roles as string[])\n        : undefined;\n      const membership =\n        typeof (req.user as unknown as Record<string, unknown>)\n          ?.membership === 'string'\n          ? ((req.user as unknown as Record<string, unknown>)\n              .membership as string)\n          : undefined;\n\n      const hasAccess = await featureCatalogService.checkFeatureAccess(featureKey, req.user.id, {\n        roles,\n        membership,\n        ...req.user\n      });\n\n      respondGenericSuccess(res, {\n        featureKey,\n        hasAccess,\n        userId: req.user.id\n      });\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to check feature access:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async recordFeatureUsage(\n    req: Request<{ featureKey: string }, unknown, FeatureUsageBody>,\n    res: Response\n  ) {\n    try {\n      if (!req.user) {\n        respondUnauthorized(req, res);\n        return;\n      }\n\n      const { featureKey } = req.params;\n      const {\n        usageCount = 1,\n        metrics = {},\n        cost = 0,\n        status = 'success',\n        errorDetails = null\n      } = req.body;\n\n      const normalizedStatus: 'success' | 'failed' = status === 'failed' ? 'failed' : 'success';\n\n      await featureCatalogService.recordFeatureUsage(featureKey, req.user.id, {\n        usageCount,\n        metrics,\n        cost,\n        status: normalizedStatus,\n        errorDetails\n      });\n\n      respondGenericSuccess(\n        res,\n        undefined,\n        req.i18n?.getMessage?.('feature.usage_recorded') ?? 'Feature usage recorded successfully'\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to record feature usage:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async getUsageStats(req: Request, res: Response) {\n    try {\n      const {\n        feature_key,\n        user_id,\n        start_date,\n        end_date,\n        group_by = 'day'\n      } = req.query as Record<string, string | undefined>;\n\n      const normalizedGroupBy: 'day' | 'feature' | 'user' =\n        group_by === 'feature' ? 'feature' : group_by === 'user' ? 'user' : 'day';\n\n      const options = {\n        featureKey: feature_key,\n        userId: user_id,\n        startDate: start_date,\n        endDate: end_date,\n        groupBy: normalizedGroupBy\n      };\n\n      const stats = await featureCatalogService.getUsageStats(options);\n\n      respondGenericSuccess(res, {\n        stats,\n        filters: options\n      });\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get usage stats:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async getServiceStats(req: Request, res: Response) {\n    try {\n      const stats = featureCatalogService.getStats();\n      respondGenericSuccess(res, stats);\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get service stats:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n\n  async getFeatureCategories(req: Request, res: Response) {\n    try {\n      const categories = [\n        { value: 'image_processing', label: '图片处理', description: '图像编辑、滤镜、增强等' },\n        { value: 'ai_generation', label: 'AI生成', description: '文本生成、图像生成、音频生成等' },\n        { value: 'video_processing', label: '视频处理', description: '视频编辑、转换、压缩等' },\n        { value: 'audio_processing', label: '音频处理', description: '音频编辑、转换、降噪等' },\n        { value: 'text_processing', label: '文本处理', description: '文本分析、翻译、摘要等' },\n        { value: 'data_analysis', label: '数据分析', description: '数据可视化、统计分析等' },\n        { value: 'file_management', label: '文件管理', description: '文件上传、存储、转换等' },\n        { value: 'user_management', label: '用户管理', description: '用户认证、权限管理等' },\n        { value: 'payment', label: '支付功能', description: '支付处理、订单管理等' },\n        { value: 'integration', label: '集成功能', description: '第三方服务集成、API对接等' }\n      ];\n\n      respondGenericSuccess(res, categories);\n    } catch (error) {\n      logger.error('[FeatureCatalogController] Failed to get feature categories:', error);\n      const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n      res.status(appError.statusCode).json(appError.toJSON(getLocale(req)));\n    }\n  }\n}\n\nconst featureCatalogController = new FeatureCatalogController();\nexport default featureCatalogController;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/feature.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/importExport.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":22,"column":12,"nodeType":null,"messageId":"replace","endLine":22,"endColumn":24,"fix":{"range":[624,636],"text":"\n          .status(400)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400).json({·success:·false,·error:·{·code:·'VALIDATION_ERROR',·message:·'CSV数据必须是字符串'·}` with `⏎············.status(400)⏎············.json({⏎··············success:·false,⏎··············error:·{·code:·'VALIDATION_ERROR',·message:·'CSV数据必须是字符串'·}⏎···········`","line":82,"column":14,"nodeType":null,"messageId":"replace","endLine":82,"endColumn":109,"fix":{"range":[2307,2402],"text":"\n            .status(400)\n            .json({\n              success: false,\n              error: { code: 'VALIDATION_ERROR', message: 'CSV数据必须是字符串' }\n           "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·(` with `⏎··········`","line":88,"column":21,"nodeType":null,"messageId":"replace","endLine":88,"endColumn":23,"fix":{"range":[2581,2583],"text":"\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":89,"column":1,"nodeType":null,"messageId":"insert","endLine":89,"endColumn":1,"fix":{"range":[2608,2608],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `:·(data·as·ContentTextExport[])` with `··:·(data·as·ContentTextExport[]`","line":90,"column":11,"nodeType":null,"messageId":"replace","endLine":90,"endColumn":42,"fix":{"range":[2693,2724],"text":"  : (data as ContentTextExport[]"}}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":5,"fixableWarningCount":0,"source":"/**\n * Import/Export Controller\n * 艹，批量导入导出控制器！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport * as importExportService from '../services/importExport.service.js';\nimport type { ContentTextExport } from '../services/importExport.service.js';\n\ninterface ImportExportOptions extends Record<string, unknown> {\n  format?: 'json' | 'csv';\n}\n\nexport class ImportExportController {\n  /**\n   * 导出实体数据\n   */\n  async exportEntity(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { entityType } = req.params as { entityType?: string };\n      if (!entityType) {\n        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: '缺少实体类型' } });\n        return;\n      }\n      const { format = 'json', ...options } = req.query as ImportExportOptions &\n        Record<string, unknown>;\n\n      if (!['json', 'csv'].includes(format as string)) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'format必须是json或csv' }\n        });\n        return;\n      }\n\n      const data = await importExportService.exportEntity(\n        entityType,\n        format as 'json' | 'csv',\n        options\n      );\n\n      // 艹，设置响应头\n      if (format === 'csv') {\n        res.setHeader('Content-Type', 'text/csv; charset=utf-8');\n        res.setHeader(\n          'Content-Disposition',\n          `attachment; filename=\"${entityType}_${Date.now()}.csv\"`\n        );\n        res.send(data);\n      } else {\n        res.json({\n          success: true,\n          data\n        });\n      }\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[ImportExportController] 导出失败:', err.message);\n      next(error);\n    }\n  }\n\n  /**\n   * 导入文案数据\n   */\n  async importContentTexts(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { data, format = 'json' } = req.body as Record<string, unknown>;\n\n      if (!data) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'data不能为空' }\n        });\n        return;\n      }\n\n      let parsedData: ContentTextExport[];\n\n      if (format === 'csv') {\n        if (typeof data !== 'string') {\n          res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: 'CSV数据必须是字符串' } });\n          return;\n        }\n        parsedData = importExportService.parseCSV(data) as unknown as ContentTextExport[];\n      } else {\n        // 艹，解析JSON\n        parsedData = (typeof data === 'string'\n          ? (JSON.parse(data as string) as unknown as ContentTextExport[])\n          : (data as ContentTextExport[]));\n      }\n\n      if (!Array.isArray(parsedData) || parsedData.length === 0) {\n        res.status(400).json({\n          success: false,\n          error: { code: 'VALIDATION_ERROR', message: 'data必须是非空数组' }\n        });\n        return;\n      }\n\n      const result = await importExportService.importContentTextsJSON(parsedData);\n\n      res.json({\n        success: true,\n        data: result,\n        message: `导入成功: 创建${result.created}条, 更新${result.updated}条`\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      console.error('[ImportExportController] 导入失败:', err.message);\n      next(error);\n    }\n  }\n}\n\nexport default new ImportExportController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/invite-code.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace ``[InviteCodeController]·Invite·code·validation:·${code}·->·${(result·as·{·valid?:·unknown·})?.valid}`` with `⏎········`[InviteCodeController]·Invite·code·validation:·${code}·->·${(result·as·{·valid?:·unknown·})?.valid}`⏎······`","line":109,"column":19,"nodeType":null,"messageId":"replace","endLine":109,"endColumn":120,"fix":{"range":[3293,3394],"text":"\n        `[InviteCodeController] Invite code validation: ${code} -> ${(result as { valid?: unknown })?.valid}`\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":169,"column":12,"nodeType":null,"messageId":"replace","endLine":169,"endColumn":24,"fix":{"range":[5731,5743],"text":"\n          .status(400)\n          "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport inviteCodeService from '../services/invite-code.service.js';\n\ninterface GenerateCodesBody {\n  count?: number;\n  type?: string;\n  maxUses?: number;\n  validDays?: number;\n  batchName?: string | null;\n  description?: string | null;\n}\n\ninterface CodeItem {\n  expires_at?: unknown;\n}\n\n/**\n * 邀请码控制器（TS版）\n */\nclass InviteCodeController {\n  async generateInviteCodes(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const {\n        count = 10,\n        type = 'general',\n        maxUses = 1,\n        validDays = 30,\n        batchName = null,\n        description = null\n      } = (req.body ?? {}) as GenerateCodesBody;\n\n      if (!Number.isInteger(count) || count < 1 || count > 1000) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'count',\n          message: '生成数量必须在1-1000之间'\n        });\n      }\n      if (!['general', 'vip', 'special', 'limited'].includes(String(type))) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'type',\n          message: '无效的邀请码类型'\n        });\n      }\n      if (!Number.isInteger(maxUses) || maxUses < 1 || maxUses > 100) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'maxUses',\n          message: '最大使用次数必须在1-100之间'\n        });\n      }\n      if (!Number.isInteger(validDays) || validDays < 1 || validDays > 365) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'validDays',\n          message: '有效天数必须在1-365之间'\n        });\n      }\n\n      const user = req.user as { id?: string } | undefined;\n      const createdBy = user?.id || 'system';\n\n      const options = {\n        count: Number(count),\n        type: String(type),\n        maxUses: Number(maxUses),\n        validDays: Number(validDays),\n        batchName: batchName as string | null,\n        description: description as string | null,\n        createdBy\n      };\n\n      const codes = await inviteCodeService.generateInviteCodes(options);\n      logger.info(\n        `[InviteCodeController] User ${createdBy} generated ${codes.length} invite codes`\n      );\n\n      const firstCode = codes?.[0] as CodeItem | undefined;\n      res.json({\n        success: true,\n        message: `成功生成${codes.length}个邀请码`,\n        data: {\n          codes,\n          summary: {\n            total: codes.length,\n            type: options.type,\n            maxUses: options.maxUses,\n            validDays: options.validDays,\n            expiresAt: firstCode?.expires_at\n          }\n        }\n      });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to generate invite codes:', error);\n      next(error);\n    }\n  }\n\n  async validateInviteCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { code } = req.body ?? {};\n      if (!code || typeof code !== 'string') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'code',\n          message: '邀请码不能为空'\n        });\n      }\n      const result = await inviteCodeService.validateInviteCode(code);\n      logger.info(`[InviteCodeController] Invite code validation: ${code} -> ${(result as { valid?: unknown })?.valid}`);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to validate invite code:', error);\n      next(error);\n    }\n  }\n\n  async useInviteCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { code, inviterId, inviteeEmail, inviteePhone } = req.body ?? {};\n      if (!code || typeof code !== 'string') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'code',\n          message: '邀请码不能为空'\n        });\n      }\n      const user = req.user as { id?: string } | undefined;\n      const usageData = {\n        userId: user?.id,\n        inviterId,\n        inviteeEmail,\n        inviteePhone\n      };\n      const result = await inviteCodeService.useInviteCode(code, usageData);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to use invite code:', error);\n      next(error);\n    }\n  }\n\n  async getInviteCodes(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const sortOrderParam = (req.query.sortOrder as string | undefined)?.toLowerCase();\n      const sortOrder: 'asc' | 'desc' = sortOrderParam === 'asc' ? 'asc' : 'desc';\n      const options = {\n        type: req.query.type as string | undefined,\n        status: req.query.status as string | undefined,\n        creatorId: req.query.creatorId as string | undefined,\n        inviterId: req.query.inviterId as string | undefined,\n        inviteeId: req.query.inviteeId as string | undefined,\n        page: req.query.page ? Number(req.query.page) : 1,\n        limit: req.query.limit ? Number(req.query.limit) : 20,\n        sortBy: (req.query.sortBy as string | undefined) ?? 'created_at',\n        sortOrder\n      };\n      const codes = await inviteCodeService.getInviteCodes(options);\n      res.json({ success: true, data: codes });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to get invite codes:', error);\n      next(error);\n    }\n  }\n\n  async getUserInviteStats(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const user = req.user as { id?: string } | undefined;\n      const targetUserId = (req.params?.userId as string | undefined) ?? user?.id;\n      if (!targetUserId) {\n        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: '缺少用户ID' } });\n        return;\n      }\n      const stats = await inviteCodeService.getUserInviteStats(targetUserId);\n      res.json({ success: true, data: stats });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to get user invite stats:', error);\n      next(error);\n    }\n  }\n\n  async getInviteUsageLogs(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const sortBy = (req.query.sortBy as string | undefined)?.toLowerCase();\n      const sortOrderParam = (req.query.sortOrder as string | undefined)?.toLowerCase();\n      const normalizedSortBy: 'created_at' | 'updated_at' =\n        sortBy === 'updated_at' ? 'updated_at' : 'created_at';\n      const normalizedSortOrder: 'asc' | 'desc' = sortOrderParam === 'asc' ? 'asc' : 'desc';\n\n      const options = {\n        inviteCodeId: req.query.inviteCodeId as string | undefined,\n        inviterId: req.query.inviterId as string | undefined,\n        inviteeId: req.query.inviteeId as string | undefined,\n        status: req.query.status as string | undefined,\n        page: req.query.page ? Number(req.query.page) : 1,\n        limit: req.query.limit ? Number(req.query.limit) : 20,\n        sortBy: normalizedSortBy,\n        sortOrder: normalizedSortOrder\n      };\n      const logs = await inviteCodeService.getInviteUsageLogs(options);\n      res.json({ success: true, data: logs });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to get invite usage logs:', error);\n      next(error);\n    }\n  }\n\n  async disableInviteCode(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { code } = req.params as { code: string };\n      const success = await inviteCodeService.disableInviteCode(code);\n      res.json({ success, message: success ? '禁用成功' : '禁用失败' });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to disable invite code:', error);\n      next(error);\n    }\n  }\n\n  async getInviteCodeStats(_req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const stats = await inviteCodeService.getInviteCodeStats();\n      res.json({ success: true, data: stats });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to get invite code stats:', error);\n      next(error);\n    }\n  }\n\n  async cleanupExpiredCodes(_req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await inviteCodeService.cleanupExpiredCodes();\n      res.json({ success: true, message: '清理完成' });\n    } catch (error) {\n      logger.error('[InviteCodeController] Failed to cleanup expired codes:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new InviteCodeController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/kms.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/kms.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const kmsController: {\n  listKeys: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getKey: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  createKey: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateKey: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  deleteKey: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n};\n\nexport default kmsController;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/kms.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1781,1784],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1781,1784],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3210,3213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3210,3213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4377,4380],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4377,4380],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5305,5308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5305,5308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8272,8275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8272,8275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport { db as knex } from '../config/database.js';\nimport type {\n  KeyGenerationConfig,\n  KeyListQuery,\n  EncryptRequest,\n  DecryptRequest,\n  DeleteKeyOptions\n} from '../types/kms.types.js';\nimport type { Knex } from 'knex';\n\nclass KMSController {\n  async generateKey(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const {\n        keyName,\n        keyAlias,\n        keyType = 'AES',\n        keyPurpose = 'data_encryption',\n        keySize,\n        algorithm,\n        metadata = {},\n        notAfter\n      } = (req.body ?? {}) as KeyGenerationConfig & { keyName: string };\n\n      if (!keyName || !String(keyName).trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyName',\n          message: '密钥名称不能为空'\n        });\n      }\n      if (!['AES', 'RSA', 'HMAC'].includes(String(keyType))) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyType',\n          message: '无效的密钥类型'\n        });\n      }\n      if (\n        !['data_encryption', 'signing', 'verification', 'key_exchange'].includes(String(keyPurpose))\n      ) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyPurpose',\n          message: '无效的密钥用途'\n        });\n      }\n\n      let validKeySize = keySize as number | undefined;\n      if (!validKeySize) {\n        if (keyType === 'AES' || keyType === 'HMAC') validKeySize = 256;\n        else if (keyType === 'RSA') validKeySize = 2048;\n      }\n\n      const kmsMod = await import('../services/kms.service.js');\n      const svc: any = kmsMod.default ?? kmsMod;\n      const key = await svc.generateKey({\n        keyName: String(keyName).trim(),\n        keyAlias,\n        keyType,\n        keyPurpose,\n        keySize: validKeySize,\n        algorithm: algorithm || `${keyType}-${validKeySize}${keyType === 'AES' ? '-GCM' : ''}`,\n        metadata,\n        notAfter: notAfter ? new Date(notAfter) : null\n      });\n\n      logger.info(`[KMSController] User ${req.user?.id ?? 'unknown'} generated key: ${keyName}`);\n      res.json({ success: true, message: '密钥生成成功', data: key });\n    } catch (error) {\n      logger.error('[KMSController] Failed to generate key:', error);\n      next(error);\n    }\n  }\n\n  async encrypt(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const {\n        data,\n        keyNameOrId,\n        dataType = 'general',\n        resourceId,\n        resourceType,\n        additionalData = ''\n      } = (req.body ?? {}) as EncryptRequest;\n      if (!data || typeof data !== 'string') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'data',\n          message: '要加密的数据不能为空'\n        });\n      }\n      if (!keyNameOrId || !String(keyNameOrId).trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyNameOrId',\n          message: '密钥名称或ID不能为空'\n        });\n      }\n      const kmsMod = await import('../services/kms.service.js');\n      const svc: any = kmsMod.default ?? kmsMod;\n      const result = await svc.encrypt({\n        data,\n        keyNameOrId: String(keyNameOrId).trim(),\n        options: { dataType, resourceId, resourceType, additionalData }\n      });\n      res.json({ success: true, data: result });\n    } catch (error) {\n      logger.error('[KMSController] Failed to encrypt:', error);\n      next(error);\n    }\n  }\n\n  async decrypt(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const {\n        cipherText,\n        keyNameOrId,\n        dataType = 'general',\n        resourceId,\n        resourceType,\n        additionalData = ''\n      } = (req.body ?? {}) as DecryptRequest;\n      if (!cipherText || typeof cipherText !== 'string') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'cipherText',\n          message: '密文不能为空'\n        });\n      }\n      if (!keyNameOrId || !String(keyNameOrId).trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyNameOrId',\n          message: '密钥名称或ID不能为空'\n        });\n      }\n      const kmsMod = await import('../services/kms.service.js');\n      const svc: any = kmsMod.default ?? kmsMod;\n      const result = await svc.decrypt({\n        cipherText,\n        keyNameOrId: String(keyNameOrId).trim(),\n        options: { dataType, resourceId, resourceType, additionalData }\n      });\n      res.json({ success: true, data: result });\n    } catch (error) {\n      logger.error('[KMSController] Failed to decrypt:', error);\n      next(error);\n    }\n  }\n\n  async deleteKey(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { keyNameOrId } = req.params as { keyNameOrId: string };\n      const { force = false } = (req.query ?? {}) as Record<string, string | boolean>;\n      if (!keyNameOrId || !String(keyNameOrId).trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'keyNameOrId',\n          message: '密钥名称或ID不能为空'\n        });\n      }\n      const kmsMod = await import('../services/kms.service.js');\n      const svc: any = kmsMod.default ?? kmsMod;\n      const options: DeleteKeyOptions = {\n        force: force === 'true' || force === true\n      };\n      const success = await svc.deleteKey(String(keyNameOrId).trim(), options);\n      if (!success) {\n        throw AppError.create(ERROR_CODES.INTERNAL_SERVER_ERROR, {\n          message: '密钥删除失败'\n        });\n      }\n      logger.info(`[KMSController] User ${req.user?.id ?? 'unknown'} deleted key: ${keyNameOrId}`);\n      res.json({ success: true, message: '密钥删除成功' });\n    } catch (error) {\n      logger.error('[KMSController] Failed to delete key:', error);\n      next(error);\n    }\n  }\n\n  async listKeys(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const {\n        keyType,\n        keyPurpose,\n        status,\n        page = '1',\n        limit = '20',\n        sortBy = 'created_at',\n        sortOrder = 'desc'\n      } = (req.query ?? {}) as KeyListQuery;\n      const validSortFields = ['created_at', 'updated_at', 'key_name', 'key_type'];\n      const sortField = validSortFields.includes(String(sortBy)) ? sortBy : 'created_at';\n      const pageNum = Number.parseInt(String(page), 10);\n      const limitNum = Number.parseInt(String(limit), 10);\n      const offset = (pageNum - 1) * limitNum;\n\n      let query: Knex.QueryBuilder = knex('encryption_keys').select(\n        'id',\n        'key_name',\n        'key_alias',\n        'key_type',\n        'key_purpose',\n        'key_size',\n        'key_algorithm',\n        'key_version',\n        'status',\n        'is_primary',\n        'not_before',\n        'not_after',\n        'created_at',\n        'updated_at'\n      );\n      if (keyType) query = query.where('key_type', keyType);\n      if (keyPurpose) query = query.where('key_purpose', keyPurpose);\n      if (status) query = query.where('status', status);\n      query = query\n        .orderBy(sortField, sortOrder === 'asc' ? 'asc' : 'desc')\n        .limit(limitNum)\n        .offset(offset);\n\n      const keys = await query;\n      let countQuery: Knex.QueryBuilder = knex('encryption_keys');\n      if (keyType) countQuery = countQuery.where('key_type', keyType);\n      if (keyPurpose) countQuery = countQuery.where('key_purpose', keyPurpose);\n      if (status) countQuery = countQuery.where('status', status);\n      const totalCount = (await countQuery.count('* as count').first()) as\n        | { count: number }\n        | undefined;\n\n      res.json({\n        success: true,\n        data: {\n          keys,\n          pagination: { page: pageNum, limit: limitNum, total: Number(totalCount?.count ?? 0) }\n        }\n      });\n    } catch (error) {\n      logger.error('[KMSController] Failed to list keys:', error);\n      next(error);\n    }\n  }\n\n  // 路由兼容方法（与 kms.routes.ts 对齐）\n  async getKey(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { id } = req.params as { id: string };\n      const kmsMod = await import('../services/kms.service.js');\n      const svc: any = kmsMod.default ?? kmsMod;\n      const info = await svc.getKeyInfo?.(String(id));\n      res.json({ success: true, data: info ?? [], requestId: req.id });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async createKey(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 兼容：将 name 映射到 keyName\n      const body = req.body as Record<string, unknown>;\n      body.keyName = body.name ?? body.keyName;\n      await this.generateKey(req, res, next);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateKey(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      // 兼容：暂时返回成功，实际应调用 rotateKey\n      res.json({ success: true, message: '密钥更新功能暂未实现（需要密钥轮换）' });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nexport default new KMSController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/mcpEndpoint.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/mcpEndpoint.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const mcpEndpointController: {\n  getEndpoints: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getEndpointStats: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getServerTypes: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getTemplates: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  batchTestEndpoints: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  healthCheck: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getEndpointById: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  testEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  connectEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  disconnectEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  discoverTools: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  executeTool: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  createEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  deleteEndpoint: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n};\n\nexport default mcpEndpointController;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/mcpEndpoint.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/media.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/membership.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":50,"column":12,"nodeType":null,"messageId":"replace","endLine":50,"endColumn":24,"fix":{"range":[1669,1681],"text":"\n          .status(400)\n          "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport membershipService, {\n  type PaymentCallbackData,\n  type PaymentChannel\n} from '../services/membership.service.js';\nimport logger from '../utils/logger.js';\n\nconst getUserIdOrRespond = (req: Request, res: Response): string | null => {\n  const userId = req.user?.id;\n  if (!userId) {\n    res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未登录' } });\n    return null;\n  }\n  return userId;\n};\n\nconst isValidCallbackData = (payload: unknown): payload is PaymentCallbackData => {\n  if (!payload || typeof payload !== 'object') return false;\n  const data = payload as Record<string, unknown>;\n  return (\n    typeof data.orderId === 'string' &&\n    typeof data.transactionId === 'string' &&\n    (data.channel === 'wx' || data.channel === 'alipay')\n  );\n};\n\nclass MembershipController {\n  async purchase(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = getUserIdOrRespond(req, res);\n      if (!userId) return;\n      const { channel } = req.body as { channel?: string };\n      if (channel !== 'wx' && channel !== 'alipay') {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 5003, message: '支付渠道参数错误' } });\n        return;\n      }\n      const result = await membershipService.purchase(userId, channel as PaymentChannel);\n      res.json({ success: true, data: result });\n    } catch (error: unknown) {\n      next(error);\n    }\n  }\n\n  async paymentCallback(req: Request, res: Response, next: NextFunction) {\n    try {\n      const callbackData = req.body;\n      if (!isValidCallbackData(callbackData)) {\n        res.status(400).json({ success: false, error: { code: 'VALIDATION_ERROR', message: '回调参数无效' } });\n        return;\n      }\n      await membershipService.handlePaymentCallback(callbackData);\n      res.json({ success: true });\n    } catch (error: unknown) {\n      logger.error('支付回调处理失败:', error);\n      next(error);\n    }\n  }\n\n  async getStatus(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = getUserIdOrRespond(req, res);\n      if (!userId) return;\n      const status = await membershipService.getStatus(userId);\n      res.json({ success: true, data: status });\n    } catch (error: unknown) {\n      next(error);\n    }\n  }\n}\n\nexport default new MembershipController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/membershipBenefits.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/membershipPlans.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/payment.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(401)` with `⏎······.status(401)⏎······`","line":32,"column":8,"nodeType":null,"messageId":"replace","endLine":32,"endColumn":20,"fix":{"range":[942,954],"text":"\n      .status(401)\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········page·=·'1',⏎········limit·=·'20',⏎········status,⏎········paymentMethod⏎·····` with `·page·=·'1',·limit·=·'20',·status,·paymentMethod`","line":183,"column":14,"nodeType":null,"messageId":"replace","endLine":188,"endColumn":6,"fix":{"range":[5453,5539],"text":" page = '1', limit = '20', status, paymentMethod"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········.where('order_no',·out_trade_no)⏎··········.first())·as·PaymentOrder` with `.where('order_no',·out_trade_no).first())·as⏎··········|·PaymentOrder⏎·········`","line":276,"column":56,"nodeType":null,"messageId":"replace","endLine":278,"endColumn":36,"fix":{"range":[9006,9085],"text":".where('order_no', out_trade_no).first()) as\n          | PaymentOrder\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········.where('order_no',·out_trade_no)⏎··········.first())·as·PaymentOrder` with `.where('order_no',·out_trade_no).first())·as⏎··········|·PaymentOrder⏎·········`","line":311,"column":56,"nodeType":null,"messageId":"replace","endLine":313,"endColumn":36,"fix":{"range":[10125,10204],"text":".where('order_no', out_trade_no).first()) as\n          | PaymentOrder\n         "}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport { validationResult } from 'express-validator';\nimport logger from '../utils/logger.js';\nimport paymentService from '../services/payment.service.js';\nimport { db } from '../config/database.js';\nimport type {\n  CreatePaymentOrderRequest,\n  CreateRefundRequest,\n  PaymentRecordsQuery,\n  RefundRecordsQuery,\n  PaymentOrder,\n  RefundRecord,\n  PaymentService,\n  OrderStatusResponse\n} from '../types/payment.types.js';\nimport type { Knex } from 'knex';\n\nconst paymentSvc = paymentService as unknown as PaymentService;\n\nconst toNumber = (value: unknown): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') {\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : 0;\n  }\n  return 0;\n};\n\nconst requireUserId = (req: Request, res: Response): string | null => {\n  const userId = req.user?.id;\n  if (!userId) {\n    res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: '未授权操作' } });\n    return null;\n  }\n  return userId;\n};\n\nclass PaymentController {\n  async createPaymentOrder(req: Request, res: Response): Promise<void> {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '请求参数验证失败',\n            details: errors.array()\n          }\n        });\n        return;\n      }\n\n      const {\n        productType,\n        productId,\n        productName,\n        productDescription,\n        amount,\n        paymentMethod,\n        returnUrl,\n        notifyUrl\n      } = req.body as CreatePaymentOrderRequest;\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n\n      const result = await paymentSvc.createPaymentOrder(userId, {\n        productType,\n        productId,\n        productName,\n        productDescription,\n        amount,\n        paymentMethod,\n        returnUrl,\n        notifyUrl\n      });\n\n      res.json({\n        success: true,\n        data: result,\n        message: '支付订单创建成功',\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[PaymentController] 创建支付订单失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'CREATE_ORDER_ERROR', message: err?.message || '创建支付订单失败' },\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  async handleAlipayNotify(req: Request, res: Response): Promise<void> {\n    try {\n      logger.info('[PaymentController] 收到支付宝回调:', req.body);\n      const result = await paymentSvc.handleAlipayCallback(req.body);\n      res.send(result?.success ? 'success' : 'fail');\n    } catch (error) {\n      logger.error('[PaymentController] 处理支付宝回调失败:', error);\n      res.send('fail');\n    }\n  }\n\n  async handleWechatNotify(req: Request, res: Response): Promise<void> {\n    try {\n      logger.info('[PaymentController] 收到微信回调:', req.body);\n      const result = await paymentSvc.handleWechatCallback(req.body);\n      if (result?.success) {\n        res.json({ code: 'SUCCESS', message: 'success' });\n      } else {\n        res.json({ code: 'FAIL', message: result?.message || 'fail' });\n      }\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[PaymentController] 处理微信回调失败:', error);\n      res.json({ code: 'FAIL', message: err?.message || 'fail' });\n    }\n  }\n\n  async createRefund(req: Request, res: Response): Promise<void> {\n    try {\n      const errors = validationResult(req);\n      if (!errors.isEmpty()) {\n        res.status(400).json({\n          success: false,\n          error: {\n            code: 'VALIDATION_ERROR',\n            message: '请求参数验证失败',\n            details: errors.array()\n          }\n        });\n        return;\n      }\n\n      const { orderId, refundAmount, refundReason } = req.body as CreateRefundRequest;\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n      const result = await paymentSvc.createRefund(orderId, userId, {\n        refundAmount,\n        refundReason\n      });\n      res.json({\n        success: true,\n        data: result,\n        message: '退款申请提交成功',\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[PaymentController] 创建退款失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'CREATE_REFUND_ERROR', message: err?.message || '创建退款失败' },\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  async getOrderStatus(req: Request, res: Response): Promise<void> {\n    try {\n      const { orderId } = req.params as { orderId: string };\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n      const order = await paymentSvc.getOrderStatus(orderId, userId);\n      res.json({ success: true, data: order, timestamp: new Date().toISOString() });\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[PaymentController] 查询订单状态失败:', error);\n      res.status(404).json({\n        success: false,\n        error: { code: 'ORDER_NOT_FOUND', message: err?.message || '订单不存在' },\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  async getUserPaymentRecords(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n      const {\n        page = '1',\n        limit = '20',\n        status,\n        paymentMethod\n      } = req.query as PaymentRecordsQuery;\n      const offset = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n      let query: Knex.QueryBuilder = db('payment_orders')\n        .where('user_id', userId)\n        .orderBy('created_at', 'desc')\n        .limit(parseInt(limit, 10))\n        .offset(offset);\n      if (status) query = query.where('status', status);\n      if (paymentMethod) query = query.where('payment_method', paymentMethod);\n      const orders = (await query) as PaymentOrder[];\n      let countQuery: Knex.QueryBuilder = db('payment_orders').where('user_id', userId);\n      if (status) countQuery = countQuery.where('status', status);\n      const totalRows = await countQuery.count<{ count: string | number }[]>('* as count');\n      const total = toNumber(totalRows[0]?.count);\n      res.json({\n        success: true,\n        data: {\n          orders,\n          pagination: {\n            page: parseInt(page, 10),\n            limit: parseInt(limit, 10),\n            total,\n            pages: Math.ceil(total / parseInt(limit, 10))\n          }\n        },\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      logger.error('[PaymentController] 获取支付记录失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'GET_RECORDS_ERROR', message: '获取支付记录失败' }\n      });\n    }\n  }\n\n  async getUserRefundRecords(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n      const { page = '1', limit = '20', status } = req.query as RefundRecordsQuery;\n      const offset = (parseInt(page, 10) - 1) * parseInt(limit, 10);\n      let query: Knex.QueryBuilder = db('refund_records')\n        .leftJoin('payment_orders', 'refund_records.order_id', 'payment_orders.id')\n        .select(\n          'refund_records.*',\n          'payment_orders.product_name',\n          'payment_orders.order_no as original_order_no'\n        )\n        .where('refund_records.user_id', userId)\n        .orderBy('refund_records.created_at', 'desc')\n        .limit(parseInt(limit, 10))\n        .offset(offset);\n      if (status) query = query.where('refund_records.status', status);\n      const refunds = (await query) as RefundRecord[];\n      let countQuery: Knex.QueryBuilder = db('refund_records').where('user_id', userId);\n      if (status) countQuery = countQuery.where('status', status);\n      const totalRows = await countQuery.count<{ count: string | number }[]>('* as count');\n      const total = toNumber(totalRows[0]?.count);\n      res.json({\n        success: true,\n        data: {\n          refunds,\n          pagination: {\n            page: parseInt(page, 10),\n            limit: parseInt(limit, 10),\n            total,\n            pages: Math.ceil(total / parseInt(limit, 10))\n          }\n        },\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      logger.error('[PaymentController] 获取退款记录失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'GET_REFUNDS_ERROR', message: '获取退款记录失败' }\n      });\n    }\n  }\n\n  async paymentSuccess(req: Request, res: Response): Promise<void> {\n    try {\n      const { orderId, out_trade_no } = req.query as Record<string, string>;\n      let order: OrderStatusResponse | null = null;\n      if (orderId) {\n        order = await paymentSvc.getOrderStatus(orderId);\n      } else if (out_trade_no) {\n        const orderRecord = (await db('payment_orders')\n          .where('order_no', out_trade_no)\n          .first()) as PaymentOrder | undefined;\n        if (orderRecord) {\n          order = await paymentSvc.getOrderStatus(orderRecord.id);\n        }\n      }\n      if (!order) {\n        res\n          .status(404)\n          .json({ success: false, error: { code: 'ORDER_NOT_FOUND', message: '订单不存在' } });\n        return;\n      }\n      res.json({\n        success: true,\n        data: order,\n        message: '支付成功',\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      logger.error('[PaymentController] 支付成功页面处理失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'PAYMENT_SUCCESS_ERROR', message: '处理支付成功页面失败' }\n      });\n    }\n  }\n\n  async paymentCancel(req: Request, res: Response): Promise<void> {\n    try {\n      const { orderId, out_trade_no } = req.query as Record<string, string>;\n      let order: OrderStatusResponse | null = null;\n      if (orderId) {\n        order = await paymentSvc.getOrderStatus(orderId);\n      } else if (out_trade_no) {\n        const orderRecord = (await db('payment_orders')\n          .where('order_no', out_trade_no)\n          .first()) as PaymentOrder | undefined;\n        if (orderRecord) {\n          order = await paymentSvc.getOrderStatus(orderRecord.id);\n        }\n      }\n      if (order && order.status === 'pending') {\n        await db('payment_orders')\n          .where('id', order.orderId)\n          .update({ status: 'cancelled', updated_at: new Date() });\n        order = { ...order, status: 'cancelled' };\n      }\n      res.json({\n        success: true,\n        data: order,\n        message: '支付已取消',\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      logger.error('[PaymentController] 支付取消页面处理失败:', error);\n      res.status(500).json({\n        success: false,\n        error: { code: 'PAYMENT_CANCEL_ERROR', message: '处理支付取消页面失败' }\n      });\n    }\n  }\n\n  async getPaymentStats(req: Request, res: Response): Promise<void> {\n    try {\n      const userId = requireUserId(req, res);\n      if (!userId) return;\n      const [totalOrders, paidOrders, totalAmount, totalRefunds, refundAmount] = await Promise.all([\n        db('payment_orders').where('user_id', userId).count('* as count').first(),\n        db('payment_orders').where({ user_id: userId, status: 'paid' }).count('* as count').first(),\n        db('payment_orders')\n          .where({ user_id: userId, status: 'paid' })\n          .sum('amount as total')\n          .first(),\n        db('refund_records')\n          .where({ user_id: userId, status: 'success' })\n          .count('* as count')\n          .first(),\n        db('refund_records')\n          .where({ user_id: userId, status: 'success' })\n          .sum('refund_amount as total')\n          .first()\n      ]);\n      res.json({\n        success: true,\n        data: {\n          totalOrders: toNumber((totalOrders as { count?: string | number } | undefined)?.count),\n          paidOrders: toNumber((paidOrders as { count?: string | number } | undefined)?.count),\n          totalAmount: toNumber((totalAmount as { total?: string | number } | undefined)?.total),\n          totalRefunds: toNumber((totalRefunds as { count?: string | number } | undefined)?.count),\n          refundAmount: toNumber((refundAmount as { total?: string | number } | undefined)?.total)\n        },\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      logger.error('[PaymentController] 获取支付统计失败:', error);\n      res\n        .status(500)\n        .json({ success: false, error: { code: 'GET_STATS_ERROR', message: '获取支付统计失败' } });\n    }\n  }\n}\n\nexport default new PaymentController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/pipelineExecution.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·ExecutionMode,·ExecutionStatus,·PipelineExecution·` with `⏎··ExecutionMode,⏎··ExecutionStatus,⏎··PipelineExecution⏎`","line":6,"column":14,"nodeType":null,"messageId":"replace","endLine":6,"endColumn":65,"fix":{"range":[300,351],"text":"\n  ExecutionMode,\n  ExecutionStatus,\n  PipelineExecution\n"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport pipelineExecutionService from '../services/pipelineExecution.service.js';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport type { ExecutionMode, ExecutionStatus, PipelineExecution } from '../engine/pipeline-types.js';\n\ninterface CreateExecutionBody {\n  schema_id: string;\n  input_data?: Record<string, unknown>;\n  mode?: string;\n}\n\ninterface GetExecutionOptionsQuery {\n  schema_id?: string;\n  status?: string;\n  mode?: string;\n  page?: string;\n  limit?: string;\n  offset?: string;\n}\n\ninterface ExecutionEventData {\n  execution_id: string;\n  event: string;\n  [key: string]: unknown;\n}\n\ninterface BatchOperateBody {\n  execution_ids: string[];\n  operation: 'cancel' | 'start' | string;\n}\n\ninterface BatchOperateResult {\n  execution_id: string;\n  success: boolean;\n  operation?: string;\n  error?: string;\n}\n\ninterface ExecutionItem {\n  status: string;\n  execution_mode: string;\n  duration_ms?: number;\n}\n\ninterface ExecutionStats {\n  total_executions: number;\n  by_status: Record<string, number>;\n  by_mode: Record<string, number>;\n  average_duration: number;\n  success_rate: number;\n}\n\ninterface CleanupBody {\n  max_age?: string | number;\n}\n\nconst parseExecutionMode = (value: unknown, fallback: ExecutionMode = 'mock'): ExecutionMode => {\n  if (value === 'real') return 'real';\n  return fallback;\n};\n\nconst parseExecutionStatus = (value: unknown): ExecutionStatus | undefined => {\n  if (\n    value === 'pending' ||\n    value === 'running' ||\n    value === 'completed' ||\n    value === 'failed' ||\n    value === 'cancelled'\n  ) {\n    return value;\n  }\n  return undefined;\n};\n\nconst toInt = (value: string | undefined, fallback: number): number => {\n  const parsed = Number.parseInt(value ?? '', 10);\n  return Number.isFinite(parsed) ? parsed : fallback;\n};\n\nclass PipelineExecutionController {\n  async createExecution(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { schema_id, input_data, mode = 'mock' } = req.body as unknown as CreateExecutionBody;\n      const userId = req.user?.id as string;\n      if (!schema_id) {\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '缺少流程模板ID');\n      }\n      const executionMode = parseExecutionMode(mode);\n      const execution = await pipelineExecutionService.createExecution(\n        schema_id,\n        input_data || {},\n        executionMode,\n        userId\n      );\n      res.status(201).json({\n        success: true,\n        data: execution,\n        message: '执行任务创建成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Create execution failed:', error);\n      next(error);\n    }\n  }\n\n  async startExecution(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      // 异步启动\n      pipelineExecutionService.startExecution(id).catch((error: unknown) => {\n        logger.error('[PipelineExecutionController] Async start execution failed:', error);\n      });\n      res.json({\n        success: true,\n        message: '执行已启动',\n        data: { execution_id: id },\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Start execution failed:', error);\n      next(error);\n    }\n  }\n\n  async createAndStartExecution(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { schema_id, input_data, mode = 'mock' } = req.body as unknown as CreateExecutionBody;\n      const userId = req.user?.id as string;\n      if (!schema_id) {\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '缺少流程模板ID');\n      }\n      const executionMode = parseExecutionMode(mode);\n      const execution = await pipelineExecutionService.createExecution(\n        schema_id,\n        input_data || {},\n        executionMode,\n        userId\n      );\n      pipelineExecutionService.startExecution(execution.id).catch((error: unknown) => {\n        logger.error('[PipelineExecutionController] Async start execution failed:', error);\n      });\n      res.status(201).json({\n        success: true,\n        data: execution,\n        message: '执行任务创建并启动成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Create and start execution failed:', error);\n      next(error);\n    }\n  }\n\n  async getExecution(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const execution = pipelineExecutionService.getExecution(id);\n      res.json({ success: true, data: execution, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Get execution failed:', error);\n      next(error);\n    }\n  }\n\n  async getExecutions(req: Request, res: Response, next: NextFunction) {\n    try {\n      const {\n        schema_id,\n        status,\n        mode,\n        page = '1',\n        limit = '20',\n        offset = '0'\n      } = req.query as unknown as GetExecutionOptionsQuery;\n      const options = {\n        schema_id,\n        status: parseExecutionStatus(status),\n        mode: mode ? parseExecutionMode(mode, 'mock') : undefined,\n        limit: toInt(limit, 20),\n        offset: toInt(offset, 0)\n      };\n      const result = pipelineExecutionService.getExecutions(options);\n      res.json({ success: true, data: result, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Get executions failed:', error);\n      next(error);\n    }\n  }\n\n  async cancelExecution(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const { reason } = req.body as { reason?: string };\n      await pipelineExecutionService.cancelExecution(id, reason || '用户取消');\n      res.json({ success: true, message: '执行已取消', requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Cancel execution failed:', error);\n      next(error);\n    }\n  }\n\n  async getExecutionEvents(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      try {\n        pipelineExecutionService.getExecution(id);\n      } catch (error) {\n        throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '执行任务不存在');\n      }\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        Connection: 'keep-alive',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Headers': 'Cache-Control'\n      });\n      res.write(\n        `event: connected\\ndata: ${JSON.stringify({\n          type: 'connected',\n          execution_id: id,\n          timestamp: new Date().toISOString()\n        })}\\n\\n`\n      );\n      const onEvent = (data: ExecutionEventData) => {\n        if (!data || data.execution_id !== id) return;\n        res.write(`event: ${data.event}\\n`);\n        res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n      };\n      pipelineExecutionService.on('execution:event', onEvent);\n      req.on('close', () => {\n        pipelineExecutionService.off('execution:event', onEvent);\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      const appError = error as { statusCode?: number; message?: string };\n      if (appError?.statusCode === 404) {\n        res.write(\n          `event: error\\ndata: ${JSON.stringify({\n            type: 'error',\n            error: appError.message || err.message,\n            timestamp: new Date().toISOString()\n          })}\\n\\n`\n        );\n        res.end();\n      } else {\n        next(error);\n      }\n    }\n  }\n\n  async batchOperateExecutions(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { execution_ids, operation } = req.body as unknown as BatchOperateBody;\n      const userId = req.user?.id as string; // reserved\n      if (!execution_ids || !Array.isArray(execution_ids)) {\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '请提供执行ID列表');\n      }\n      if (!operation) {\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '请指定操作类型');\n      }\n      const results: BatchOperateResult[] = [];\n      let success_count = 0;\n      let failed_count = 0;\n      for (const executionId of execution_ids) {\n        try {\n          switch (operation) {\n            case 'cancel':\n              await pipelineExecutionService.cancelExecution(executionId);\n              results.push({ execution_id: executionId, success: true, operation: 'cancelled' });\n              success_count++;\n              break;\n            case 'start':\n              await pipelineExecutionService.startExecution(executionId);\n              results.push({ execution_id: executionId, success: true, operation: 'started' });\n              success_count++;\n              break;\n            default:\n              results.push({\n                execution_id: executionId,\n                success: false,\n                error: `不支持的操作: ${operation}`\n              });\n              failed_count++;\n          }\n        } catch (e: unknown) {\n          const error = e instanceof Error ? e : new Error(String(e));\n          results.push({ execution_id: executionId, success: false, error: error.message });\n          failed_count++;\n        }\n      }\n      res.json({\n        success: true,\n        data: {\n          results,\n          summary: { total: execution_ids.length, success: success_count, failed: failed_count }\n        },\n        message: `批量操作完成: ${success_count} 成功, ${failed_count} 失败`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Batch operate executions failed:', error);\n      next(error);\n    }\n  }\n\n  async getExecutionStats(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { schema_id } = req.query as unknown as { schema_id?: string };\n      const options = { schema_id };\n      const executions = pipelineExecutionService.getExecutions({\n        ...options,\n        limit: 1000\n      });\n      const stats: ExecutionStats = {\n        total_executions: (executions.executions as ExecutionItem[]).length,\n        by_status: {},\n        by_mode: {},\n        average_duration: 0,\n        success_rate: 0\n      };\n      let total_duration = 0;\n      let completed_count = 0;\n      for (const execution of executions.executions as ExecutionItem[]) {\n        stats.by_status[execution.status] = (stats.by_status[execution.status] || 0) + 1;\n        stats.by_mode[execution.execution_mode] =\n          (stats.by_mode[execution.execution_mode] || 0) + 1;\n        if (execution.duration_ms) {\n          total_duration += execution.duration_ms;\n          completed_count++;\n        }\n      }\n      if (completed_count > 0) {\n        stats.average_duration = Math.round(total_duration / completed_count);\n      }\n      const completed = stats.by_status.completed || 0;\n      const failed = stats.by_status.failed || 0;\n      const total_completed = completed + failed;\n      if (total_completed > 0) {\n        stats.success_rate = Math.round((completed / total_completed) * 100);\n      }\n      res.json({ success: true, data: stats, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Get execution stats failed:', error);\n      next(error);\n    }\n  }\n\n  async cleanupExecutions(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { max_age } = req.body as unknown as CleanupBody;\n      const maxAgeMs = max_age ? parseInt(String(max_age)) * 1000 : 24 * 60 * 60 * 1000;\n      const cleanedCount = pipelineExecutionService.cleanupExpiredExecutions(maxAgeMs);\n      res.json({\n        success: true,\n        data: { cleaned_count: cleanedCount },\n        message: `已清理 ${cleanedCount} 个过期执行记录`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Cleanup executions failed:', error);\n      next(error);\n    }\n  }\n\n  async healthCheck(req: Request, res: Response, next: NextFunction) {\n    try {\n      const health = {\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        service: 'pipeline-execution',\n        active_executions: pipelineExecutionService.getActiveExecutionCount(),\n        memory_usage: process.memoryUsage(),\n        uptime: process.uptime()\n      };\n      res.json({ success: true, data: health, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineExecutionController] Health check failed:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new PipelineExecutionController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/pipelineSchema.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··type·ValidationType⏎` with `·type·ValidationType·`","line":2,"column":32,"nodeType":null,"messageId":"replace","endLine":4,"endColumn":1,"fix":{"range":[95,118],"text":" type ValidationType "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport pipelineSchemaService, {\n  type ValidationType\n} from '../services/pipelineSchema.service.js';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\n\nconst VALIDATION_TYPE_VALUES: ValidationType[] = [\n  'topology',\n  'variables',\n  'completeness',\n  'constraints'\n];\n\nconst parseBooleanQuery = (value?: string): boolean | undefined => {\n  if (typeof value !== 'string') return undefined;\n  const normalized = value.toLowerCase();\n  if (normalized === 'true' || normalized === '1') return true;\n  if (normalized === 'false' || normalized === '0') return false;\n  return undefined;\n};\n\nconst normalizeValidationTypes = (types?: string[]): ValidationType[] | undefined => {\n  if (!types || types.length === 0) return undefined;\n  const normalized = types\n    .map((type) => type?.toLowerCase())\n    .filter((value): value is ValidationType =>\n      VALIDATION_TYPE_VALUES.includes(value as ValidationType)\n    );\n  return normalized.length > 0 ? normalized : undefined;\n};\n\ntype BatchValidationResult = {\n  schema_id: string;\n  success: boolean;\n  result?: unknown;\n  error?: string;\n};\n\nclass PipelineSchemaController {\n  async getSchemas(req: Request, res: Response, next: NextFunction) {\n    try {\n      const {\n        page = '1',\n        limit = '20',\n        category,\n        status,\n        is_valid,\n        search,\n        sortBy = 'created_at',\n        sortOrder = 'desc'\n      } = req.query as Record<string, string>;\n\n      const parsedIsValid = parseBooleanQuery(is_valid);\n      const parsedSortOrder: 'asc' | 'desc' = sortOrder === 'asc' ? 'asc' : 'desc';\n\n      const result = await pipelineSchemaService.getSchemas({\n        page: parseInt(String(page)),\n        limit: parseInt(String(limit)),\n        category,\n        status,\n        is_valid: parsedIsValid,\n        search,\n        sortBy,\n        sortOrder: parsedSortOrder\n      });\n\n      res.json({ success: true, data: result, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Get schemas failed:', error);\n      next(error);\n    }\n  }\n\n  async getSchemaById(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const schema = await pipelineSchemaService.getSchemaById(id);\n      res.json({ success: true, data: schema, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Get schema by ID failed:', error);\n      next(error);\n    }\n  }\n\n  async createSchema(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = req.user?.id as string;\n      const schemaData = { ...req.body, created_by: userId };\n      const schema = await pipelineSchemaService.createSchema(schemaData, userId);\n      res.status(201).json({\n        success: true,\n        data: schema,\n        message: '流程模板创建成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Create schema failed:', error);\n      next(error);\n    }\n  }\n\n  async updateSchema(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const userId = req.user?.id as string;\n      const updateData = { ...req.body, updated_by: userId };\n      const schema = await pipelineSchemaService.updateSchema(id, updateData, userId);\n      res.json({\n        success: true,\n        data: schema,\n        message: '流程模板更新成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Update schema failed:', error);\n      next(error);\n    }\n  }\n\n  async deleteSchema(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const userId = req.user?.id as string;\n      await pipelineSchemaService.deleteSchema(id, userId);\n      res.json({ success: true, message: '流程模板删除成功', requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Delete schema failed:', error);\n      next(error);\n    }\n  }\n\n  async validateSchema(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const { validation_types } = req.body as { validation_types?: string[] };\n      const userId = req.user?.id as string;\n      const normalizedTypes = normalizeValidationTypes(validation_types);\n      const result = await pipelineSchemaService.validateSchema(id, normalizedTypes, userId);\n      res.json({\n        success: true,\n        data: result,\n        message: result?.is_valid ? '校验通过' : '校验发现问题',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Validate schema failed:', error);\n      next(error);\n    }\n  }\n\n  async getValidationHistory(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const { page = '1', limit = '20' } = req.query as Record<string, string>;\n      const result = await pipelineSchemaService.getValidationHistory(id, {\n        page: parseInt(String(page)),\n        limit: parseInt(String(limit))\n      });\n      res.json({ success: true, data: result, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Get validation history failed:', error);\n      next(error);\n    }\n  }\n\n  async getSchemaCategories(req: Request, res: Response, next: NextFunction) {\n    try {\n      const categories = await pipelineSchemaService.getSchemaCategories();\n      res.json({ success: true, data: categories, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Get categories failed:', error);\n      next(error);\n    }\n  }\n\n  async getSchemaStats(req: Request, res: Response, next: NextFunction) {\n    try {\n      const stats = await pipelineSchemaService.getSchemaStats();\n      res.json({ success: true, data: stats, requestId: req.id });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Get stats failed:', error);\n      next(error);\n    }\n  }\n\n  async batchValidateSchemas(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { schema_ids, validation_types } = req.body as {\n        schema_ids: string[];\n        validation_types?: string[];\n      };\n      const userId = req.user?.id as string;\n      if (!schema_ids || !Array.isArray(schema_ids)) {\n        throw AppError.custom(ERROR_CODES.MISSING_PARAMETERS, '请提供要校验的Schema ID列表');\n      }\n      const results: BatchValidationResult[] = [];\n      let success_count = 0;\n      let failed_count = 0;\n      const normalizedTypes = normalizeValidationTypes(validation_types);\n\n      for (const schemaId of schema_ids) {\n        try {\n          const result = await pipelineSchemaService.validateSchema(\n            schemaId,\n            normalizedTypes,\n            userId\n          );\n          results.push({ schema_id: schemaId, success: true, result });\n          if (result?.is_valid) success_count++;\n          else failed_count++;\n        } catch (e: unknown) {\n          const errorMessage = e instanceof Error ? e.message : 'Unknown error';\n          results.push({ schema_id: schemaId, success: false, error: errorMessage });\n          failed_count++;\n        }\n      }\n      res.json({\n        success: true,\n        data: {\n          results,\n          summary: { total: schema_ids.length, success: success_count, failed: failed_count }\n        },\n        message: `批量校验完成: ${success_count} 通过, ${failed_count} 失败`,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Batch validate schemas failed:', error);\n      next(error);\n    }\n  }\n\n  async cloneSchema(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params as { id: string };\n      const { name, description } = req.body as { name?: string; description?: string };\n      const userId = req.user?.id as string;\n      const originalSchema = await pipelineSchemaService.getSchemaById(id);\n      const clonedData = {\n        name: name || `${originalSchema.name} (副本)`,\n        description: description || `${originalSchema.description} (克隆)`,\n        category: originalSchema.category,\n        version: '1.0.0',\n        schema_definition: originalSchema.schema_definition,\n        node_definitions: originalSchema.node_definitions,\n        edge_definitions: originalSchema.edge_definitions,\n        input_schema: originalSchema.input_schema,\n        output_schema: originalSchema.output_schema,\n        variable_mappings: originalSchema.variable_mappings,\n        validation_rules: originalSchema.validation_rules,\n        constraints: originalSchema.constraints,\n        status: 'draft'\n      };\n      const clonedSchema = await pipelineSchemaService.createSchema(clonedData, userId);\n      res.status(201).json({\n        success: true,\n        data: clonedSchema,\n        message: '流程模板克隆成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('[PipelineSchemaController] Clone schema failed:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new PipelineSchemaController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/promptTemplate.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/providers.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/referral-validation.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/referral-validation.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const controller: {\n  validateReferral: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getReferralStats: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n};\nexport default controller;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/referral-validation.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·referralCode,·referrerId,·refereeId,·referralData·=·{}·}·=` with `⏎········referralCode,⏎········referrerId,⏎········refereeId,⏎········referralData·=·{}`","line":47,"column":14,"nodeType":null,"messageId":"replace","endLine":47,"endColumn":73,"fix":{"range":[1099,1158],"text":"\n        referralCode,\n        referrerId,\n        refereeId,\n        referralData = {}"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·` with `}·=`","line":48,"column":7,"nodeType":null,"messageId":"replace","endLine":48,"endColumn":8,"fix":{"range":[1165,1166],"text":"} ="}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.where('referral_code',·referralCode)⏎········.first())·as·ReferralRecord` with `.where('referral_code',·referralCode).first())·as⏎········|·ReferralRecord⏎·······`","line":74,"column":46,"nodeType":null,"messageId":"replace","endLine":76,"endColumn":36,"fix":{"range":[1968,2050],"text":".where('referral_code', referralCode).first()) as\n        | ReferralRecord\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.count('*·as·cnt')⏎········` with `.count('*·as·cnt')`","line":145,"column":43,"nodeType":null,"messageId":"replace","endLine":147,"endColumn":9,"fix":{"range":[4160,4196],"text":".count('* as cnt')"}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport logger from '../utils/logger.js';\nimport referralValidationService from '../services/referral-validation.service.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport { db } from '../config/database.js';\n\ninterface ReferralValidationBody {\n  referralCode?: string;\n  referrerId?: string;\n  refereeId?: string;\n  referralData?: Record<string, unknown>;\n}\n\ninterface ReferralRecord {\n  id: string;\n  referral_code: string;\n  referrer_id: string;\n  referee_id: string;\n  status: string;\n  expires_at?: string;\n}\n\ninterface ReferralStats {\n  date?: string;\n  byStatus?: Array<{ status: string; cnt: number }>;\n}\n\ninterface StatsRow {\n  status: string;\n  cnt: number;\n}\n\ninterface CountResult {\n  cnt: number;\n}\n\nclass ReferralValidationController {\n  /**\n   * 通用推荐验证\n   * 支持两种输入：\n   * - referralCode：直接校验推荐码有效性（基于 referrals 表）\n   * - referrerId + refereeId：调用服务进行关系校验\n   */\n  async validateReferral(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { referralCode, referrerId, refereeId, referralData = {} } =\n        (req.body ?? {}) as ReferralValidationBody;\n\n      // 优先使用 referrerId + refereeId 的关系验证\n      if (referrerId && refereeId) {\n        const dataWithMeta = {\n          ...referralData,\n          ipAddress: req.ip,\n          userAgent: req.get('User-Agent')\n        };\n        const result = await referralValidationService.validateReferralRelationship(\n          referrerId,\n          refereeId,\n          dataWithMeta\n        );\n        res.json({ success: true, data: result });\n        return;\n      }\n\n      // 否则使用 referralCode 的直接校验\n      if (!referralCode || typeof referralCode !== 'string') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'referralCode',\n          message: 'referralCode不能为空'\n        });\n      }\n\n      const referral = (await db('referrals')\n        .where('referral_code', referralCode)\n        .first()) as ReferralRecord | undefined;\n      if (!referral) {\n        res.status(404).json({\n          success: false,\n          error: { code: ERROR_CODES.USER_NOT_FOUND, message: '推荐码不存在' }\n        });\n        return;\n      }\n\n      const now = new Date();\n      const expired = referral.expires_at\n        ? now.getTime() > new Date(referral.expires_at).getTime()\n        : false;\n      const validStatus = ['pending', 'validated'];\n      const isValid = validStatus.includes(referral.status) && !expired;\n\n      res.json({\n        success: true,\n        data: {\n          valid: isValid,\n          status: referral.status,\n          expired,\n          referrerId: referral.referrer_id,\n          refereeId: referral.referee_id,\n          referralId: referral.id\n        }\n      });\n    } catch (error: unknown) {\n      logger.error('[ReferralValidationController] validateReferral failed:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 推荐统计\n   * 若提供 date（YYYY-MM-DD），返回该日统计；否则返回总体按状态聚合\n   */\n  async getReferralStats(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { date } = (req.query ?? {}) as Record<string, string | undefined>;\n\n      if (date) {\n        // 尝试读取 referral_statistics 表（若存在），否则退化到 referrals 聚合\n        let stats: ReferralStats | null = null;\n        try {\n          const record = (await db('referral_statistics').where('date', date).first()) as\n            | ReferralStats\n            | undefined;\n          stats = record ?? null;\n        } catch {\n          // ignore, fall back below\n        }\n        if (!stats) {\n          const rows = (await db('referrals')\n            .whereRaw('DATE(created_at) = ?', [date])\n            .select('status')\n            .count('* as cnt')\n            .groupBy('status')) as StatsRow[];\n          res.json({ success: true, data: { date, byStatus: rows } });\n          return;\n        }\n        res.json({ success: true, data: stats });\n        return;\n      }\n\n      const rows = (await db('referrals')\n        .select('status')\n        .count('* as cnt')\n        .groupBy('status')) as StatsRow[];\n      const total = (await db('referrals')\n        .count('* as cnt')\n        .first()) as CountResult | undefined;\n      res.json({\n        success: true,\n        data: { total: Number(total?.cnt ?? 0), byStatus: rows }\n      });\n    } catch (error: unknown) {\n      logger.error('[ReferralValidationController] getReferralStats failed:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new ReferralValidationController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/scfCallback.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/systemConfig.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········category,⏎········includeSecrets·===·'true'⏎······` with `category,·includeSecrets·===·'true'`","line":95,"column":63,"nodeType":null,"messageId":"replace","endLine":98,"endColumn":7,"fix":{"range":[2668,2727],"text":"category, includeSecrets === 'true'"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport systemConfigService, {\n  type ConfigPrimitive,\n  type ConfigType\n} from '../services/systemConfig.service.js';\nimport logger from '../utils/logger.js';\n\ninterface GetValueQuery {\n  defaultValue?: unknown;\n}\n\ninterface GetCategoryQuery {\n  includeSecrets?: string;\n}\n\ninterface SetValueBody {\n  value: unknown;\n  type?: string;\n  description?: string;\n}\n\ninterface SetBatchBody {\n  configs: Array<{\n    key: string;\n    value: ConfigPrimitive;\n    type?: ConfigType;\n    description?: string;\n  }>;\n}\n\ninterface ImportBody {\n  configs: Array<{\n    key: string;\n    value: ConfigPrimitive;\n    type?: ConfigType;\n    description?: string;\n  }>;\n  overwrite?: boolean;\n}\n\nconst normalizeType = (type?: string): ConfigType => {\n  if (type === 'number' || type === 'boolean' || type === 'json') {\n    return type;\n  }\n  return 'string';\n};\n\nconst normalizeValue = (value: unknown, type: ConfigType): ConfigPrimitive => {\n  if (value === null || value === undefined) return null;\n  if (type === 'number') {\n    const num = Number(value);\n    return Number.isFinite(num) ? num : 0;\n  }\n  if (type === 'boolean') {\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value !== 0;\n    if (typeof value === 'string') {\n      const normalized = value.trim().toLowerCase();\n      return normalized === 'true' || normalized === '1';\n    }\n    return false;\n  }\n  if (type === 'json') {\n    if (typeof value === 'object') return value as Record<string, unknown>;\n    if (typeof value === 'string') {\n      try {\n        return JSON.parse(value) as Record<string, unknown>;\n      } catch {\n        return null;\n      }\n    }\n    return null;\n  }\n  return value as string;\n};\n\nclass SystemConfigController {\n  async getValue(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { key } = req.params as { key: string };\n      const { defaultValue = null } = req.query as unknown as GetValueQuery;\n      const value = await systemConfigService.get(key, defaultValue);\n      res.json({ success: true, data: { key, value, exists: value !== null } });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 获取配置值失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async getCategory(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { category } = req.params as { category: string };\n      const { includeSecrets = false } = req.query as unknown as GetCategoryQuery;\n      const configs = await systemConfigService.getByCategory(\n        category,\n        includeSecrets === 'true'\n      );\n      res.json({ success: true, data: { category, configs } });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 获取分类配置失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async list(req: Request, res: Response, next: NextFunction) {\n    try {\n      const {\n        category = null,\n        page = '1',\n        limit = '50',\n        includeInactive = 'false'\n      } = req.query as Record<string, string>;\n      const result = await systemConfigService.list({\n        category,\n        page: parseInt(page, 10),\n        limit: parseInt(limit, 10),\n        includeInactive: includeInactive === 'true'\n      });\n      res.json({ success: true, data: result });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 获取配置列表失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async getCategories(_req: Request, res: Response, next: NextFunction) {\n    try {\n      const categories = await systemConfigService.listCategories();\n      res.json({ success: true, data: categories });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 获取配置分类失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async setValue(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { key } = req.params as { key: string };\n      const { value, type = 'string', description = '' } = req.body as unknown as SetValueBody;\n      const userId = req.user?.id as string | undefined;\n      if (value === undefined) {\n        res.status(400).json({ success: false, error: { code: 4001, message: '配置值不能为空' } });\n        return;\n      }\n      const configType = normalizeType(type);\n      const normalizedValue = normalizeValue(value, configType);\n      await systemConfigService.set(key, normalizedValue, configType, description, userId);\n      res.json({ success: true, message: '配置更新成功', data: { key, value, type, description } });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 设置配置值失败: ${err.message}`, error);\n      if (String(err.message || '').includes('系统配置不可删除')) {\n        res.status(403).json({ success: false, error: { code: 4003, message: err.message } });\n        return;\n      }\n      next(error);\n    }\n  }\n\n  async setBatch(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { configs } = req.body as unknown as SetBatchBody;\n      const userId = req.user?.id as string | undefined;\n      if (!Array.isArray(configs) || configs.length === 0) {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: '配置数组不能为空' } });\n        return;\n      }\n      for (const config of configs) {\n        if (!config.key || config.value === undefined) {\n          res.status(400).json({\n            success: false,\n            error: { code: 4001, message: '每个配置必须包含key和value字段' }\n          });\n          return;\n        }\n      }\n      const normalizedConfigs = configs.map((config) => {\n        const configType = normalizeType(config.type);\n        return {\n          key: config.key,\n          value: normalizeValue(config.value, configType),\n          type: configType,\n          description: config.description ?? ''\n        };\n      });\n      await systemConfigService.setMultiple(normalizedConfigs, userId ?? null);\n      res.json({\n        success: true,\n        message: `批量更新成功，共更新${configs.length}个配置`,\n        data: { updatedCount: configs.length }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 批量设置配置失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async delete(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { key } = req.params as { key: string };\n      const deleted = await systemConfigService.delete(key);\n      if (!deleted) {\n        res.status(404).json({ success: false, error: { code: 4004, message: '配置不存在' } });\n        return;\n      }\n      res.json({ success: true, message: '配置删除成功', data: { key } });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 删除配置失败: ${err.message}`, error);\n      if (String(err.message || '').includes('系统配置不可删除')) {\n        res.status(403).json({ success: false, error: { code: 4003, message: err.message } });\n        return;\n      }\n      next(error);\n    }\n  }\n\n  async reloadCache(_req: Request, res: Response, next: NextFunction) {\n    try {\n      await systemConfigService.reloadCache();\n      res.json({ success: true, message: '配置缓存已重载' });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 重载缓存失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async export(_req: Request, res: Response, next: NextFunction) {\n    try {\n      const configs = await systemConfigService.exportAll();\n      const exportData = (configs || []).map((c) => {\n        const type = c.config_type ?? 'string';\n        return {\n          key: c.config_key,\n          value: normalizeValue(c.config_value, type),\n          type,\n          description: c.description ?? '',\n          updated_at: c.updated_at ?? null\n        };\n      });\n      res.json({\n        success: true,\n        data: {\n          configs: exportData,\n          exportedAt: new Date().toISOString(),\n          count: exportData.length\n        }\n      });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 导出配置失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async import(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { configs, overwrite = false } = req.body as unknown as ImportBody;\n      const userId = req.user?.id as string | undefined;\n      if (!Array.isArray(configs) || configs.length === 0) {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: '配置数组不能为空' } });\n        return;\n      }\n      const results = { success: 0, skipped: 0, failed: 0, errors: [] as string[] };\n      for (const config of configs) {\n        try {\n          const { key, value, type = 'string', description = '' } = config;\n          if (!key || value === undefined) {\n            results.failed++;\n            results.errors.push(`配置${config.key || '(未知)'}格式不正确`);\n            continue;\n          }\n          const existing = await systemConfigService.get(key);\n          if (existing && !overwrite) {\n            results.skipped++;\n            continue;\n          }\n          const configType = normalizeType(type);\n          await systemConfigService.set(\n            key,\n            normalizeValue(value, configType),\n            configType,\n            description,\n            userId\n          );\n          results.success++;\n        } catch (err: unknown) {\n          const error = err instanceof Error ? err : new Error(String(err));\n          results.failed++;\n          results.errors.push(`配置${config.key}导入失败: ${error.message}`);\n        }\n      }\n      res.json({ success: true, message: '配置导入完成', data: results });\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[SystemConfigController] 导入配置失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n}\n\nexport default new SystemConfigController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/task.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `userId,·featureId,·inputData` with `⏎········userId,⏎········featureId,⏎········inputData⏎······`","line":39,"column":72,"nodeType":null,"messageId":"replace","endLine":39,"endColumn":100,"fix":{"range":[1423,1451],"text":"\n        userId,\n        featureId,\n        inputData\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········`[TaskController]·创建Feature任务失败:·${err.message·||·String(error)}`,⏎········error⏎······` with ``[TaskController]·创建Feature任务失败:·${err.message·||·String(error)}`,·error`","line":46,"column":20,"nodeType":null,"messageId":"replace","endLine":49,"endColumn":7,"fix":{"range":[1711,1807],"text":"`[TaskController] 创建Feature任务失败: ${err.message || String(error)}`, error"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.status(400)` with `⏎··········.status(400)⏎··········`","line":58,"column":12,"nodeType":null,"messageId":"replace","endLine":58,"endColumn":24,"fix":{"range":[2076,2088],"text":"\n          .status(400)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········.createModelTask(task.taskId,·inputImageUrl,·params)⏎··········` with `.createModelTask(task.taskId,·inputImageUrl,·params)`","line":92,"column":23,"nodeType":null,"messageId":"replace","endLine":94,"endColumn":11,"fix":{"range":[3320,3394],"text":".createModelTask(task.taskId, inputImageUrl, params)"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `············` with `··········`","line":95,"column":1,"nodeType":null,"messageId":"replace","endLine":95,"endColumn":13,"fix":{"range":[3419,3431],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":96,"column":13,"nodeType":null,"messageId":"delete","endLine":96,"endColumn":15,"fix":{"range":[3505,3507],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":97,"column":11,"nodeType":null,"messageId":"delete","endLine":97,"endColumn":13,"fix":{"range":[3537,3539],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":98,"column":1,"nodeType":null,"messageId":"delete","endLine":98,"endColumn":3,"fix":{"range":[3543,3545],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········`[TaskController]·管理员获取任务列表失败:·${err.message}`,⏎········error⏎······` with ``[TaskController]·管理员获取任务列表失败:·${err.message}`,·error`","line":184,"column":20,"nodeType":null,"messageId":"replace","endLine":187,"endColumn":7,"fix":{"range":[6360,6437],"text":"`[TaskController] 管理员获取任务列表失败: ${err.message}`, error"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·q:·searchTerm,·page·=·'1',·limit·=·'20',·status,·type` with `⏎········q:·searchTerm,⏎········page·=·'1',⏎········limit·=·'20',⏎········status,⏎········type⏎·····`","line":199,"column":14,"nodeType":null,"messageId":"replace","endLine":199,"endColumn":68,"fix":{"range":[6764,6818],"text":"\n        q: searchTerm,\n        page = '1',\n        limit = '20',\n        status,\n        type\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········`[TaskController]·获取数据库性能分析失败:·${err.message}`,⏎········error⏎······` with ``[TaskController]·获取数据库性能分析失败:·${err.message}`,·error`","line":251,"column":20,"nodeType":null,"messageId":"replace","endLine":254,"endColumn":7,"fix":{"range":[8678,8755],"text":"`[TaskController] 获取数据库性能分析失败: ${err.message}`, error"}}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":11,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport taskService from '../services/task.service.js';\nimport imageProcessService from '../services/imageProcess.service.js';\nimport aiModelService from '../services/aiModel.service.js';\nimport paginationService, { type TaskFilters } from '../services/pagination.service.js';\nimport logger from '../utils/logger.js';\nimport type {\n  CreateFeatureTaskRequest,\n  CreateTaskRequest,\n  UpdateTaskStatusRequest,\n  AdminTaskQuery,\n  TaskSearchQuery,\n  DbPerformanceQuery,\n  TaskError,\n  TaskCreateResult\n} from '../types/task.types.js';\n\nclass TaskController {\n  async createByFeature(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { featureId, inputData } = (req.body ?? {}) as CreateFeatureTaskRequest;\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 4003, message: '未授权操作' } });\n        return;\n      }\n      if (!featureId) {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: '缺少必要参数:featureId' } });\n        return;\n      }\n      if (!inputData || typeof inputData !== 'object') {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: 'inputData必须是一个对象' } });\n        return;\n      }\n      const task: TaskCreateResult = await taskService.createByFeature(userId, featureId, inputData);\n      logger.info(\n        `[TaskController] Feature任务创建成功 taskId=${task.taskId} userId=${userId} featureId=${featureId}`\n      );\n      res.json({ success: true, data: task });\n    } catch (error) {\n      const err = error as TaskError;\n      logger.error(\n        `[TaskController] 创建Feature任务失败: ${err.message || String(error)}`,\n        error\n      );\n      if (err?.errorCode === 4029) {\n        res.status(429).json({\n          success: false,\n          error: { code: err.errorCode, message: err.message, rateLimitInfo: err.rateLimitInfo }\n        });\n        return;\n      }\n      if (err?.errorCode) {\n        res.status(400).json({ success: false, error: { code: err.errorCode, message: err.message } });\n        return;\n      }\n      next(error);\n    }\n  }\n\n  async create(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { type, inputImageUrl, params } = (req.body ?? {}) as CreateTaskRequest;\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 4003, message: '未授权操作' } });\n        return;\n      }\n      if (!type || !inputImageUrl) {\n        res.status(400).json({\n          success: false,\n          error: { code: 4001, message: '缺少必要参数:type和inputImageUrl' }\n        });\n        return;\n      }\n      const task: TaskCreateResult = await taskService.create(userId, type, inputImageUrl, params);\n      logger.info(`[TaskController] 任务创建成功 taskId=${task.taskId} userId=${userId}`);\n      if (type === 'basic_clean') {\n        imageProcessService\n          .processBasicClean(task.taskId, inputImageUrl, params)\n          .catch((err: Error) => {\n            logger.error(`[TaskController] 异步处理失败: ${err.message}`, {\n              taskId: task.taskId\n            });\n          });\n      }\n      if (type === 'model_pose12') {\n        aiModelService\n          .createModelTask(task.taskId, inputImageUrl, params)\n          .catch((err: Error) => {\n            logger.error(`[TaskController] AI模特任务创建失败: ${err.message}`, {\n              taskId: task.taskId\n            });\n          });\n      }\n      res.json({ success: true, data: task });\n    } catch (error) {\n      const err = error as Error;\n      logger.error(`[TaskController] 创建任务失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async get(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { taskId } = req.params as { taskId: string };\n      const task = await taskService.get(taskId);\n      res.json({ success: true, data: task });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async list(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userId = req.user?.id;\n      if (!userId) {\n        res.status(401).json({ success: false, error: { code: 4003, message: '未授权操作' } });\n        return;\n      }\n      const result = await taskService.list(userId, req.query as Record<string, string>);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateStatus(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { taskId } = req.params as { taskId: string };\n      const { status, resultUrls, errorMessage } = (req.body ?? {}) as UpdateTaskStatusRequest;\n      if (!status) {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: '缺少必要参数:status' } });\n        return;\n      }\n      await taskService.updateStatus(taskId, status, { resultUrls, errorMessage });\n      res.json({ success: true, message: '任务状态更新成功' });\n    } catch (error) {\n      const err = error as Error;\n      logger.error(`[TaskController] 更新任务状态失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async adminList(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userRole = req.user?.role;\n      if (userRole !== 'admin') {\n        res.status(403).json({ success: false, error: { code: 4003, message: '需要管理员权限' } });\n        return;\n      }\n      const {\n        page = '1',\n        limit = '20',\n        status,\n        type,\n        userId,\n        startDate,\n        endDate\n      } = req.query as AdminTaskQuery;\n      const filters: TaskFilters = {};\n      if (status) filters.status = status;\n      if (type) filters.type = type;\n      if (userId) filters.userId = userId;\n      if (startDate || endDate) {\n        filters.createdRange = {\n          start: startDate ? String(startDate) : undefined,\n          end: endDate ? String(endDate) : undefined\n        };\n      }\n      const result = await paginationService.getTaskList(filters, {\n        page: Number(page),\n        limit: Math.min(Number(limit), 100)\n      });\n      res.json({ success: true, data: result.data, pagination: result.pageInfo });\n    } catch (error) {\n      const err = error as Error;\n      logger.error(\n        `[TaskController] 管理员获取任务列表失败: ${err.message}`,\n        error\n      );\n      next(error);\n    }\n  }\n\n  async search(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userRole = req.user?.role;\n      if (userRole !== 'admin') {\n        res.status(403).json({ success: false, error: { code: 4003, message: '需要管理员权限' } });\n        return;\n      }\n      const { q: searchTerm, page = '1', limit = '20', status, type } = req.query as TaskSearchQuery;\n      if (!searchTerm || String(searchTerm).trim().length === 0) {\n        res\n          .status(400)\n          .json({ success: false, error: { code: 4001, message: '搜索关键词不能为空' } });\n        return;\n      }\n      const filters: TaskFilters = {};\n      if (status) filters.status = status;\n      if (type) filters.type = type;\n      const result = await paginationService.searchTasks(String(searchTerm).trim(), {\n        page: Number(page),\n        limit: Math.min(Number(limit), 100),\n        where: filters\n      });\n      res.json({\n        success: true,\n        data: result.data,\n        pagination: result.pageInfo,\n        searchTerm: String(searchTerm).trim()\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error(`[TaskController] 任务搜索失败: ${err.message}`, error);\n      next(error);\n    }\n  }\n\n  async getDbPerformance(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const userRole = req.user?.role;\n      if (userRole !== 'admin') {\n        res.status(403).json({ success: false, error: { code: 4003, message: '需要管理员权限' } });\n        return;\n      }\n      const { table, status } = req.query as DbPerformanceQuery;\n      if (!table) {\n        res.status(400).json({ success: false, error: { code: 4001, message: '缺少表名参数' } });\n        return;\n      }\n      const where: Record<string, string> = {};\n      if (status) where.status = status;\n      const analysis = await paginationService.analyzeQuery(table, where, [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ]);\n      res.json({\n        success: true,\n        data: { table, query: analysis.sql, bindings: analysis.bindings, explain: analysis.explain }\n      });\n    } catch (error) {\n      const err = error as Error;\n      logger.error(\n        `[TaskController] 获取数据库性能分析失败: ${err.message}`,\n        error\n      );\n      next(error);\n    }\n  }\n}\n\nexport default new TaskController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/uiSchema.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/user-profile.controller.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/controllers/user-profile.controller.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const userProfileController: {\n  getUserFullProfile: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserBasicInfo: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateUserBasicInfo: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserEducation: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  addEducation: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateEducation: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  deleteEducation: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserWorkExperience: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  addWorkExperience: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateWorkExperience: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  deleteWorkExperience: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserSkills: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  addSkill: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  updateSkill: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  deleteSkill: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserInterests: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserSocialLinks: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getUserProfileCompleteness: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  recalculateProfileCompleteness: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  getProfileSuggestions: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  batchUpdateProfile: (\n    req: import('express').Request,\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  uploadAvatar: (\n    req: import('express').Request & { file?: Express.Multer.File },\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n  uploadBanner: (\n    req: import('express').Request & { file?: Express.Multer.File },\n    res: import('express').Response,\n    next: import('express').NextFunction\n  ) => any;\n};\n\nexport default userProfileController;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/user-profile.controller.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·id:·string` with `⏎········id:·string;⏎·····`","line":275,"column":97,"nodeType":null,"messageId":"replace","endLine":275,"endColumn":108,"fix":{"range":[7381,7392],"text":"\n        id: string;\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·id:·string` with `⏎········id:·string;⏎·····`","line":328,"column":97,"nodeType":null,"messageId":"replace","endLine":328,"endColumn":108,"fix":{"range":[8845,8856],"text":"\n        id: string;\n     "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import type { Request, Response, NextFunction } from 'express';\nimport logger from '../utils/logger.js';\nimport { db } from '../config/database.js';\nimport userProfileService from '../services/user-profile.service.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\n\n/**\n * 用户资料控制器\n *\n * 处理用户资料相关的HTTP请求：\n * - 用户基础信息管理\n * - 教育和工作经历管理\n * - 技能和兴趣标签管理\n * - 社交媒体链接管理\n * - 资料完整度计算\n * - 隐私设置控制\n */\nclass UserProfileController {\n  private getCurrentUserId(req: Request): string {\n    const user = req.user as { id?: string } | undefined;\n    const userId = user?.id;\n    if (!userId) {\n      throw AppError.create(ERROR_CODES.UNAUTHORIZED, { message: '用户未登录' });\n    }\n    return userId as string;\n  }\n\n  /**\n   * 获取用户完整资料\n   */\n  async getUserFullProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params as { userId?: string };\n      const currentUserId = this.getCurrentUserId(req);\n      const targetUserId = userId || currentUserId;\n\n      const profile = await userProfileService.getUserFullProfile(targetUserId, currentUserId);\n\n      res.json({\n        success: true,\n        data: profile\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user full profile:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户基础信息\n   */\n  async getUserBasicInfo(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params as { userId?: string };\n      const currentUserId = this.getCurrentUserId(req);\n      const targetUserId = userId || currentUserId;\n\n      const userInfo = await userProfileService.getUserBasicInfo(targetUserId, currentUserId);\n\n      res.json({\n        success: true,\n        data: userInfo\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user basic info:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 更新用户基础信息\n   */\n  async updateUserBasicInfo(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const updateData = req.body;\n\n      const updatedUser = await userProfileService.updateUserBasicInfo(userId, updateData);\n\n      logger.info(`[UserProfileController] User ${userId} updated basic profile`);\n\n      res.json({\n        success: true,\n        message: '基础信息更新成功',\n        data: updatedUser\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to update user basic info:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户教育经历\n   */\n  async getUserEducation(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const education = await userProfileService.getUserEducation(\n        targetUserId,\n        this.getCurrentUserId(req)\n      );\n\n      res.json({\n        success: true,\n        data: education\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user education:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 添加教育经历\n   */\n  async addEducation(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const educationData = req.body;\n\n      // 参数验证\n      if (!educationData.school_name || !educationData.school_name.trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'school_name',\n          message: '学校名称不能为空'\n        });\n      }\n\n      const education = await userProfileService.addEducation(userId, educationData);\n\n      logger.info(`[UserProfileController] User ${userId} added education`);\n\n      res.json({\n        success: true,\n        message: '教育经历添加成功',\n        data: education\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to add education:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 更新教育经历\n   */\n  async updateEducation(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { educationId } = req.params;\n      const updateData = req.body;\n\n      const updatedEducation = await userProfileService.updateEducation(\n        userId,\n        educationId,\n        updateData\n      );\n\n      logger.info(`[UserProfileController] User ${userId} updated education ${educationId}`);\n\n      res.json({\n        success: true,\n        message: '教育经历更新成功',\n        data: updatedEducation\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to update education:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 删除教育经历\n   */\n  async deleteEducation(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { educationId } = req.params;\n\n      const success = await userProfileService.deleteEducation(userId, educationId);\n\n      if (!success) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '教育经历不存在'\n        });\n      }\n\n      logger.info(`[UserProfileController] User ${userId} deleted education ${educationId}`);\n\n      res.json({\n        success: true,\n        message: '教育经历删除成功'\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to delete education:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户工作经历\n   */\n  async getUserWorkExperience(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const workExperience = await userProfileService.getUserWorkExperience(\n        targetUserId,\n        this.getCurrentUserId(req)\n      );\n\n      res.json({\n        success: true,\n        data: workExperience\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user work experience:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 添加工作经历\n   */\n  async addWorkExperience(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const workData = req.body;\n\n      // 参数验证\n      if (!workData.company_name || !workData.company_name.trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'company_name',\n          message: '公司名称不能为空'\n        });\n      }\n\n      if (!workData.job_title || !workData.job_title.trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'job_title',\n          message: '职位名称不能为空'\n        });\n      }\n\n      const workExperience = await userProfileService.addWorkExperience(userId, workData);\n\n      logger.info(`[UserProfileController] User ${userId} added work experience`);\n\n      res.json({\n        success: true,\n        message: '工作经历添加成功',\n        data: workExperience\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to add work experience:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 更新工作经历\n   */\n  async updateWorkExperience(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { workId } = req.params;\n      const updateData = req.body;\n\n      // 需要先检查工作经历是否存在且属于当前用户\n      const workExperience = (await userProfileService.getUserWorkExperience(userId)) as Array<{ id: string }>;\n      const existingWork = workExperience.find((work: { id: string }) => work.id === workId);\n\n      if (!existingWork) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '工作经历不存在'\n        });\n      }\n\n      // 更新工作经历\n      const [updatedWork] = await db('user_work_experience')\n        .where({\n          id: workId,\n          user_id: userId\n        })\n        .update({\n          ...updateData,\n          updated_at: new Date()\n        })\n        .returning('*');\n\n      if (!updatedWork) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '工作经历不存在'\n        });\n      }\n\n      // 清除缓存\n      await userProfileService.clearUserProfileCache(userId);\n      await userProfileService.calculateProfileCompleteness(userId);\n\n      logger.info(`[UserProfileController] User ${userId} updated work experience ${workId}`);\n\n      res.json({\n        success: true,\n        message: '工作经历更新成功',\n        data: updatedWork\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to update work experience:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 删除工作经历\n   */\n  async deleteWorkExperience(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { workId } = req.params;\n\n      // 需要先检查工作经历是否存在且属于当前用户\n      const workExperience = (await userProfileService.getUserWorkExperience(userId)) as Array<{ id: string }>;\n      const existingWork = workExperience.find((work: { id: string }) => work.id === workId);\n\n      if (!existingWork) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '工作经历不存在'\n        });\n      }\n\n      // 删除工作经历\n      const deleted = await db('user_work_experience')\n        .where({\n          id: workId,\n          user_id: userId\n        })\n        .del();\n\n      if (deleted === 0) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '工作经历不存在'\n        });\n      }\n\n      // 清除缓存\n      await userProfileService.clearUserProfileCache(userId);\n      await userProfileService.calculateProfileCompleteness(userId);\n\n      logger.info(`[UserProfileController] User ${userId} deleted work experience ${workId}`);\n\n      res.json({\n        success: true,\n        message: '工作经历删除成功'\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to delete work experience:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户技能\n   */\n  async getUserSkills(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const skills = (await userProfileService.getUserSkills(\n        targetUserId,\n        this.getCurrentUserId(req)\n      )) as Array<Record<string, unknown>>;\n\n      res.json({\n        success: true,\n        data: skills\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user skills:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 添加技能\n   */\n  async addSkill(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const skillData = req.body;\n\n      // 参数验证\n      if (!skillData.skill_name || !skillData.skill_name.trim()) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          field: 'skill_name',\n          message: '技能名称不能为空'\n        });\n      }\n\n      const skill = await userProfileService.addSkill(userId, skillData);\n\n      logger.info(`[UserProfileController] User ${userId} added skill`);\n\n      res.json({\n        success: true,\n        message: '技能添加成功',\n        data: skill\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to add skill:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 更新技能\n   */\n  async updateSkill(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { skillId } = req.params;\n      const updateData = req.body;\n\n      // 需要先检查技能是否存在且属于当前用户\n      const skills = (await userProfileService.getUserSkills(userId)) as Array<{ id: string }>;\n      const existingSkill = skills.find((skill: { id: string }) => skill.id === skillId);\n\n      if (!existingSkill) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '技能不存在'\n        });\n      }\n\n      // 更新技能（需要在service中实现）\n      const [updatedSkill] = await db('user_skills')\n        .where({\n          id: skillId,\n          user_id: userId\n        })\n        .update({\n          ...updateData,\n          updated_at: new Date()\n        })\n        .returning('*');\n\n      if (!updatedSkill) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '技能不存在'\n        });\n      }\n\n      // 清除缓存\n      await userProfileService.clearUserProfileCache(userId);\n      await userProfileService.calculateProfileCompleteness(userId);\n\n      logger.info(`[UserProfileController] User ${userId} updated skill ${skillId}`);\n\n      res.json({\n        success: true,\n        message: '技能更新成功',\n        data: updatedSkill\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to update skill:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 删除技能\n   */\n  async deleteSkill(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { skillId } = req.params;\n\n      // 删除技能\n      const deleted = await db('user_skills')\n        .where({\n          id: skillId,\n          user_id: userId\n        })\n        .del();\n\n      if (deleted === 0) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          message: '技能不存在'\n        });\n      }\n\n      // 清除缓存\n      await userProfileService.clearUserProfileCache(userId);\n      await userProfileService.calculateProfileCompleteness(userId);\n\n      logger.info(`[UserProfileController] User ${userId} deleted skill ${skillId}`);\n\n      res.json({\n        success: true,\n        message: '技能删除成功'\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to delete skill:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户兴趣标签\n   */\n  async getUserInterests(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const interests = await userProfileService.getUserInterests(\n        targetUserId,\n        this.getCurrentUserId(req)\n      );\n\n      res.json({\n        success: true,\n        data: interests\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user interests:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户社交媒体链接\n   */\n  async getUserSocialLinks(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const socialLinks = await userProfileService.getUserSocialLinks(\n        targetUserId,\n        this.getCurrentUserId(req)\n      );\n\n      res.json({\n        success: true,\n        data: socialLinks\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user social links:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取用户资料完整度\n   */\n  async getUserProfileCompleteness(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { userId } = req.params;\n      const targetUserId = userId || this.getCurrentUserId(req);\n\n      const completeness = await userProfileService.getUserProfileCompleteness(targetUserId);\n\n      res.json({\n        success: true,\n        data: completeness\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get user profile completeness:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 重新计算用户资料完整度\n   */\n  async recalculateProfileCompleteness(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n\n      const completeness = await userProfileService.calculateProfileCompleteness(userId);\n\n      logger.info(`[UserProfileController] User ${userId} recalculated profile completeness`);\n\n      res.json({\n        success: true,\n        message: '资料完整度重新计算成功',\n        data: completeness\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to recalculate profile completeness:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 获取资料完善建议\n   */\n  async getProfileSuggestions(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n\n      const completeness = await userProfileService.getUserProfileCompleteness(userId);\n      const suggestions = completeness.suggestions || [];\n\n      res.json({\n        success: true,\n        data: {\n          suggestions,\n          completeness_percentage: completeness.completenessPercentage,\n          missing_fields: completeness.missingFields || []\n        }\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to get profile suggestions:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 批量更新用户资料\n   */\n  async batchUpdateProfile(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n      const { basicInfo, education, workExperience, skills } = req.body as {\n        basicInfo?: Record<string, unknown>;\n        education?: Array<Record<string, unknown>>;\n        workExperience?: Array<Record<string, unknown>>;\n        skills?: Array<Record<string, unknown>>;\n      };\n\n      const trx = await db.transaction();\n\n      try {\n        const results: Record<string, unknown> = {};\n\n        // 更新基础信息\n        if (basicInfo) {\n          results.basicInfo = await userProfileService.updateUserBasicInfo(userId, basicInfo);\n        }\n\n        // 批量添加教育经历\n        if (education && Array.isArray(education)) {\n          results.education = [];\n          for (const edu of education) {\n            const addedEdu = await userProfileService.addEducation(userId, edu);\n            (results.education as Array<unknown>).push(addedEdu);\n          }\n        }\n\n        // 批量添加工作经历\n        if (workExperience && Array.isArray(workExperience)) {\n          results.workExperience = [];\n          for (const work of workExperience) {\n            const addedWork = await userProfileService.addWorkExperience(userId, work);\n            (results.workExperience as Array<unknown>).push(addedWork);\n          }\n        }\n\n        // 批量添加技能\n        if (skills && Array.isArray(skills)) {\n          results.skills = [];\n          for (const skill of skills) {\n            try {\n              const addedSkill = await userProfileService.addSkill(userId, skill);\n              (results.skills as Array<unknown>).push(addedSkill);\n            } catch (error: unknown) {\n              // 忽略重复技能错误\n              const err = error as { code?: string };\n              if (err?.code !== 'DUPLICATE_RESOURCE') {\n                throw err;\n              }\n            }\n          }\n        }\n\n        await trx.commit();\n\n        // 重新计算完整度\n        const completeness = await userProfileService.calculateProfileCompleteness(userId);\n\n        logger.info(`[UserProfileController] User ${userId} batch updated profile`);\n\n        res.json({\n          success: true,\n          message: '资料批量更新成功',\n          data: {\n            ...results,\n            completeness\n          }\n        });\n      } catch (error) {\n        await trx.rollback();\n        throw error;\n      }\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to batch update profile:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 上传头像\n   */\n  async uploadAvatar(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n\n      const file = (req as unknown as { file?: unknown }).file;\n      if (!file) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          message: '请选择要上传的头像文件'\n        });\n      }\n\n      // 这里应该调用文件上传服务，暂时返回模拟数据\n      const avatarUrl = `/uploads/avatars/${userId}_${Date.now()}.jpg`;\n\n      const updatedUser = await userProfileService.updateUserBasicInfo(userId, {\n        avatar_url: avatarUrl\n      });\n\n      logger.info(`[UserProfileController] User ${userId} uploaded avatar`);\n\n      res.json({\n        success: true,\n        message: '头像上传成功',\n        data: {\n          avatar_url: updatedUser.avatar_url\n        }\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to upload avatar:', error);\n      next(error);\n    }\n  }\n\n  /**\n   * 上传横幅图片\n   */\n  async uploadBanner(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userId = this.getCurrentUserId(req);\n\n      const file = (req as unknown as { file?: unknown }).file;\n      if (!file) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          message: '请选择要上传的横幅图片文件'\n        });\n      }\n\n      // 这里应该调用文件上传服务，暂时返回模拟数据\n      const bannerUrl = `/uploads/banners/${userId}_${Date.now()}.jpg`;\n\n      const updatedUser = await userProfileService.updateUserBasicInfo(userId, {\n        banner_url: bannerUrl\n      });\n\n      logger.info(`[UserProfileController] User ${userId} uploaded banner`);\n\n      res.json({\n        success: true,\n        message: '横幅图片上传成功',\n        data: {\n          banner_url: updatedUser.banner_url\n        }\n      });\n    } catch (error) {\n      logger.error('[UserProfileController] Failed to upload banner:', error);\n      next(error);\n    }\n  }\n}\n\nexport default new UserProfileController();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/users.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/controllers/wechat-login.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000001_create_config_snapshots_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000002_create_cms_features_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000003_create_provider_endpoints_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000004_create_provider_secrets_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000005_create_pipeline_schemas_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000006_create_pipeline_validations_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000007_create_pipeline_executions_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000008_create_pipeline_execution_steps_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000009_create_mcp_endpoints_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000010_create_kb_tables.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241203000010_create_mcp_tools_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241204000001_create_kms_secrets_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241204000002_add_role_to_users_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241204000003_create_prompt_templates_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20241204000004_create_prompt_template_versions_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000001_create_quota_transactions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000007_create_feature_catalog.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000008_create_invite_codes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000009_enhance_user_profiles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000010_create_referral_system.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250102000011_create_kms_system.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250103000002_add_core_indexes_simple.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250103000003_create_notifications_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250103000004_create_file_lifecycle_records_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250103000005_create_task_files_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250103000006_create_rbac_tables.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250104000001_create_payment_tables.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20250215000012_enable_email_codes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000001_create_users_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000002_create_orders_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000003_create_tasks_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000004_create_verification_codes_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000005_extend_tasks_for_video.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251028000006_create_system_configs_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000001_create_feature_definitions_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000002_create_form_schemas_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000003_create_pipeline_schemas_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000004_extend_tasks_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000005_create_task_steps_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000006_create_provider_endpoints_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000007_create_provider_health_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029000008_create_assets_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110001_create_distributors_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110002_create_referral_relationships_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110003_create_commissions_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110004_create_withdrawals_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110005_create_distribution_settings_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029110006_extend_users_for_distribution.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251029133207_add_ai_model_dynamic_configs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251030000001_add_final_amount_to_orders.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251030000002_add_orders_indexes.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251030000004_create_audit_logs_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000001_create_config_snapshots_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000002_create_announcements_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000003_create_banners_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000004_create_membership_tables.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000005_create_content_texts_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251031000006_create_audit_logs_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251101000001_add_auth_fields_to_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251101000002_add_branch_support_to_task_steps.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251101000002_extend_form_schemas_for_versioning.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251101000007_create_prompt_versions_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102000001_create_refresh_tokens.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102000002_add_user_profile_fields.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102000003_add_referrer_validation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102010000_extend_tasks_for_video.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102020000_add_wechat_fields_to_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251102030000_add_password_to_users.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251111090001_alter_users_for_email_login.js","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'users',·'uq_users_email'` with `⏎····'users',⏎····'uq_users_email'⏎··`","line":9,"column":78,"nodeType":null,"messageId":"replace","endLine":9,"endColumn":103,"fix":{"range":[253,278],"text":"\n    'users',\n    'uq_users_email'\n  "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 调整 users 表以支持邮箱登录\n */\nexports.up = async function (knex) {\n  await knex.schema.alterTable('users', (table) => {\n    table.string('phone', 11).nullable().alter();\n  });\n\n  const [indexes] = await knex.raw('SHOW INDEX FROM ?? WHERE Key_name = ?', ['users', 'uq_users_email']);\n  if (!indexes || indexes.length === 0) {\n    await knex.schema.alterTable('users', (table) => {\n      table.unique(['email'], 'uq_users_email');\n    });\n  }\n};\n\nexports.down = async function (knex) {\n  await knex.schema.alterTable('users', (table) => {\n    table.dropUnique(['email'], 'uq_users_email');\n    table.string('phone', 11).notNullable().alter();\n  });\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/migrations/20251111090002_extend_verification_codes_table.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/seeds/001_system_configs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/seeds/002_provider_endpoints.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/db/seeds/003_features_init.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/engine/nodes/kb-retrieve.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········?·resolvedQueryRaw⏎·········` with `·?·resolvedQueryRaw`","line":60,"column":45,"nodeType":null,"messageId":"replace","endLine":62,"endColumn":10,"fix":{"range":[1252,1291],"text":" ? resolvedQueryRaw"}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":135,"column":20,"nodeType":null,"messageId":"insert","endLine":135,"endColumn":20,"fix":{"range":[3200,3200],"text":"\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":136,"column":7,"nodeType":null,"messageId":"insert","endLine":136,"endColumn":7,"fix":{"range":[3267,3267],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":137,"column":1,"nodeType":null,"messageId":"insert","endLine":137,"endColumn":1,"fix":{"range":[3316,3316],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎········`","line":182,"column":26,"nodeType":null,"messageId":"insert","endLine":182,"endColumn":26,"fix":{"range":[4369,4369],"text":"\n        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":183,"column":9,"nodeType":null,"messageId":"insert","endLine":183,"endColumn":9,"fix":{"range":[4465,4465],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":184,"column":1,"nodeType":null,"messageId":"insert","endLine":184,"endColumn":1,"fix":{"range":[4475,4475],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":185,"column":1,"nodeType":null,"messageId":"replace","endLine":185,"endColumn":9,"fix":{"range":[4497,4505],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":186,"column":9,"nodeType":null,"messageId":"insert","endLine":186,"endColumn":9,"fix":{"range":[4555,4555],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":187,"column":9,"nodeType":null,"messageId":"insert","endLine":187,"endColumn":9,"fix":{"range":[4579,4579],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······})` with `········})⏎······`","line":188,"column":1,"nodeType":null,"messageId":"replace","endLine":188,"endColumn":9,"fix":{"range":[4593,4601],"text":"        })\n      "}}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":11,"fixableWarningCount":0,"source":"/**\n * KB检索节点执行器\n * 艹，这个憨批节点负责从知识库检索上下文并拼装到Prompt！\n */\n\nimport axios from 'axios';\nimport db from '../../db/index.js';\nimport logger from '../../utils/logger.js';\nimport {\n  NodeExecutor,\n  NodeExecutionContext,\n  NodeExecutionResult,\n  NodeConfig,\n  NodeError,\n  NodeErrorType\n} from '../types.js';\n\n/**\n * KB检索配置\n */\ninterface KBRetrieveConfig {\n  query: string; // 检索查询（支持变量模板）\n  kbId?: string; // 知识库ID（可选）\n  topK?: number; // 返回结果数量（默认5）\n  filters?: Record<string, unknown>; // 过滤条件\n  outputKey?: string; // 输出键名（默认'contexts'）\n}\n\n/**\n * KB检索结果\n */\ninterface RetrieveResult {\n  id: string;\n  text: string;\n  metadata: unknown;\n  title: string;\n  kbId: string;\n}\n\n/**\n * KB检索节点执行器\n */\nclass KBRetrieveNodeExecutor implements NodeExecutor {\n  /**\n   * 执行KB检索节点\n   */\n  async execute(context: NodeExecutionContext): Promise<NodeExecutionResult> {\n    const startTime = Date.now();\n\n    try {\n      const config = this.parseConfig(context.node);\n\n      logger.info(\n        `[KBRetrieve] 开始检索: flowId=${context.flowContext.flowId} ` + `nodeId=${context.node.id}`\n      );\n\n      // 解析查询变量\n      const resolvedQueryRaw = this.resolveValue(config.query, context.flowContext.state);\n      const resolvedQuery =\n        typeof resolvedQueryRaw === 'string'\n          ? resolvedQueryRaw\n          : String(resolvedQueryRaw ?? '');\n\n      // 执行检索\n      const results = await this.retrieve(\n        resolvedQuery,\n        config.kbId,\n        config.topK || 5,\n        config.filters || {}\n      );\n\n      // 合并结果到流程状态\n      const outputKey = config.outputKey || 'contexts';\n      context.flowContext.state[outputKey] = results.map((r) => r.text);\n      context.flowContext.state[`${outputKey}_metadata`] = results;\n\n      const duration = Date.now() - startTime;\n\n      logger.info(\n        `[KBRetrieve] 检索成功: nodeId=${context.node.id} ` +\n          `results=${results.length} duration=${duration}ms`\n      );\n\n      return {\n        success: true,\n        outputs: {\n          [outputKey]: results.map((r) => r.text),\n          [`${outputKey}_metadata`]: results\n        },\n        duration\n      };\n    } catch (error: unknown) {\n      const duration = Date.now() - startTime;\n\n      logger.error(`[KBRetrieve] 检索失败: nodeId=${context.node.id}`, error);\n\n      return {\n        success: false,\n        error: this.handleError(error),\n        duration\n      };\n    }\n  }\n\n  /**\n   * 验证节点配置\n   */\n  validate(config: NodeConfig): boolean {\n    try {\n      this.parseConfig(config);\n      return true;\n    } catch (error) {\n      logger.error('[KBRetrieve] 配置验证失败:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 解析节点配置\n   * @private\n   */\n  private parseConfig(node: NodeConfig): KBRetrieveConfig {\n    const rawConfig = node.config as Record<string, unknown> | undefined;\n    if (!rawConfig || typeof rawConfig !== 'object') {\n      throw new Error('KB检索配置无效');\n    }\n\n    const query = rawConfig.query;\n    if (typeof query !== 'string' || query.trim().length === 0) {\n      throw new Error('KB检索 query 不能为空');\n    }\n\n    const kbId = typeof rawConfig.kbId === 'string' ? rawConfig.kbId : undefined;\n    const topK = typeof rawConfig.topK === 'number' ? rawConfig.topK : undefined;\n    const filters = (rawConfig.filters && typeof rawConfig.filters === 'object'\n      ? (rawConfig.filters as Record<string, unknown>)\n      : undefined) ?? {};\n    const outputKey = typeof rawConfig.outputKey === 'string' ? rawConfig.outputKey : undefined;\n\n    return {\n      query,\n      kbId,\n      topK,\n      filters,\n      outputKey\n    };\n  }\n\n  /**\n   * 执行检索\n   * @private\n   */\n  private async retrieve(\n    query: string,\n    kbId: string | undefined,\n    topK: number,\n    filters: Record<string, unknown>\n  ): Promise<RetrieveResult[]> {\n    try {\n      // 简化实现：直接查询数据库\n      let dbQuery = db('kb_chunks')\n        .join('kb_documents', 'kb_chunks.document_id', 'kb_documents.id')\n        .where('kb_documents.status', 'completed');\n\n      if (kbId) {\n        dbQuery = dbQuery.where('kb_documents.kb_id', kbId);\n      }\n\n      // 文本相似度匹配（简化版）\n      dbQuery = dbQuery.where('kb_chunks.text', 'like', `%${query}%`);\n\n      const results = await dbQuery\n        .select(\n          'kb_chunks.id',\n          'kb_chunks.text',\n          'kb_chunks.metadata',\n          'kb_documents.title',\n          'kb_documents.kb_id'\n        )\n        .limit(topK);\n\n      return results.map((r: { id: string; text: string; metadata: string; title: string; kb_id: string }) => ({\n        id: r.id,\n        text: r.text,\n        metadata: JSON.parse(r.metadata || '{}'),\n        title: r.title,\n        kbId: r.kb_id\n      }));\n    } catch (error) {\n      logger.error('[KBRetrieve] 数据库查询失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 解析变量值\n   * @private\n   */\n  private resolveValue(value: unknown, state: Record<string, unknown>): unknown {\n    if (typeof value === 'string') {\n      return value.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n        const resolved = this.getNestedValue(state, path.trim());\n        const replacement = resolved !== undefined ? resolved : match;\n        return typeof replacement === 'string' ? replacement : String(replacement);\n      });\n    }\n    return value;\n  }\n\n  /**\n   * 获取嵌套对象值\n   * @private\n   */\n  private getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n    const keys = path.split('.');\n    let value: unknown = obj;\n\n    for (const key of keys) {\n      if (value && typeof value === 'object' && key in value) {\n        value = (value as Record<string, unknown>)[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * 处理错误\n   * @private\n   */\n  private handleError(error: unknown): NodeError {\n    const err = error instanceof Error ? error : new Error(String(error));\n    return {\n      code: 'KB_RETRIEVE_ERROR',\n      message: err.message || 'KB retrieve failed',\n      type: NodeErrorType.KB_RETRIEVE_ERROR\n    };\n  }\n}\n\n// 导出单例\nexport const kbRetrieveExecutor = new KBRetrieveNodeExecutor();\n\nexport default kbRetrieveExecutor;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/engine/nodes/mcp-tool-call.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":260,"column":27,"nodeType":null,"messageId":"insert","endLine":260,"endColumn":27,"fix":{"range":[6387,6387],"text":"\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎······typeof·error·===·'object'·&&⏎······error·!==·null·&&⏎······'code'·in·error·&&⏎······'type'·in·error⏎····` with `typeof·error·===·'object'·&&·error·!==·null·&&·'code'·in·error·&&·'type'·in·error`","line":478,"column":9,"nodeType":null,"messageId":"replace","endLine":483,"endColumn":5,"fix":{"range":[11327,11438],"text":"typeof error === 'object' && error !== null && 'code' in error && 'type' in error"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········'EXECUTION_FAILED',⏎··········err.message,⏎··········NodeErrorType.EXECUTION_FAILED⏎········` with `'EXECUTION_FAILED',·err.message,·NodeErrorType.EXECUTION_FAILED`","line":508,"column":33,"nodeType":null,"messageId":"replace","endLine":512,"endColumn":9,"fix":{"range":[12254,12357],"text":"'EXECUTION_FAILED', err.message, NodeErrorType.EXECUTION_FAILED"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\n * MCP工具调用节点执行器\n * 艹，这个憨批节点负责调用MCP工具并合并结果到流程状态！\n *\n * 功能：\n * - 从上下文变量渲染参数\n * - 调用MCP工具\n * - 合并结果到state\n * - 支持重试与超时\n * - 完善的错误处理\n */\n\nimport axios, { AxiosInstance } from 'axios';\nimport db from '../../db/index.js';\nimport logger from '../../utils/logger.js';\nimport {\n  NodeExecutor,\n  NodeExecutionContext,\n  NodeExecutionResult,\n  NodeConfig,\n  NodeError,\n  NodeErrorType\n} from '../types.js';\n\n/**\n * MCP工具调用配置\n */\ninterface MCPToolCallConfig {\n  mcpEndpointRef: string; // MCP端点引用\n  toolName: string; // 工具名称\n  parameters: Record<string, unknown>; // 工具参数（支持变量模板）\n  outputKey?: string; // 输出键名（默认使用工具名称）\n  validateSchema?: boolean; // 是否验证参数Schema（默认true）\n}\n\n/**\n * MCP端点信息\n */\ninterface MCPEndpoint {\n  id: string;\n  name: string;\n  endpoint_url: string;\n  auth_token?: string;\n  transport_type: 'http' | 'ws' | 'stdio';\n  timeout_ms: number;\n  max_retries: number;\n}\n\n/**\n * MCP工具Schema\n */\ninterface MCPToolSchema {\n  name: string;\n  description: string;\n  parameters: {\n    type: 'object';\n    properties: Record<string, unknown>;\n    required?: string[];\n  };\n}\n\n/**\n * MCP工具调用节点执行器\n */\nclass MCPToolCallNodeExecutor implements NodeExecutor {\n  private axiosClient: AxiosInstance;\n\n  constructor() {\n    this.axiosClient = axios.create({\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n\n  /**\n   * 执行MCP工具调用节点\n   */\n  async execute(context: NodeExecutionContext): Promise<NodeExecutionResult> {\n    const startTime = Date.now();\n\n    try {\n      // 1. 解析节点配置\n      const config = this.parseConfig(context.node);\n\n      logger.info(\n        `[MCPToolCall] 开始执行: flowId=${context.flowContext.flowId} ` +\n          `nodeId=${context.node.id} tool=${config.toolName}`\n      );\n\n      // 2. 获取MCP端点配置\n      const endpoint = await this.getMCPEndpoint(config.mcpEndpointRef);\n\n      if (!endpoint) {\n        throw this.createError(\n          'MCP_ENDPOINT_NOT_FOUND',\n          `MCP endpoint not found: ${config.mcpEndpointRef}`,\n          NodeErrorType.INVALID_CONFIG\n        );\n      }\n\n      // 3. 渲染参数（解析变量模板）\n      const resolvedParams = this.resolveParameters(config.parameters, context.flowContext.state);\n\n      // 4. 验证参数Schema（可选）\n      if (config.validateSchema) {\n        await this.validateParameters(endpoint, config.toolName, resolvedParams);\n      }\n\n      // 5. 调用MCP工具\n      const result = await this.callMCPTool(endpoint, config.toolName, resolvedParams, context);\n\n      // 6. 合并结果到流程状态\n      const outputKey = config.outputKey || config.toolName;\n      context.flowContext.state[outputKey] = result;\n\n      const duration = Date.now() - startTime;\n\n      logger.info(\n        `[MCPToolCall] 执行成功: nodeId=${context.node.id} ` +\n          `tool=${config.toolName} duration=${duration}ms`\n      );\n\n      return {\n        success: true,\n        outputs: {\n          [outputKey]: result\n        },\n        duration,\n        metadata: {\n          toolName: config.toolName,\n          endpoint: endpoint.name\n        }\n      };\n    } catch (error: unknown) {\n      const duration = Date.now() - startTime;\n\n      logger.error(`[MCPToolCall] 执行失败: nodeId=${context.node.id}`, error);\n\n      return {\n        success: false,\n        error: this.handleError(error),\n        duration\n      };\n    }\n  }\n\n  /**\n   * 验证节点配置\n   */\n  validate(config: NodeConfig): boolean {\n    try {\n      this.parseConfig(config);\n      return true;\n    } catch (error) {\n      logger.error('[MCPToolCall] 配置验证失败:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 解析节点配置\n   * @private\n   */\n\n  /**\n   * 获取MCP端点配置\n   * @private\n   */\n  private async getMCPEndpoint(endpointRef: string): Promise<MCPEndpoint | null> {\n    try {\n      const endpoint = await db('mcp_endpoints')\n        .where('endpoint_ref', endpointRef)\n        .andWhere('is_active', true)\n        .first();\n\n      return endpoint || null;\n    } catch (error) {\n      logger.error('[MCPToolCall] 获取MCP端点失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 解析参数（变量模板）\n   * @private\n   */\n  private resolveParameters(\n    params: Record<string, unknown>,\n    state: Record<string, unknown>\n  ): Record<string, unknown> {\n    const resolved: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(params)) {\n      resolved[key] = this.resolveValue(value, state);\n    }\n\n    return resolved;\n  }\n\n  /**\n   * 解析单个值（支持变量模板）\n   * @private\n   */\n  private resolveValue(value: unknown, state: Record<string, unknown>): unknown {\n    if (typeof value === 'string') {\n      // 解析 {{variable}} 模板\n      return value.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n        const resolved = this.getNestedValue(state, path.trim());\n        const replacement = resolved !== undefined ? resolved : match;\n        if (replacement === null || replacement === undefined) {\n          return '';\n        }\n        return typeof replacement === 'string' ? replacement : String(replacement);\n      });\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((item) => this.resolveValue(item, state));\n    }\n\n    if (typeof value === 'object' && value !== null) {\n      const resolved: Record<string, unknown> = {};\n      for (const [k, v] of Object.entries(value)) {\n        resolved[k] = this.resolveValue(v, state);\n      }\n      return resolved;\n    }\n\n    return value;\n  }\n\n  private parseConfig(node: NodeConfig): MCPToolCallConfig {\n    const rawConfig = node.config as Record<string, unknown> | undefined;\n    if (!rawConfig || typeof rawConfig !== 'object') {\n      throw this.createError('INVALID_CONFIG', 'MCP工具配置不能为空', NodeErrorType.INVALID_CONFIG);\n    }\n\n    const mcpEndpointRef = rawConfig.mcpEndpointRef;\n    if (typeof mcpEndpointRef !== 'string' || mcpEndpointRef.trim().length === 0) {\n      throw this.createError(\n        'MISSING_ENDPOINT_REF',\n        '缺少mcpEndpointRef配置',\n        NodeErrorType.INVALID_CONFIG\n      );\n    }\n\n    const toolName = rawConfig.toolName;\n    if (typeof toolName !== 'string' || toolName.trim().length === 0) {\n      throw this.createError('MISSING_TOOL_NAME', '缺少toolName配置', NodeErrorType.INVALID_CONFIG);\n    }\n\n    const parameters =\n      rawConfig.parameters && typeof rawConfig.parameters === 'object'\n        ? (rawConfig.parameters as Record<string, unknown>)\n        : {};\n\n    const outputKey = typeof rawConfig.outputKey === 'string' ? rawConfig.outputKey : undefined;\n    const validateSchema = rawConfig.validateSchema === undefined ? true : Boolean(rawConfig.validateSchema);\n\n    return {\n      mcpEndpointRef,\n      toolName,\n      parameters,\n      outputKey,\n      validateSchema\n    };\n  }\n\n  /**\n   * 获取嵌套对象值\n   * @private\n   */\n  private getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n    const keys = path.split('.');\n    let value: unknown = obj;\n\n    for (const key of keys) {\n      if (value && typeof value === 'object' && key in value) {\n        value = (value as Record<string, unknown>)[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * 验证参数Schema\n   * @private\n   */\n  private async validateParameters(\n    endpoint: MCPEndpoint,\n    toolName: string,\n    params: Record<string, unknown>\n  ): Promise<void> {\n    try {\n      // 从MCP端点获取工具Schema\n      const schema = await this.getToolSchema(endpoint, toolName);\n\n      if (!schema) {\n        logger.warn(`[MCPToolCall] 工具Schema不存在: ${toolName}`);\n        return;\n      }\n\n      // 验证必需参数\n      const required = schema.parameters.required || [];\n      for (const field of required) {\n        if (!(field in params) || params[field] === undefined) {\n          throw this.createError(\n            'MISSING_REQUIRED_PARAM',\n            `Missing required parameter: ${field}`,\n            NodeErrorType.MISSING_INPUT\n          );\n        }\n      }\n\n      // 这里可以添加更复杂的Schema验证（使用Zod或Joi）\n    } catch (error) {\n      logger.error('[MCPToolCall] 参数验证失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取工具Schema\n   * @private\n   */\n  private async getToolSchema(\n    endpoint: MCPEndpoint,\n    toolName: string\n  ): Promise<MCPToolSchema | null> {\n    try {\n      // 调用MCP端点的discover接口获取工具列表\n      const response = await this.axiosClient.post(\n        `${endpoint.endpoint_url}/discover`,\n        {},\n        {\n          headers: this.getAuthHeaders(endpoint),\n          timeout: endpoint.timeout_ms\n        }\n      );\n\n      const tools = response.data.tools || [];\n      const tool = tools.find((t: { name: string }) => t.name === toolName);\n\n      return tool || null;\n    } catch (error) {\n      logger.error('[MCPToolCall] 获取工具Schema失败:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 调用MCP工具\n   * @private\n   */\n  private async callMCPTool(\n    endpoint: MCPEndpoint,\n    toolName: string,\n    params: Record<string, unknown>,\n    context: NodeExecutionContext\n  ): Promise<unknown> {\n    const maxRetries = context.node.retryPolicy?.maxRetries || endpoint.max_retries || 0;\n    const retryDelay = context.node.retryPolicy?.retryDelay || 1000;\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        if (attempt > 0) {\n          logger.info(\n            `[MCPToolCall] 重试调用: attempt=${attempt}/${maxRetries} ` + `tool=${toolName}`\n          );\n          await this.sleep(retryDelay * attempt);\n        }\n\n        const response = await this.axiosClient.post(\n          `${endpoint.endpoint_url}/execute`,\n          {\n            tool: toolName,\n            parameters: params\n          },\n          {\n            headers: this.getAuthHeaders(endpoint),\n            timeout: context.node.timeout || endpoint.timeout_ms\n          }\n        );\n\n        return response.data.result;\n      } catch (error: unknown) {\n        lastError = error as Error;\n\n        // 判断是否可重试\n        if (!this.isRetryableError(error) || attempt >= maxRetries) {\n          throw error;\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * 获取认证头\n   * @private\n   */\n  private getAuthHeaders(endpoint: MCPEndpoint): Record<string, string> {\n    const headers: Record<string, string> = {};\n\n    if (endpoint.auth_token) {\n      headers['Authorization'] = `Bearer ${endpoint.auth_token}`;\n    }\n\n    return headers;\n  }\n\n  /**\n   * 判断是否可重试的错误\n   * @private\n   */\n  private isRetryableError(error: unknown): boolean {\n    if (typeof error !== 'object' || error === null) {\n      return false;\n    }\n\n    const err = error as Record<string, unknown>;\n\n    // 网络错误可重试\n    if (err.code === 'ECONNRESET' || err.code === 'ETIMEDOUT') {\n      return true;\n    }\n\n    // 5xx服务器错误可重试\n    if (err.response) {\n      const response = err.response as Record<string, unknown>;\n      if (typeof response.status === 'number' && response.status >= 500) {\n        return true;\n      }\n    }\n\n    // 429 Too Many Requests可重试\n    if (err.response) {\n      const response = err.response as Record<string, unknown>;\n      if (response.status === 429) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * 创建错误对象\n   * @private\n   */\n  private createError(\n    code: string,\n    message: string,\n    type: NodeErrorType,\n    details?: Record<string, unknown>\n  ): NodeError {\n    return {\n      code,\n      message,\n      type,\n      details\n    };\n  }\n\n  /**\n   * 处理错误\n   * @private\n   */\n  private handleError(error: unknown): NodeError {\n    if (\n      typeof error === 'object' &&\n      error !== null &&\n      'code' in error &&\n      'type' in error\n    ) {\n      return error as NodeError; // 已经是NodeError\n    }\n\n    if (typeof error === 'object' && error !== null) {\n      const err = error as Record<string, unknown>;\n\n      if (err.code === 'ETIMEDOUT' || err.code === 'ECONNABORTED') {\n        return this.createError('MCP_TIMEOUT', 'MCP tool call timeout', NodeErrorType.TIMEOUT);\n      }\n\n      if (err.response) {\n        const response = err.response as Record<string, unknown>;\n        return this.createError(\n          'MCP_TOOL_ERROR',\n          `MCP tool error: ${response.status} ${response.statusText}`,\n          NodeErrorType.MCP_TOOL_ERROR,\n          {\n            status: response.status,\n            data: response.data\n          }\n        );\n      }\n\n      if ('message' in err && typeof err.message === 'string') {\n        return this.createError(\n          'EXECUTION_FAILED',\n          err.message,\n          NodeErrorType.EXECUTION_FAILED\n        );\n      }\n    }\n\n    return this.createError(\n      'EXECUTION_FAILED',\n      'MCP tool call failed',\n      NodeErrorType.EXECUTION_FAILED\n    );\n  }\n\n  /**\n   * 延迟函数\n   * @private\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// 导出单例\nexport const mcpToolCallExecutor = new MCPToolCallNodeExecutor();\n\nexport default mcpToolCallExecutor;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/engine/pipeline-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/engine/types.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `data:·Record<string,·unknown>,·context:·Record<string,·unknown>` with `⏎····data:·Record<string,·unknown>,⏎····context:·Record<string,·unknown>⏎··`","line":280,"column":14,"nodeType":null,"messageId":"replace","endLine":280,"endColumn":77,"fix":{"range":[5173,5236],"text":"\n    data: Record<string, unknown>,\n    context: Record<string, unknown>\n  "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 流程引擎类型定义\n * 艹，这个SB文件定义流程引擎的所有核心类型！\n *\n * 类型：\n * - 节点类型\n * - 流程上下文\n * - 执行结果\n * - 错误类型\n */\n\n/**\n * 节点类型枚举\n */\nexport enum NodeType {\n  // LLM相关\n  LLM_CHAT = 'LLM_CHAT',\n  LLM_COMPLETION = 'LLM_COMPLETION',\n\n  // MCP工具调用\n  MCP_TOOL_CALL = 'MCP_TOOL_CALL',\n\n  // RAG知识库\n  KB_RETRIEVE = 'KB_RETRIEVE',\n\n  // 数据处理\n  DATA_TRANSFORM = 'DATA_TRANSFORM',\n  DATA_FILTER = 'DATA_FILTER',\n\n  // 控制流\n  CONDITION = 'CONDITION',\n  LOOP = 'LOOP',\n  PARALLEL = 'PARALLEL',\n\n  // 输入输出\n  INPUT = 'INPUT',\n  OUTPUT = 'OUTPUT'\n}\n\n/**\n * 节点状态枚举\n */\nexport enum NodeStatus {\n  PENDING = 'pending',\n  RUNNING = 'running',\n  SUCCESS = 'success',\n  FAILED = 'failed',\n  SKIPPED = 'skipped'\n}\n\n/**\n * 节点配置接口\n */\nexport interface NodeConfig {\n  id: string; // 节点ID\n  type: NodeType; // 节点类型\n  name: string; // 节点名称\n  config: Record<string, unknown>; // 节点配置（特定于节点类型）\n  inputs?: NodeInput[]; // 输入连接\n  outputs?: NodeOutput[]; // 输出连接\n  retryPolicy?: RetryPolicy; // 重试策略\n  timeout?: number; // 超时时间（毫秒）\n}\n\n/**\n * 节点输入\n */\nexport interface NodeInput {\n  name: string; // 输入名称\n  sourceNodeId: string; // 来源节点ID\n  sourceOutputName: string; // 来源输出名称\n  transform?: string; // 转换表达式（可选）\n}\n\n/**\n * 节点输出\n */\nexport interface NodeOutput {\n  name: string; // 输出名称\n  value?: unknown; // 输出值\n}\n\n/**\n * 重试策略\n */\nexport interface RetryPolicy {\n  maxRetries: number; // 最大重试次数\n  retryDelay: number; // 重试延迟（毫秒）\n  backoff?: 'linear' | 'exponential'; // 退避策略\n  retryableErrors?: string[]; // 可重试的错误类型\n}\n\n/**\n * 流程上下文\n */\nexport interface FlowContext {\n  flowId: string; // 流程ID\n  executionId: string; // 执行ID\n  userId: string; // 用户ID\n  state: Record<string, unknown>; // 流程状态（变量存储）\n  metadata: Record<string, unknown>; // 元数据\n  createdAt: Date; // 创建时间\n  updatedAt: Date; // 更新时间\n}\n\n/**\n * 节点执行上下文\n */\nexport interface NodeExecutionContext {\n  node: NodeConfig; // 节点配置\n  flowContext: FlowContext; // 流程上下文\n  inputs: Record<string, unknown>; // 节点输入数据\n  attempt: number; // 当前尝试次数\n}\n\n/**\n * 节点执行结果\n */\nexport interface NodeExecutionResult {\n  success: boolean; // 是否成功\n  outputs?: Record<string, unknown>; // 输出数据\n  error?: NodeError; // 错误信息\n  duration: number; // 执行时长（毫秒）\n  metadata?: Record<string, unknown>; // 执行元数据\n}\n\n/**\n * 节点错误\n */\nexport interface NodeError {\n  code: string; // 错误码\n  message: string; // 错误信息\n  type: NodeErrorType; // 错误类型\n  details?: Record<string, unknown>; // 错误详情\n  stack?: string; // 错误堆栈\n}\n\n/**\n * 节点错误类型\n */\nexport enum NodeErrorType {\n  // 配置错误\n  INVALID_CONFIG = 'INVALID_CONFIG',\n  MISSING_INPUT = 'MISSING_INPUT',\n\n  // 执行错误\n  EXECUTION_FAILED = 'EXECUTION_FAILED',\n  TIMEOUT = 'TIMEOUT',\n  RETRY_EXHAUSTED = 'RETRY_EXHAUSTED',\n\n  // 外部服务错误\n  PROVIDER_ERROR = 'PROVIDER_ERROR',\n  MCP_TOOL_ERROR = 'MCP_TOOL_ERROR',\n  KB_RETRIEVE_ERROR = 'KB_RETRIEVE_ERROR',\n\n  // 系统错误\n  INTERNAL_ERROR = 'INTERNAL_ERROR'\n}\n\n/**\n * 流程执行器接口\n */\nexport interface FlowExecutor {\n  /**\n   * 执行流程\n   * @param flowConfig - 流程配置\n   * @param inputs - 输入数据\n   * @returns 执行结果\n   */\n  execute(flowConfig: FlowConfig, inputs: Record<string, unknown>): Promise<FlowExecutionResult>;\n\n  /**\n   * 暂停流程\n   * @param executionId - 执行ID\n   */\n  pause(executionId: string): Promise<void>;\n\n  /**\n   * 恢复流程\n   * @param executionId - 执行ID\n   */\n  resume(executionId: string): Promise<void>;\n\n  /**\n   * 取消流程\n   * @param executionId - 执行ID\n   */\n  cancel(executionId: string): Promise<void>;\n}\n\n/**\n * 流程配置\n */\nexport interface FlowConfig {\n  id: string; // 流程ID\n  name: string; // 流程名称\n  description?: string; // 流程描述\n  nodes: NodeConfig[]; // 节点列表\n  edges: FlowEdge[]; // 边（连接）列表\n  variables?: Record<string, unknown>; // 流程变量\n  settings?: FlowSettings; // 流程设置\n}\n\n/**\n * 流程边（连接）\n */\nexport interface FlowEdge {\n  id: string; // 边ID\n  source: string; // 来源节点ID\n  target: string; // 目标节点ID\n  sourceOutput?: string; // 来源输出端口\n  targetInput?: string; // 目标输入端口\n  condition?: string; // 条件表达式（可选）\n}\n\n/**\n * 流程设置\n */\nexport interface FlowSettings {\n  maxExecutionTime?: number; // 最大执行时间（毫秒）\n  maxRetries?: number; // 最大重试次数\n  errorHandling?: 'stop' | 'continue' | 'rollback'; // 错误处理策略\n  logging?: {\n    level: 'debug' | 'info' | 'warn' | 'error';\n    includeInputs: boolean;\n    includeOutputs: boolean;\n  };\n}\n\n/**\n * 流程执行结果\n */\nexport interface FlowExecutionResult {\n  success: boolean; // 是否成功\n  executionId: string; // 执行ID\n  outputs?: Record<string, unknown>; // 输出数据\n  error?: NodeError; // 错误信息\n  duration: number; // 执行时长（毫秒）\n  nodeResults: Record<string, NodeExecutionResult>; // 各节点执行结果\n  metadata?: Record<string, unknown>; // 执行元数据\n}\n\n/**\n * 节点执行器接口\n */\nexport interface NodeExecutor {\n  /**\n   * 执行节点\n   * @param context - 执行上下文\n   * @returns 执行结果\n   */\n  execute(context: NodeExecutionContext): Promise<NodeExecutionResult>;\n\n  /**\n   * 验证节点配置\n   * @param config - 节点配置\n   * @returns 是否有效\n   */\n  validate(config: NodeConfig): boolean;\n}\n\n/**\n * 变量解析器接口\n */\nexport interface VariableResolver {\n  /**\n   * 解析变量\n   * @param template - 变量模板（如 {{user.name}}）\n   * @param context - 上下文数据\n   * @returns 解析后的值\n   */\n  resolve(template: string, context: Record<string, unknown>): unknown;\n\n  /**\n   * 批量解析\n   * @param data - 包含变量的数据对象\n   * @param context - 上下文数据\n   * @returns 解析后的数据对象\n   */\n  resolveAll(data: Record<string, unknown>, context: Record<string, unknown>): Record<string, unknown>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/adminAuth.middleware.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··req:·Request,⏎··res:·Response,⏎··next:·NextFunction⏎` with `req:·Request,·res:·Response,·next:·NextFunction`","line":13,"column":36,"nodeType":null,"messageId":"replace","endLine":17,"endColumn":1,"fix":{"range":[376,431],"text":"req: Request, res: Response, next: NextFunction"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { NextFunction, Request, Response } from 'express';\nimport { db } from '../config/database.js';\nimport logger from '../utils/logger.js';\nimport type { UserRole } from '../utils/rbac.js';\nimport type { AuthRequest } from './auth.middleware.js';\n\ninterface AdminInfo {\n  id: string;\n  phone?: string;\n  role: UserRole | string;\n}\n\nexport async function requireAdmin(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  const adminReq = req as AuthRequest;\n  try {\n    const userId = adminReq.user?.id;\n\n    if (!userId) {\n      res.status(401).json({ success: false, error: { code: 4001, message: '未登录' } });\n      return;\n    }\n\n    const user = (await db('users').where('id', userId).first('id', 'phone', 'role')) as\n      | { id: string; phone?: string; role: string }\n      | undefined;\n\n    if (!user) {\n      res.status(404).json({ success: false, error: { code: 4004, message: '用户不存在' } });\n      return;\n    }\n\n    if (user.role !== 'admin') {\n      logger.warn(`[AdminAuth] 非管理员尝试访问管理接口 userId=${userId} role=${user.role}`);\n      res\n        .status(403)\n        .json({ success: false, error: { code: 4003, message: '无权访问,仅限管理员' } });\n      return;\n    }\n\n    // 附加到 req.admin（已在 global.d.ts 声明）\n    adminReq.admin = { id: user.id, phone: user.phone, role: user.role };\n    next();\n  } catch (error) {\n    const err = error as Error;\n    logger.error(`[AdminAuth] 权限验证失败: ${err.message}`, { userId: adminReq.user?.id, error });\n    res.status(500).json({ success: false, error: { code: 9999, message: '服务器内部错误' } });\n  }\n}\n\nexport default { requireAdmin };\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/auth.middleware.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··req:·Request,⏎··res:·Response,⏎··next:·NextFunction⏎` with `req:·Request,·res:·Response,·next:·NextFunction`","line":66,"column":36,"nodeType":null,"messageId":"replace","endLine":70,"endColumn":1,"fix":{"range":[1639,1694],"text":"req: Request, res: Response, next: NextFunction"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * JWT认证中间件 - 支持双Token机制\n * 艹，真正的TypeScript版本，不偷懒！\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport tokenService from '../services/token.service.js';\nimport logger from '../utils/logger.js';\nimport { UserRole } from '../utils/rbac.js';\n\n/**\n * 用户信息接口\n * 艹，必须和require-permission.middleware.ts里定义的类型一致！\n */\nexport interface UserPayload {\n  id: string;\n  role: UserRole;\n  uid?: string; // token中可能用uid存储id\n  jti?: string;\n  phone?: string;\n  source?: string;\n  [key: string]: unknown;\n}\n\n/**\n * 扩展后的请求对象，保留用户信息和Token，别乱删！\n */\nexport interface AuthRequest extends Request {\n  user?: UserPayload;\n  userId?: string;\n  token?: string;\n}\n\nconst ALLOWED_ROLES: readonly UserRole[] = ['viewer', 'editor', 'admin'] as const;\n\nfunction normalizeUserPayload(payload: unknown): UserPayload | null {\n  if (!payload || typeof payload !== 'object') {\n    return null;\n  }\n\n  const raw = payload as Record<string, unknown>;\n  const identifier = raw.uid ?? raw.id ?? raw.userId;\n\n  if (typeof identifier !== 'string' || identifier.length === 0) {\n    return null;\n  }\n\n  const roleCandidate = typeof raw.role === 'string' ? (raw.role as string) : undefined;\n  const normalizedRole = ALLOWED_ROLES.includes(roleCandidate as UserRole)\n    ? (roleCandidate as UserRole)\n    : 'viewer';\n\n  return {\n    ...(payload as Record<string, unknown>),\n    id: identifier,\n    uid: (raw.uid as string | undefined) ?? identifier,\n    role: normalizedRole,\n    jti: typeof raw.jti === 'string' ? raw.jti : undefined,\n    phone: typeof raw.phone === 'string' ? raw.phone : undefined\n  };\n}\n\n/**\n * JWT认证中间件\n */\nexport async function authenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  try {\n    const authReq = req as AuthRequest;\n    // 获取token\n    const authHeader = req.headers.authorization;\n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: '未登录或Token格式错误'\n        }\n      });\n      return;\n    }\n\n    const token = authHeader.substring(7);\n    authReq.token = token; // 保存原始token供其他中间件使用\n\n    // 验证Access Token\n    const decoded = tokenService.verifyAccessToken(token);\n    const normalizedUser = normalizeUserPayload(decoded);\n\n    if (!normalizedUser) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'INVALID_TOKEN',\n          message: 'Token无效'\n        }\n      });\n      return;\n    }\n\n    // 检查Token是否在黑名单中\n    const isBlacklisted = await tokenService.isTokenBlacklisted(normalizedUser.jti ?? '');\n    if (isBlacklisted) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'TOKEN_BLACKLISTED',\n          message: 'Token已失效'\n        }\n      });\n      return;\n    }\n\n    // 检查用户是否被撤销\n    const isRevoked = await tokenService.isUserRevoked(normalizedUser.id);\n    if (isRevoked) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'USER_REVOKED',\n          message: '用户登录状态已失效'\n        }\n      });\n      return;\n    }\n\n    // 将用户信息附加到请求对象\n    // 艹，注意decoded.role可能是string需要转换为UserRole！\n    authReq.userId = normalizedUser.id;\n    authReq.user = normalizedUser;\n\n    logger.debug(\n      `[AuthMiddleware] 用户认证成功: userId=${normalizedUser.id}, role=${normalizedUser.role}`\n    );\n    next();\n  } catch (error) {\n    const err = error as Error;\n    logger.error('JWT验证失败:', error);\n\n    if (err.name === 'TokenExpiredError') {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'TOKEN_EXPIRED',\n          message: '登录已过期，请刷新Token或重新登录'\n        }\n      });\n      return;\n    }\n\n    res.status(401).json({\n      success: false,\n      error: {\n        code: 'INVALID_TOKEN',\n        message: 'Token无效'\n      }\n    });\n  }\n}\n\n/**\n * 可选认证中间件(用于某些接口既可登录也可不登录访问)\n */\nexport async function optionalAuthenticate(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  try {\n    const authReq = req as AuthRequest;\n    const authHeader = req.headers.authorization;\n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.substring(7);\n      authReq.token = token;\n\n      // 尝试验证token\n      const decoded = tokenService.verifyAccessToken(token);\n      const normalizedUser = normalizeUserPayload(decoded);\n      if (normalizedUser) {\n        // 检查黑名单和撤销状态\n        const isBlacklisted = await tokenService.isTokenBlacklisted(normalizedUser.jti ?? '');\n        const isRevoked = await tokenService.isUserRevoked(normalizedUser.id);\n\n        if (!isBlacklisted && !isRevoked) {\n          authReq.userId = normalizedUser.id;\n          authReq.user = normalizedUser;\n        }\n      }\n    }\n    next();\n  } catch (error) {\n    const err = error as Error;\n    // 可选认证失败不阻止请求继续\n    logger.debug('可选认证失败:', err.message);\n    next();\n  }\n}\n\n/**\n * 角色权限检查中间件\n * @param requiredRoles - 需要的角色\n * @returns 中间件函数\n */\nexport function requireRole(requiredRoles: string | string[]) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const authReq = req as AuthRequest;\n    if (!authReq.user) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'UNAUTHORIZED',\n          message: '未登录'\n        }\n      });\n      return;\n    }\n\n    const userRole = authReq.user.role;\n    const roles = Array.isArray(requiredRoles) ? requiredRoles : [requiredRoles];\n\n    if (!roles.includes(userRole)) {\n      res.status(403).json({\n        success: false,\n        error: {\n          code: 'INSUFFICIENT_PERMISSIONS',\n          message: '权限不足'\n        }\n      });\n      return;\n    }\n\n    logger.debug(\n      `[AuthMiddleware] 权限检查通过: userId=${authReq.user.uid}, role=${userRole}, required=${roles.join(',')}`\n    );\n    next();\n  };\n}\n\n/**\n * 管理员权限检查\n */\nexport const requireAdmin = requireRole(['admin']);\n\n/**\n * 用户或管理员权限检查\n */\nexport const requireUserOrAdmin = requireRole(['user', 'admin']);\n\n/**\n * API Key认证中间件（用于系统间调用）\n */\nexport async function authenticateApiKey(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<void> {\n  try {\n    const authReq = req as AuthRequest;\n    const apiKey = authReq.headers['x-api-key'];\n    const validApiKeys = process.env.VALID_API_KEYS ? process.env.VALID_API_KEYS.split(',') : [];\n\n    if (!apiKey || !validApiKeys.includes(apiKey as string)) {\n      res.status(401).json({\n        success: false,\n        error: {\n          code: 'INVALID_API_KEY',\n          message: 'API Key无效'\n        }\n      });\n      return;\n    }\n\n    // 设置系统用户标识\n    // 艹，'system'不是合法的UserRole，用'admin'代替！\n    authReq.user = {\n      id: 'system',\n      uid: 'system',\n      role: 'admin' as UserRole,\n      source: 'api_key'\n    };\n    authReq.userId = 'system';\n\n    logger.debug('[AuthMiddleware] API Key认证成功');\n    next();\n  } catch (error) {\n    logger.error('API Key认证失败:', error);\n    res.status(401).json({\n      success: false,\n      error: {\n        code: 'API_KEY_AUTH_FAILED',\n        message: 'API Key认证失败'\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/cache.middleware.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎·········`","line":228,"column":26,"nodeType":null,"messageId":"delete","endLine":229,"endColumn":10,"fix":{"range":[7475,7485],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import type { NextFunction, Request, Response } from 'express';\nimport cacheService from '../services/cache.service.js';\nimport logger from '../utils/logger.js';\nimport crypto from 'crypto';\nimport type { AuthRequest } from './auth.middleware.js';\n\ninterface ResponseCacheOptions {\n  ttl?: number;\n  keyGenerator?: ((req: Request) => string) | null;\n  condition?: (req: Request, res: Response) => boolean;\n  namespace?: string;\n  skipCache?: boolean;\n  headersToInclude?: string[];\n  queryParamsToInclude?: string[];\n}\n\n/**\n * 扩展 Response 类型，包含自定义 json 方法\n */\ntype ResponseWithCustomJson = Response & {\n  json: (data: unknown) => Response;\n};\n\nclass CacheMiddleware {\n  responseCache(\n    options: ResponseCacheOptions = {}\n  ): (req: Request, res: Response, next: NextFunction) => Promise<void> {\n    const {\n      ttl = 300,\n      keyGenerator = null,\n      condition = () => true,\n      namespace = 'api_response',\n      skipCache = false,\n      headersToInclude = [],\n      queryParamsToInclude = []\n    } = options;\n\n    return async (req, res, next) => {\n      try {\n        if (skipCache || !condition(req, res)) {\n          return next();\n        }\n\n        const cacheKey = keyGenerator\n          ? keyGenerator(req)\n          : this.generateCacheKey(req, namespace, headersToInclude, queryParamsToInclude);\n\n        const cachedResponse = await cacheService.getWithVersion(namespace, cacheKey);\n        if (cachedResponse) {\n          logger.debug(`[CacheMiddleware] 缓存命中: ${cacheKey}`);\n          res.set('X-Cache', 'HIT');\n          res.set('X-Cache-Key', cacheKey);\n          res.json(cachedResponse);\n          return;\n        }\n\n        // 保存原始 json 方法\n        const originalJson = res.json.bind(res);\n        const customRes = res as ResponseWithCustomJson;\n\n        // 重写 json 方法以缓存响应\n        customRes.json = (data: unknown) => {\n          cacheService\n            .setWithVersion(namespace, cacheKey, data, ttl)\n            .then(() => {\n              logger.debug(`[CacheMiddleware] 响应已缓存: ${cacheKey}`);\n            })\n            .catch((error) => {\n              logger.warn(`[CacheMiddleware] 响应缓存失败: ${cacheKey}`, error);\n            });\n\n          res.set('X-Cache', 'MISS');\n          res.set('X-Cache-Key', cacheKey);\n          return originalJson(data);\n        };\n\n        next();\n      } catch (error) {\n        logger.error('[CacheMiddleware] 缓存中间件错误', error);\n        next();\n      }\n    };\n  }\n\n  userCache(options: { ttl?: number; namespace?: string } = {}) {\n    const { ttl = 600, namespace = 'user_data' } = options;\n    return this.responseCache({\n      ttl,\n      namespace,\n      keyGenerator: (req) => {\n        const authReq = req as AuthRequest;\n        const userId =\n          authReq.user?.id ||\n          String((req.params as Record<string, unknown>).userId || '') ||\n          String((req.query as Record<string, unknown>).userId || '');\n        return `user:${userId}:${req.originalUrl}`;\n      },\n      condition: (req) => Boolean((req as AuthRequest).user)\n    });\n  }\n\n  adminCache(options: { ttl?: number; namespace?: string } = {}) {\n    const { ttl = 180, namespace = 'admin_data' } = options;\n    return this.responseCache({\n      ttl,\n      namespace,\n      keyGenerator: (req) => {\n        const adminId = (req as AuthRequest).user?.id;\n        const path = req.originalUrl;\n        const query = JSON.stringify(req.query);\n        return `admin:${adminId}:${path}:${query}`;\n      },\n      condition: (req) => (req as AuthRequest).user?.role === 'admin'\n    });\n  }\n\n  featureCache(options: { ttl?: number; namespace?: string } = {}) {\n    const { ttl = 3600, namespace = 'feature_config' } = options;\n    return this.responseCache({\n      ttl,\n      namespace,\n      keyGenerator: (req) => {\n        const params = req.params as Record<string, unknown>;\n        const query = req.query as Record<string, unknown>;\n        const featureId = params.featureId || query.featureId;\n        return `feature:${featureId}`;\n      },\n      condition: (req) =>\n        req.originalUrl.includes('/feature/') || req.originalUrl.includes('/api/features')\n    });\n  }\n\n  statsCache(options: { ttl?: number; namespace?: string } = {}) {\n    const { ttl = 900, namespace = 'stats_data' } = options;\n    return this.responseCache({\n      ttl,\n      namespace,\n      keyGenerator: (req) => {\n        const userId = (req as AuthRequest).user?.id;\n        const path = req.originalUrl;\n        const query = JSON.stringify(req.query);\n        return `stats:${userId}:${path}:${query}`;\n      },\n      condition: (req) =>\n        req.originalUrl.includes('/stats/') ||\n        req.originalUrl.includes('/analytics/') ||\n        req.originalUrl.includes('/dashboard')\n    });\n  }\n\n  generateCacheKey(\n    req: Request,\n    namespace: string,\n    headersToInclude: string[] = [],\n    queryParamsToInclude: string[] = []\n  ): string {\n    try {\n      const keyComponents: string[] = [req.method.toLowerCase(), req.path];\n      const authReq = req as AuthRequest;\n\n      if (authReq.user?.id) {\n        keyComponents.push(`user:${authReq.user.id}`);\n      }\n\n      const queryObj = req.query as Record<string, unknown>;\n      if (queryParamsToInclude.length > 0) {\n        const queryParams: Record<string, unknown> = {};\n        for (const param of queryParamsToInclude) {\n          const q = queryObj[param];\n          if (q !== undefined) queryParams[param] = q;\n        }\n        if (Object.keys(queryParams).length > 0) {\n          keyComponents.push(`q:${JSON.stringify(queryParams)}`);\n        }\n      } else if (Object.keys(req.query).length > 0) {\n        keyComponents.push(`q:${JSON.stringify(req.query)}`);\n      }\n\n      const headersObj = req.headers as Record<string, unknown>;\n      if (headersToInclude.length > 0) {\n        const headers: Record<string, unknown> = {};\n        for (const header of headersToInclude) {\n          const v = headersObj[header];\n          if (v) headers[header] = v;\n        }\n        if (Object.keys(headers).length > 0) {\n          keyComponents.push(`h:${JSON.stringify(headers)}`);\n        }\n      }\n\n      const baseKey = keyComponents.join(':');\n      const hash = crypto.createHash('md5').update(baseKey).digest('hex').substring(0, 8);\n      return `${namespace}:${hash}:${baseKey.substring(0, 100)}`;\n    } catch (error) {\n      logger.error('[CacheMiddleware] 生成缓存键失败', error);\n      return `${namespace}:${req.method}:${req.path}:${Date.now()}`;\n    }\n  }\n\n  clearCache(namespace: string, pattern: string | null = null) {\n    return async (_req: Request, _res: Response, next: NextFunction) => {\n      try {\n        if (pattern) {\n          await cacheService.deletePattern(`${namespace}:${pattern}*`);\n          logger.info(`[CacheMiddleware] 清除缓存: ${namespace}:${pattern}*`);\n        } else {\n          await cacheService.incrementVersion(namespace);\n          logger.info(`[CacheMiddleware] 清除命名空间缓存: ${namespace}`);\n        }\n        next();\n      } catch (error) {\n        logger.error('[CacheMiddleware] 清除缓存失败', error);\n        next();\n      }\n    };\n  }\n\n  cacheControl() {\n    return (req: Request, res: Response, next: NextFunction) => {\n      res.set('Cache-Control', 'no-cache, no-store, must-revalidate');\n      res.set('Pragma', 'no-cache');\n      res.set('Expires', '0');\n\n      const queryObj = req.query as Record<string, unknown>;\n      const headersObj = req.headers as Record<string, unknown>;\n\n      if (queryObj.nocache === 'true') {\n        const namespace =\n          (headersObj['x-cache-namespace'] as string | undefined) || 'api_response';\n        const pattern = headersObj['x-cache-pattern'] as string | undefined;\n\n        if (pattern) {\n          cacheService\n            .deletePattern(`${namespace}:${pattern}*`)\n            .then(() => logger.info(`[CacheMiddleware] 强制清除缓存: ${namespace}:${pattern}*`))\n            .catch((error) => logger.warn('[CacheMiddleware] 强制清除缓存失败', error));\n        } else {\n          cacheService\n            .incrementVersion(namespace)\n            .then(() => logger.info(`[CacheMiddleware] 强制清除命名空间: ${namespace}`))\n            .catch((error) => logger.warn('[CacheMiddleware] 强制清除命名空间失败', error));\n        }\n      }\n\n      next();\n    };\n  }\n\n  conditionalCache(\n    condition: (req: Request, res: Response) => boolean,\n    cacheOptions: Omit<ResponseCacheOptions, 'condition'> = {}\n  ) {\n    const options: ResponseCacheOptions = {\n      ...cacheOptions,\n      condition: (req, res) => {\n        try {\n          return condition(req, res);\n        } catch (error) {\n          logger.error('[CacheMiddleware] 条件判断失败', error);\n          return false;\n        }\n      }\n    };\n    return this.responseCache(options);\n  }\n\n  timeBasedCache(\n    timeConfig: {\n      workHours?: { start: number; end: number };\n      workDays?: number[];\n      timezone?: string;\n    } = {},\n    cacheOptions: ResponseCacheOptions & { workTTL?: number; offWorkTTL?: number } = {}\n  ) {\n    const { workHours = { start: 9, end: 18 }, workDays = [1, 2, 3, 4, 5] } = timeConfig;\n\n    // 艹！创建可变的options对象来动态设置ttl\n    let dynamicTTL = 300;\n\n    const options: ResponseCacheOptions = {\n      ...cacheOptions,\n      condition: (_req) => {\n        const now = new Date();\n        const hour = now.getHours();\n        const day = now.getDay();\n        const isWorkHour = hour >= workHours.start && hour < workHours.end;\n        const isWorkDay = workDays.includes(day);\n        if (isWorkHour && isWorkDay) {\n          dynamicTTL = cacheOptions.workTTL || 300;\n        } else {\n          dynamicTTL = cacheOptions.offWorkTTL || 1800;\n        }\n        return true;\n      },\n      ttl: dynamicTTL\n    };\n    return this.responseCache(options);\n  }\n\n  cacheStats() {\n    return (_req: Request, res: Response, next: NextFunction) => {\n      if (_req.path === '/cache/stats') {\n        const stats = cacheService.getStats();\n        return res.json({\n          success: true,\n          data: { ...(stats as Record<string, unknown>), timestamp: new Date().toISOString() }\n        });\n      }\n      next();\n    };\n  }\n\n  cacheHealthCheck() {\n    return async (req: Request, res: Response, next: NextFunction) => {\n      if (req.path === '/cache/health') {\n        try {\n          const health = await cacheService.healthCheck();\n          return res.json({ success: true, data: health });\n        } catch (error) {\n          const err = error as Error;\n          return res.status(503).json({ success: false, error: err.message });\n        }\n      }\n      next();\n    };\n  }\n}\n\nconst cacheMiddleware = new CacheMiddleware();\nexport default cacheMiddleware;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/enhanced-error-handler.middleware.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/middlewares/enhanced-error-handler.middleware.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const enhancedErrorHandler: {\n  getErrorStats: () => any;\n  resetStats: () => void;\n};\nexport default enhancedErrorHandler;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/enhanced-error-handler.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/error-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/metrics.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/rateLimiter.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/request-id.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/require-permission.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/security.middleware.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `req.ip·as·string` with `⏎········req.ip·as·string⏎······`","line":117,"column":74,"nodeType":null,"messageId":"replace","endLine":117,"endColumn":90,"fix":{"range":[3799,3815],"text":"\n        req.ip as string\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎················'SUSPICIOUS_ACTIVITY',⏎················'请求被标记为可疑活动，已被阻止',` with `'SUSPICIOUS_ACTIVITY',·'请求被标记为可疑活动，已被阻止',·{`","line":144,"column":35,"nodeType":null,"messageId":"replace","endLine":146,"endColumn":35,"fix":{"range":[4739,4813],"text":"'SUSPICIOUS_ACTIVITY', '请求被标记为可疑活动，已被阻止', {"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `{·...suspicious,·severity·}·as·Record<string,·unknown>⏎··············` with `...suspicious,⏎················severity⏎··············}·as·Record<string,·unknown>`","line":147,"column":17,"nodeType":null,"messageId":"replace","endLine":148,"endColumn":15,"fix":{"range":[4830,4899],"text":"...suspicious,\n                severity\n              } as Record<string, unknown>"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import type { NextFunction, Request, Response } from 'express';\nimport * as securityService from '../services/security.service.js';\nimport { createErrorResponse } from '../utils/response.js';\nimport logger from '../utils/logger.js';\nimport type { DataMaskingRule, HealthCheck } from '../services/security.service.js';\n\ntype ResponseWithCustomMethods = Response & {\n  json: (data: unknown) => Response;\n  send: (data: unknown) => Response;\n};\n\ntype SuspiciousActivityResult = Awaited<\n  ReturnType<typeof securityService.detectSuspiciousActivity>\n> & { severity?: 'low' | 'medium' | 'high' | 'critical' };\n\nexport interface RateLimitConfig {\n  windowMs: number;\n  maxRequests: number;\n  message?: string;\n  keyGenerator?: (req: Request) => string;\n}\n\nexport const rateLimit = (config: RateLimitConfig) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const key = config.keyGenerator\n        ? config.keyGenerator(req)\n        : `rate_limit:${req.ip}:${req.path}`;\n\n      const result = await securityService.checkRateLimit(key, {\n        windowMs: config.windowMs,\n        maxRequests: config.maxRequests,\n        message: config.message || '请求过于频繁，请稍后再试'\n      });\n\n      res.set({\n        'X-RateLimit-Limit': String(result.limit),\n        'X-RateLimit-Remaining': String(result.remaining),\n        'X-RateLimit-Reset': String(Math.ceil(result.resetTime.getTime() / 1000))\n      });\n\n      if (!result.allowed) {\n        res\n          .status(429)\n          .json(\n            createErrorResponse(\n              'RATE_LIMIT_EXCEEDED',\n              config.message || '请求过于频繁，请稍后再试',\n              { retryAfter: result.retryAfter, resetTime: result.resetTime }\n            )\n          );\n        return;\n      }\n\n      next();\n    } catch (error) {\n      logger.error('限流中间件错误:', error);\n      next();\n    }\n  };\n};\n\nexport const dataMasking = (rules: DataMaskingRule[] = []) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const originalJson = res.json.bind(res);\n    const customRes = res as ResponseWithCustomMethods;\n\n    customRes.json = (data: unknown) => {\n      if (\n        data &&\n        typeof data === 'object' &&\n        'data' in data &&\n        (data as Record<string, unknown>).data\n      ) {\n        const dataObj = data as Record<string, unknown>;\n        dataObj.data = securityService.maskData(dataObj.data as Record<string, unknown>, rules);\n      }\n      return originalJson(data);\n    };\n    next();\n  };\n};\n\nexport const securityCheck = (options: { skipCriticalCheck?: boolean } = {}) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const checks = await securityService.performHealthChecks();\n      const checksData = checks.checks as HealthCheck[];\n      const criticalIssues = checksData.filter((check) => {\n        const details = (check.details as { severity?: string } | undefined) ?? undefined;\n        const severity = typeof details?.severity === 'string' ? details.severity : undefined;\n        return check.status === 'unhealthy' && severity === 'critical';\n      });\n\n      if (criticalIssues.length > 0 && !options.skipCriticalCheck) {\n        logger.error('发现严重安全问题:', criticalIssues);\n        res.status(503).json(\n          createErrorResponse('SECURITY_ISSUE', '系统安全问题，暂时无法提供服务', {\n            issues: criticalIssues\n          })\n        );\n        return;\n      }\n\n      req.securityChecks = checks;\n      next();\n    } catch (error) {\n      logger.error('安全检查中间件错误:', error);\n      next();\n    }\n  };\n};\n\nexport const suspiciousActivityDetection = (options: Record<string, unknown> = {}) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const suspicious = (await securityService.detectSuspiciousActivity(req.ip as string)) as SuspiciousActivityResult;\n\n      if (suspicious.suspicious) {\n        const severity: SuspiciousActivityResult['severity'] =\n          suspicious.riskScore >= 80\n            ? 'critical'\n            : suspicious.riskScore >= 60\n              ? 'high'\n              : suspicious.riskScore >= 30\n                ? 'medium'\n                : 'low';\n        logger.warn('检测到可疑活动:', suspicious);\n        await securityService.logSecurityEvent({\n          type: 'suspicious_activity',\n          severity,\n          userId: req.user?.id,\n          ip: String(req.ip ?? ''),\n          userAgent: req.get('User-Agent') ?? '',\n          endpoint: req.path,\n          method: req.method,\n          details: { ...suspicious, severity } as Record<string, unknown>\n        });\n\n        if (severity === 'high' || severity === 'critical') {\n          res\n            .status(403)\n            .json(\n              createErrorResponse(\n                'SUSPICIOUS_ACTIVITY',\n                '请求被标记为可疑活动，已被阻止',\n                { ...suspicious, severity } as Record<string, unknown>\n              )\n            );\n          return;\n        }\n      }\n\n      next();\n    } catch (error) {\n      logger.error('可疑活动检测中间件错误:', error);\n      next();\n    }\n  };\n};\n\nexport const securityAudit = (\n  options: { includeRequestData?: boolean; includeResponseData?: boolean } = {}\n) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    const originalSend = res.send.bind(res);\n    const originalJson = res.json.bind(res);\n    const startTime = Date.now();\n\n    const audit = (statusCode: number, data: unknown) => {\n      const auditData = {\n        method: req.method,\n        endpoint: req.path,\n        statusCode,\n        userId: req.user?.id,\n        ip: String(req.ip ?? ''),\n        userAgent: req.get('User-Agent') ?? '',\n        responseTime: Date.now() - startTime,\n        requestData: options.includeRequestData ? req.body : undefined,\n        responseData: options.includeResponseData ? data : undefined\n      };\n      securityService.logSecurityEvent({\n        type: 'data_access',\n        severity: statusCode >= 400 ? 'medium' : 'low',\n        userId: req.user?.id,\n        ip: String(req.ip ?? ''),\n        endpoint: req.path,\n        method: req.method,\n        details: auditData\n      });\n    };\n\n    const customRes = res as ResponseWithCustomMethods;\n\n    customRes.send = (data: unknown) => {\n      audit(res.statusCode, data);\n      return originalSend(data);\n    };\n\n    customRes.json = (data: unknown) => {\n      audit(res.statusCode, data);\n      return originalJson(data);\n    };\n\n    next();\n  };\n};\n\nexport const ipWhitelist = (allowedIPs: string[] = []) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const connection = req.connection as { remoteAddress?: string };\n    const clientIP = (req.ip || connection.remoteAddress) as string;\n    if (allowedIPs.length > 0 && !allowedIPs.includes(clientIP)) {\n      logger.warn(`IP ${clientIP} 不在白名单中，拒绝访问`);\n      res.status(403).json(createErrorResponse('IP_NOT_ALLOWED', 'IP地址不在允许范围中'));\n      return;\n    }\n    next();\n  };\n};\n\nexport const forceHTTPS = (options: { skipInDev?: boolean } = {}) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const secureReq = req as { secure?: boolean };\n    if (secureReq.secure || req.headers['x-forwarded-proto'] === 'https') {\n      next();\n      return;\n    }\n    if (process.env.NODE_ENV === 'development' && options.skipInDev) {\n      next();\n      return;\n    }\n    const httpsUrl = `https://${req.headers.host}${req.url}`;\n    res.redirect(301, httpsUrl);\n  };\n};\n\nexport const securityHeaders = (options: Record<string, string> = {}) => {\n  return (_req: Request, res: Response, next: NextFunction) => {\n    res.set({\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': options['frameOptions'] || 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Strict-Transport-Security': options['hsts'] || 'max-age=31536000; includeSubDomains',\n      'Content-Security-Policy': options['csp'] || \"default-src 'self'\",\n      'Referrer-Policy': options['referrerPolicy'] || 'strict-origin-when-cross-origin',\n      'Permissions-Policy':\n        options['permissionsPolicy'] || 'geolocation=(), microphone=(), camera=()'\n    });\n    next();\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/validate.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/validation.middleware.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/middlewares/validation.middleware.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export declare const validateCircuitBreakerOperation: (\n  req: import('express').Request,\n  res: import('express').Response,\n  next: import('express').NextFunction\n) => void;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/middlewares/validation.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/base/base-provider.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·error·!==·null·&&·'name'·in·error·&&` with `⏎··········error·!==·null·&&⏎··········'name'·in·error·&&⏎·········`","line":145,"column":38,"nodeType":null,"messageId":"replace","endLine":145,"endColumn":75,"fix":{"range":[3312,3349],"text":"\n          error !== null &&\n          'name' in error &&\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········error·!==·null·&&⏎·········` with `·error·!==·null·&&`","line":254,"column":39,"nodeType":null,"messageId":"replace","endLine":256,"endColumn":10,"fix":{"range":[6378,6416],"text":" error !== null &&"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········error·instanceof·Error⏎············?·error.message⏎···········` with `·error·instanceof·Error·?·error.message`","line":267,"column":29,"nodeType":null,"messageId":"replace","endLine":270,"endColumn":12,"fix":{"range":[6740,6813],"text":" error instanceof Error ? error.message"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"/**\n * BaseProvider基类\n * 提供通用的重试、超时、日志等功能\n * 这tm的是所有Provider的基础，必须继承！\n */\n\nimport {\n  IProvider,\n  ExecContext,\n  ExecResult,\n  RetryPolicy,\n  ProviderError,\n  ProviderErrorCode,\n  DEFAULT_RETRY_POLICY,\n  DEFAULT_TIMEOUT\n} from '../types.js';\n\n/**\n * 日志接口\n * Provider可以通过这个接口输出日志\n */\nexport interface ILogger {\n  info(message: string, meta?: unknown): void;\n  warn(message: string, meta?: unknown): void;\n  error(message: string, meta?: unknown): void;\n  debug(message: string, meta?: unknown): void;\n}\n\n/**\n * 默认日志实现（使用console）\n * 生产环境应该替换成Winston等专业日志库\n */\nclass ConsoleLogger implements ILogger {\n  info(message: string, meta?: unknown): void {\n    console.log(`[INFO] ${message}`, meta || '');\n  }\n\n  warn(message: string, meta?: unknown): void {\n    console.warn(`[WARN] ${message}`, meta || '');\n  }\n\n  error(message: string, meta?: unknown): void {\n    console.error(`[ERROR] ${message}`, meta || '');\n  }\n\n  debug(message: string, meta?: unknown): void {\n    console.debug(`[DEBUG] ${message}`, meta || '');\n  }\n}\n\n/**\n * BaseProvider抽象基类\n * 实现了通用的重试、超时控制、日志等功能\n */\nexport abstract class BaseProvider implements IProvider {\n  /** Provider唯一标识 */\n  public abstract readonly key: string;\n\n  /** Provider显示名称 */\n  public abstract readonly name: string;\n\n  /** 重试策略配置 */\n  protected retryPolicy: RetryPolicy;\n\n  /** 日志接口 */\n  protected logger: ILogger;\n\n  /** 默认超时时间（毫秒） */\n  protected defaultTimeout: number;\n\n  constructor(\n    retryPolicy: RetryPolicy = DEFAULT_RETRY_POLICY,\n    logger: ILogger = new ConsoleLogger(),\n    defaultTimeout: number = DEFAULT_TIMEOUT\n  ) {\n    this.retryPolicy = retryPolicy;\n    this.logger = logger;\n    this.defaultTimeout = defaultTimeout;\n  }\n\n  /**\n   * 参数校验（子类必须实现）\n   * @param input - 输入数据\n   * @returns 校验错误信息，null表示校验通过\n   */\n  public abstract validate(input: unknown): string | null;\n\n  /**\n   * 执行Provider任务（带重试和超时控制）\n   * 这个tm的方法是模板方法，子类不应该重写！\n   * @param context - 执行上下文\n   * @returns Promise<ExecResult> - 执行结果\n   */\n  public async execute(context: ExecContext): Promise<ExecResult> {\n    const startTime = Date.now();\n\n    // 1. 参数校验\n    const validationError = this.validate(context.input);\n    if (validationError) {\n      this.logger.error(`[${this.key}] 参数校验失败`, {\n        taskId: context.taskId,\n        error: validationError\n      });\n      return {\n        success: false,\n        error: {\n          code: ProviderErrorCode.ERR_PROVIDER_VALIDATION_FAILED,\n          message: validationError\n        },\n        duration: Date.now() - startTime\n      };\n    }\n\n    // 2. 设置超时控制\n    const timeout = context.timeout || this.defaultTimeout;\n    const abortController = new AbortController();\n    const timeoutId = setTimeout(() => {\n      abortController.abort();\n    }, timeout);\n\n    // 艹，如果用户传入了signal，需要监听它并同步到内部的abortController\n    if (context.signal) {\n      context.signal.addEventListener('abort', () => {\n        abortController.abort();\n      });\n    }\n\n    try {\n      // 3. 带重试的执行\n      const result = await this.executeWithRetry({\n        ...context,\n        signal: abortController.signal\n      });\n\n      clearTimeout(timeoutId);\n      return {\n        ...result,\n        duration: Date.now() - startTime\n      };\n    } catch (error: unknown) {\n      clearTimeout(timeoutId);\n\n      // 处理超时错误\n      if (\n        (typeof error === 'object' && error !== null && 'name' in error && (error as Record<string, unknown>).name === 'AbortError') ||\n        abortController.signal.aborted\n      ) {\n        this.logger.error(`[${this.key}] 执行超时`, {\n          taskId: context.taskId,\n          timeout\n        });\n        return {\n          success: false,\n          error: {\n            code: ProviderErrorCode.ERR_PROVIDER_TIMEOUT,\n            message: `执行超时（${timeout}ms）`,\n            details: { timeout }\n          },\n          duration: Date.now() - startTime\n        };\n      }\n\n      // 处理其他错误\n      let errorCode = ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED;\n      let message = '执行失败';\n      let details: unknown = undefined;\n\n      if (error instanceof ProviderError) {\n        errorCode = error.code;\n        message = error.message;\n        details = error.details;\n      } else if (error instanceof Error) {\n        message = error.message || '执行失败';\n        details = { stack: error.stack };\n      } else {\n        message = String(error);\n      }\n\n      this.logger.error(`[${this.key}] 执行失败`, {\n        taskId: context.taskId,\n        error: message,\n        stack: details\n      });\n\n      return {\n        success: false,\n        error: {\n          code: errorCode,\n          message,\n          details\n        },\n        duration: Date.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * 带重试的执行逻辑\n   * 使用指数退避算法进行重试\n   * @param context - 执行上下文\n   * @returns Promise<ExecResult> - 执行结果\n   */\n  protected async executeWithRetry(context: ExecContext): Promise<ExecResult> {\n    let lastError: unknown = null;\n    let attempt = 0;\n\n    while (attempt <= this.retryPolicy.maxRetries) {\n      try {\n        this.logger.debug(\n          `[${this.key}] 开始执行 (尝试 ${attempt + 1}/${this.retryPolicy.maxRetries + 1})`,\n          { taskId: context.taskId }\n        );\n\n        // 调用子类实现的doExecute方法\n        const result = await this.doExecute(context);\n\n        if (result.success) {\n          if (attempt > 0) {\n            this.logger.info(\n              `[${this.key}] 重试成功 (尝试 ${attempt + 1}/${this.retryPolicy.maxRetries + 1})`,\n              { taskId: context.taskId }\n            );\n          }\n          return result;\n        }\n\n        // 执行失败，判断是否可重试\n        const errorCode = result.error?.code || '';\n        const isRetryable = this.isRetryableError(errorCode);\n\n        if (!isRetryable || attempt >= this.retryPolicy.maxRetries) {\n          this.logger.warn(\n            `[${this.key}] 执行失败，不再重试 (错误码: ${errorCode}, 可重试: ${isRetryable})`,\n            { taskId: context.taskId }\n          );\n          return result;\n        }\n\n        lastError = result.error;\n        this.logger.warn(\n          `[${this.key}] 执行失败，准备重试 (尝试 ${attempt + 1}/${this.retryPolicy.maxRetries + 1})`,\n          { taskId: context.taskId, error: errorCode }\n        );\n      } catch (error: unknown) {\n        // 捕获doExecute抛出的异常\n        lastError = error;\n\n        // 检查是否被中止（超时）\n        if (context.signal?.aborted) {\n          throw error;\n        }\n\n        const errorCode =\n          typeof error === 'object' &&\n          error !== null &&\n          'code' in error\n            ? (error as Record<string, unknown>).code\n            : ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED;\n\n        const isRetryable = this.isRetryableError(String(errorCode));\n\n        // 艹，如果不可重试，直接throw\n        if (!isRetryable) {\n          throw error;\n        }\n\n        const errorMessage =\n          error instanceof Error\n            ? error.message\n            : String(error);\n\n        // 如果已经达到最大重试次数，不throw，让循环结束后返回MAX_RETRIES_EXCEEDED\n        if (attempt >= this.retryPolicy.maxRetries) {\n          this.logger.warn(\n            `[${this.key}] 执行异常，已达最大重试次数 (尝试 ${attempt + 1}/${this.retryPolicy.maxRetries + 1})`,\n            { taskId: context.taskId, error: errorMessage }\n          );\n          // 不throw，让程序继续，最后会走到循环后面返回MAX_RETRIES_EXCEEDED\n        } else {\n          this.logger.warn(\n            `[${this.key}] 执行异常，准备重试 (尝试 ${attempt + 1}/${this.retryPolicy.maxRetries + 1})`,\n            { taskId: context.taskId, error: errorMessage }\n          );\n        }\n      }\n\n      // 计算延迟时间（指数退避）\n      attempt++;\n      if (attempt <= this.retryPolicy.maxRetries) {\n        const delay = this.calculateBackoffDelay(attempt);\n        this.logger.debug(`[${this.key}] 等待 ${delay}ms 后重试`, {\n          taskId: context.taskId\n        });\n\n        // 等待一段时间后重试，同时检查是否被中止\n        try {\n          await this.sleep(delay, context.signal);\n        } catch (sleepError: unknown) {\n          // sleep被中止，直接抛出\n          if (\n            (typeof sleepError === 'object' &&\n              sleepError !== null &&\n              'name' in sleepError &&\n              (sleepError as Record<string, unknown>).name === 'AbortError') ||\n            context.signal?.aborted\n          ) {\n            throw sleepError;\n          }\n          throw sleepError;\n        }\n      }\n    }\n\n    // 重试次数耗尽\n    this.logger.error(`[${this.key}] 重试次数耗尽`, {\n      taskId: context.taskId,\n      maxRetries: this.retryPolicy.maxRetries\n    });\n\n    // 艹，重试次数耗尽了，返回MAX_RETRIES_EXCEEDED错误结果\n    return {\n      success: false,\n      error: {\n        code: ProviderErrorCode.ERR_PROVIDER_MAX_RETRIES_EXCEEDED,\n        message: `重试次数耗尽（${this.retryPolicy.maxRetries}次）`,\n        details: { lastError }\n      }\n    };\n  }\n\n  /**\n   * 实际执行逻辑（子类必须实现）\n   * 这个tm的方法才是真正干活的地方！\n   * @param context - 执行上下文\n   * @returns Promise<ExecResult> - 执行结果\n   */\n  protected abstract doExecute(context: ExecContext): Promise<ExecResult>;\n\n  /**\n   * 健康检查（子类可选实现）\n   * @returns Promise<boolean> - true表示健康，false表示不可用\n   */\n  public async healthCheck(): Promise<boolean> {\n    // 默认实现：假设总是健康\n    // 子类可以重写这个方法，实现真正的健康检查\n    return true;\n  }\n\n  /**\n   * 判断错误是否可重试\n   * @param errorCode - 错误码\n   * @returns boolean - true表示可重试\n   */\n  protected isRetryableError(errorCode: string): boolean {\n    // 如果retryableErrors为空，则所有错误都可重试\n    if (!this.retryPolicy.retryableErrors || this.retryPolicy.retryableErrors.length === 0) {\n      // 但超时和参数校验错误不应该重试\n      const nonRetryableErrors = [\n        ProviderErrorCode.ERR_PROVIDER_TIMEOUT,\n        ProviderErrorCode.ERR_PROVIDER_VALIDATION_FAILED\n      ];\n      return !nonRetryableErrors.includes(errorCode as ProviderErrorCode);\n    }\n\n    // 否则检查错误码是否在可重试列表中\n    return this.retryPolicy.retryableErrors.includes(errorCode);\n  }\n\n  /**\n   * 计算指数退避延迟时间\n   * @param attempt - 当前重试次数（从1开始）\n   * @returns number - 延迟时间（毫秒）\n   */\n  protected calculateBackoffDelay(attempt: number): number {\n    const delay =\n      this.retryPolicy.initialDelay * Math.pow(this.retryPolicy.backoffMultiplier, attempt - 1);\n    return Math.min(delay, this.retryPolicy.maxDelay);\n  }\n\n  /**\n   * 可中断的sleep\n   * @param ms - 延迟时间（毫秒）\n   * @param signal - AbortSignal，用于取消等待\n   */\n  protected sleep(ms: number, signal?: AbortSignal): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        resolve();\n      }, ms);\n\n      // 监听中止信号\n      if (signal) {\n        const abortHandler = () => {\n          clearTimeout(timeoutId);\n          const error = new Error('执行被中止');\n          error.name = 'AbortError'; // 艹，这个name很重要！\n          reject(error);\n        };\n        signal.addEventListener('abort', abortHandler);\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/handlers/genericHttp.handler.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·error·!==·null·&&·'name'·in·error·&&` with `⏎··········error·!==·null·&&⏎··········'name'·in·error·&&⏎·········`","line":192,"column":38,"nodeType":null,"messageId":"replace","endLine":192,"endColumn":75,"fix":{"range":[4941,4978],"text":"\n          error !== null &&\n          'name' in error &&\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·error·!==·null·&&·'name'·in·error·&&` with `⏎··········error·!==·null·&&⏎··········'name'·in·error·&&⏎·········`","line":193,"column":38,"nodeType":null,"messageId":"replace","endLine":193,"endColumn":75,"fix":{"range":[5077,5114],"text":"\n          error !== null &&\n          'name' in error &&\n         "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\n * GenericHTTP Provider\n * 艹，这个Provider能处理99%的HTTP请求场景！\n * 支持模板变量替换、extractPath、超时重试\n */\n\nimport axios, { AxiosRequestConfig, AxiosError } from 'axios';\nimport { BaseProvider } from '../base/base-provider.js';\nimport { ExecContext, ExecResult, ProviderErrorCode, ProviderError } from '../types.js';\nimport { replaceVariables, extractValue } from '../../utils/template.js';\n\n/**\n * 请求模板接口\n */\nexport interface HttpRequestTemplate {\n  /** HTTP方法（GET/POST/PUT/DELETE/PATCH） */\n  method: string;\n\n  /** 请求URL（支持{{var}}变量替换） */\n  url: string;\n\n  /** 请求头（支持{{var}}变量替换） */\n  headers?: Record<string, string>;\n\n  /** 请求体（支持{{var}}变量替换） */\n  body?: unknown;\n\n  /** 查询参数（支持{{var}}变量替换） */\n  params?: Record<string, string>;\n\n  /** 从响应中提取数据的路径（JSONPath或点路径，如 result.url）*/\n  extractPath?: string;\n\n  /** 超时时间（毫秒），不传则使用默认值 */\n  timeout?: number;\n}\n\n/**\n * GenericHTTP Provider输入格式\n */\nexport interface GenericHttpInput {\n  /** 请求模板 */\n  req_template: HttpRequestTemplate;\n\n  /** 变量字典（用于替换模板中的{{var}}） */\n  variables?: Record<string, unknown>;\n}\n\n/**\n * GenericHTTP Provider实现\n * 继承BaseProvider，自动获得重试、超时控制、日志等能力\n */\nexport class GenericHttpProvider extends BaseProvider {\n  public readonly key = 'generic-http';\n  public readonly name = 'Generic HTTP Provider';\n\n  /**\n   * 参数校验\n   * @param input - 输入数据\n   * @returns 校验错误信息，null表示校验通过\n   */\n  public validate(input: unknown): string | null {\n    if (!input || typeof input !== 'object') {\n      return '输入参数必须是对象';\n    }\n\n    const { req_template } = input as GenericHttpInput;\n\n    if (!req_template) {\n      return '缺少必填字段: req_template';\n    }\n\n    if (!req_template.method) {\n      return '缺少必填字段: req_template.method';\n    }\n\n    if (!req_template.url) {\n      return '缺少必填字段: req_template.url';\n    }\n\n    // 验证HTTP方法\n    const validMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];\n    const method = req_template.method.toUpperCase();\n    if (!validMethods.includes(method)) {\n      return `不支持的HTTP方法: ${req_template.method}`;\n    }\n\n    return null;\n  }\n\n  /**\n   * 执行HTTP请求\n   * @param context - 执行上下文\n   * @returns Promise<ExecResult> - 执行结果\n   */\n  protected async doExecute(context: ExecContext): Promise<ExecResult> {\n    const input = context.input as GenericHttpInput;\n    const { req_template, variables = {} } = input;\n\n    try {\n      // 1. 变量替换（艹，只替换{{var}}，不执行表达式）\n      const method = req_template.method.toUpperCase();\n      const url = replaceVariables(req_template.url, variables) as string;\n      const headers = replaceVariables(req_template.headers || {}, variables) as Record<\n        string,\n        string\n      >;\n      const params = replaceVariables(req_template.params || {}, variables) as Record<\n        string,\n        string\n      >;\n\n      let body = req_template.body;\n      if (body) {\n        body = replaceVariables(body, variables);\n      }\n\n      this.logger.debug(`[${this.key}] 准备发送HTTP请求`, {\n        taskId: context.taskId,\n        method,\n        url,\n        hasBody: !!body\n      });\n\n      // 2. 构建axios配置\n      const axiosConfig: AxiosRequestConfig = {\n        method: method as 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS',\n        url,\n        headers,\n        params,\n        timeout: req_template.timeout || this.defaultTimeout\n      };\n\n      // 3. 添加请求体（仅POST/PUT/PATCH）\n      if (['POST', 'PUT', 'PATCH'].includes(method) && body) {\n        axiosConfig.data = body;\n      }\n\n      // 4. 支持AbortSignal（用于超时取消）\n      if (context.signal) {\n        // 艹，Axios的CancelToken已废弃，使用AbortSignal\n        (axiosConfig as Record<string, unknown>).signal = context.signal;\n      }\n\n      // 5. 执行HTTP请求\n      const response = await axios(axiosConfig);\n\n      this.logger.info(`[${this.key}] HTTP请求成功`, {\n        taskId: context.taskId,\n        statusCode: response.status,\n        url\n      });\n\n      // 6. 提取结果数据（可选）\n      let resultData = response.data;\n      if (req_template.extractPath) {\n        resultData = extractValue(response.data, req_template.extractPath);\n\n        if (resultData === undefined) {\n          this.logger.warn(`[${this.key}] extractPath未找到数据: ${req_template.extractPath}`, {\n            taskId: context.taskId\n          });\n        }\n      }\n\n      // 7. 返回成功结果\n      return {\n        success: true,\n        data: {\n          statusCode: response.status,\n          headers: response.headers,\n          body: resultData,\n          fullResponse: response.data // 保留完整响应（用于调试）\n        }\n      };\n    } catch (error: unknown) {\n      // 艹，HTTP请求失败了！\n      const err = error instanceof Error ? error : new Error(String(error));\n      this.logger.error(`[${this.key}] HTTP请求失败`, {\n        taskId: context.taskId,\n        error: err.message,\n        url: req_template.url\n      });\n\n      // 处理Axios错误\n      if (axios.isAxiosError(error)) {\n        return this.handleAxiosError(error, context.taskId);\n      }\n\n      // 处理AbortError（超时）\n      if (\n        (typeof error === 'object' && error !== null && 'name' in error && (error as Record<string, unknown>).name === 'AbortError') ||\n        (typeof error === 'object' && error !== null && 'name' in error && (error as Record<string, unknown>).name === 'CanceledError')\n      ) {\n        return {\n          success: false,\n          error: {\n            code: ProviderErrorCode.ERR_PROVIDER_TIMEOUT,\n            message: `HTTP请求超时: ${req_template.url}`,\n            details: {\n              timeout: req_template.timeout || this.defaultTimeout\n            }\n          }\n        };\n      }\n\n      // 其他未知错误\n      return {\n        success: false,\n        error: {\n          code: ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED,\n          message: err.message || 'HTTP请求执行失败',\n          details: { stack: err instanceof Error ? err.stack : undefined }\n        }\n      };\n    }\n  }\n\n  /**\n   * 处理Axios错误（归一化错误码）\n   * @param error - Axios错误对象\n   * @param taskId - 任务ID\n   * @returns ExecResult - 执行结果\n   */\n  private handleAxiosError(error: AxiosError, taskId: string): ExecResult {\n    const response = error.response;\n\n    // 艹，根据HTTP状态码归一化错误信息\n    if (response) {\n      const statusCode = response.status;\n      let errorCode = ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED;\n      let message = `HTTP请求失败 (${statusCode})`;\n\n      // HTTP状态码归一化\n      if (statusCode >= 400 && statusCode < 500) {\n        // 4xx 客户端错误\n        message = `客户端错误 (${statusCode}): ${this.getStatusText(statusCode)}`;\n      } else if (statusCode >= 500) {\n        // 5xx 服务器错误\n        message = `服务器错误 (${statusCode}): ${this.getStatusText(statusCode)}`;\n      }\n\n      return {\n        success: false,\n        error: {\n          code: errorCode,\n          message,\n          details: {\n            statusCode,\n            statusText: response.statusText,\n            responseData: response.data,\n            requestUrl: error.config?.url\n          }\n        }\n      };\n    }\n\n    // 网络错误（没有响应）\n    if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n      return {\n        success: false,\n        error: {\n          code: ProviderErrorCode.ERR_PROVIDER_TIMEOUT,\n          message: '请求超时',\n          details: {\n            requestUrl: error.config?.url,\n            timeout: error.config?.timeout\n          }\n        }\n      };\n    }\n\n    // 网络连接失败\n    return {\n      success: false,\n      error: {\n        code: ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED,\n        message: `网络错误: ${error.message}`,\n        details: {\n          requestUrl: error.config?.url,\n          errorCode: error.code\n        }\n      }\n    };\n  }\n\n  /**\n   * 获取HTTP状态码的文本描述\n   * @param statusCode - HTTP状态码\n   * @returns 状态描述\n   */\n  private getStatusText(statusCode: number): string {\n    const statusTexts: Record<number, string> = {\n      400: 'Bad Request',\n      401: 'Unauthorized',\n      403: 'Forbidden',\n      404: 'Not Found',\n      405: 'Method Not Allowed',\n      408: 'Request Timeout',\n      429: 'Too Many Requests',\n      500: 'Internal Server Error',\n      502: 'Bad Gateway',\n      503: 'Service Unavailable',\n      504: 'Gateway Timeout'\n    };\n\n    return statusTexts[statusCode] || 'Unknown';\n  }\n\n  /**\n   * 健康检查（可选）\n   * 这里简单返回true，子类可以override实现真正的健康检查\n   */\n  public async healthCheck(): Promise<boolean> {\n    // 乖乖，这里可以ping一个健康检查端点\n    return true;\n  }\n}\n\n// 导出默认实例（兼容旧代码）\nexport default GenericHttpProvider;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/handlers/runninghub.handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/handlers/scf.handler.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·typeof·error·===·'object'·&&·error·!==·null·&&·'code'·in·error·?·(error·as·Record<string,·unknown>).code` with `⏎········typeof·error·===·'object'·&&·error·!==·null·&&·'code'·in·error⏎··········?·(error·as·Record<string,·unknown>).code⏎·········`","line":237,"column":24,"nodeType":null,"messageId":"replace","endLine":237,"endColumn":129,"fix":{"range":[5869,5974],"text":"\n        typeof error === 'object' && error !== null && 'code' in error\n          ? (error as Record<string, unknown>).code\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `response:·Record<string,·unknown>,·invokeType:·'sync'·|·'async'` with `⏎····response:·Record<string,·unknown>,⏎····invokeType:·'sync'·|·'async'⏎··`","line":257,"column":28,"nodeType":null,"messageId":"replace","endLine":257,"endColumn":91,"fix":{"range":[6425,6488],"text":"\n    response: Record<string, unknown>,\n    invokeType: 'sync' | 'async'\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·resultPayload·!==·null·&&` with `⏎········resultPayload·!==·null·&&⏎·······`","line":280,"column":45,"nodeType":null,"messageId":"replace","endLine":280,"endColumn":71,"fix":{"range":[7066,7092],"text":"\n        resultPayload !== null &&\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·typeof·error·===·'object'·&&·error·!==·null·&&·'code'·in·error·?·(error·as·Record<string,·unknown>).code` with `⏎········typeof·error·===·'object'·&&·error·!==·null·&&·'code'·in·error⏎··········?·(error·as·Record<string,·unknown>).code⏎·········`","line":317,"column":20,"nodeType":null,"messageId":"replace","endLine":317,"endColumn":125,"fix":{"range":[8176,8281],"text":"\n        typeof error === 'object' && error !== null && 'code' in error\n          ? (error as Record<string, unknown>).code\n         "}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"/**\n * ScfProvider - 腾讯云云函数（SCF）Provider\n *\n * 职责：\n * - 支持同步/异步调用腾讯云SCF\n * - 支持传递自定义事件参数\n * - 严格的参数校验（auth、functionName、payload、invokeType）\n * - 统一的错误处理和日志\n *\n * 艹，这个Provider遵循最小权限、幂等、重试+死信、可观测四大基线！\n */\n\nimport { BaseProvider } from '../base/base-provider.js';\nimport { ExecContext, ExecResult, ProviderErrorCode } from '../types.js';\n\n// 导入腾讯云SCF SDK\nconst tencentcloud = require('tencentcloud-sdk-nodejs');\nconst ScfClient = tencentcloud.scf.v20180416.Client;\n\n/**\n * SCF认证配置接口\n */\nexport interface ScfAuth {\n  /** 腾讯云SecretId */\n  secretId: string;\n\n  /** 腾讯云SecretKey */\n  secretKey: string;\n\n  /** 临时密钥Token（可选，使用临时密钥时必填） */\n  token?: string;\n\n  /** 地域（如 ap-guangzhou、ap-shanghai） */\n  region: string;\n}\n\n/**\n * SCF调用参数接口\n */\nexport interface ScfParams {\n  /** 函数名称（必填） */\n  functionName: string;\n\n  /** 函数命名空间（可选，默认default） */\n  namespace?: string;\n\n  /** 函数版本/别名（可选，默认$LATEST） */\n  qualifier?: string;\n\n  /** 调用类型（必填：sync=同步、async=异步） */\n  invokeType: 'sync' | 'async';\n\n  /** 事件参数（必填，传递给云函数的数据） */\n  payload: unknown;\n\n  /** 日志类型（可选：None=不返回日志、Tail=返回日志） */\n  logType?: 'None' | 'Tail';\n}\n\n/**\n * SCF Provider输入格式\n */\nexport interface ScfInput {\n  /** 认证配置 */\n  auth: ScfAuth;\n\n  /** 调用参数 */\n  params: ScfParams;\n}\n\n/**\n * ScfProvider实现\n * 继承BaseProvider，自动获得重试、超时控制、日志等能力\n *\n * 乖乖，这个Provider严格遵循SOLID原则和SCF Worker规范！\n */\nexport class ScfProvider extends BaseProvider {\n  public readonly key = 'scf';\n  public readonly name = 'Tencent Cloud SCF Provider';\n\n  /**\n   * 参数校验\n   * 艹，这个方法必须严格校验所有参数！\n   * @param input - 输入数据\n   * @returns 校验错误信息，null表示校验通过\n   */\n  public validate(input: unknown): string | null {\n    if (!input || typeof input !== 'object') {\n      return '输入参数必须是对象';\n    }\n\n    const { auth, params } = input as ScfInput;\n\n    // 校验auth配置\n    if (!auth) {\n      return '缺少必填字段: auth';\n    }\n\n    if (!auth.secretId || typeof auth.secretId !== 'string') {\n      return '缺少或无效的auth.secretId';\n    }\n\n    if (!auth.secretKey || typeof auth.secretKey !== 'string') {\n      return '缺少或无效的auth.secretKey';\n    }\n\n    if (!auth.region || typeof auth.region !== 'string') {\n      return '缺少或无效的auth.region';\n    }\n\n    // 校验region格式（如 ap-guangzhou）\n    const regionPattern = /^[a-z]+-[a-z]+(-\\d+)?$/;\n    if (!regionPattern.test(auth.region)) {\n      return `region格式无效: ${auth.region}，应为 ap-guangzhou、ap-shanghai 等格式`;\n    }\n\n    // 校验params配置\n    if (!params) {\n      return '缺少必填字段: params';\n    }\n\n    if (!params.functionName || typeof params.functionName !== 'string') {\n      return '缺少或无效的params.functionName';\n    }\n\n    if (!params.invokeType) {\n      return '缺少必填字段: params.invokeType';\n    }\n\n    // 校验invokeType\n    if (!['sync', 'async'].includes(params.invokeType)) {\n      return `invokeType无效: ${params.invokeType}，必须为 sync 或 async`;\n    }\n\n    // 校验payload（必须存在，可以是任意类型）\n    if (params.payload === undefined) {\n      return '缺少必填字段: params.payload';\n    }\n\n    // 校验logType（可选）\n    if (params.logType && !['None', 'Tail'].includes(params.logType)) {\n      return `logType无效: ${params.logType}，必须为 None 或 Tail`;\n    }\n\n    return null;\n  }\n\n  /**\n   * 执行SCF调用\n   * 艹，这个方法才是真正干活的地方！\n   * @param context - 执行上下文\n   * @returns Promise<ExecResult> - 执行结果\n   */\n  protected async doExecute(context: ExecContext): Promise<ExecResult> {\n    const input = context.input as ScfInput;\n    const { auth, params } = input;\n\n    try {\n      this.logger.info(`[${this.key}] 准备调用SCF`, {\n        taskId: context.taskId,\n        functionName: params.functionName,\n        namespace: params.namespace || 'default',\n        invokeType: params.invokeType\n      });\n\n      // 1. 初始化SCF客户端\n      const client = new ScfClient({\n        credential: {\n          secretId: auth.secretId,\n          secretKey: auth.secretKey,\n          token: auth.token // 临时密钥Token（可选）\n        },\n        region: auth.region,\n        profile: {\n          httpProfile: {\n            endpoint: 'scf.tencentcloudapi.com'\n          }\n        }\n      });\n\n      // 2. 构建调用参数\n      const clientContext =\n        typeof params.payload === 'string' ? params.payload : JSON.stringify(params.payload);\n\n      const invokeParams: Record<string, unknown> = {\n        FunctionName: params.functionName,\n        Namespace: params.namespace || 'default',\n        Qualifier: params.qualifier || '$LATEST',\n        // 艹，invokeType需要转换成腾讯云的枚举值\n        InvocationType: params.invokeType === 'sync' ? 'RequestResponse' : 'Event',\n        LogType: params.logType || 'None',\n        // 艹，payload需要转成JSON字符串（如果不是字符串的话）\n        ClientContext: clientContext\n      };\n\n      this.logger.debug(`[${this.key}] SCF调用参数`, {\n        taskId: context.taskId,\n        invokeParams: {\n          ...invokeParams,\n          ClientContext: `${clientContext.substring(0, 100)}...` // 只打印前100字符\n        }\n      });\n\n      // 3. 执行云函数调用\n      const startTime = Date.now();\n      const response = await client.Invoke(invokeParams);\n      const duration = Date.now() - startTime;\n\n      this.logger.info(`[${this.key}] SCF调用成功`, {\n        taskId: context.taskId,\n        functionName: params.functionName,\n        duration,\n        requestId: response.RequestId\n      });\n\n      // 4. 解析响应结果\n      const result = this.parseScfResponse(response, params.invokeType);\n\n      // 5. 返回成功结果\n      return {\n        success: true,\n        data: {\n          invokeType: params.invokeType,\n          functionName: params.functionName,\n          namespace: params.namespace || 'default',\n          qualifier: params.qualifier || '$LATEST',\n          requestId: response.RequestId,\n          result: result,\n          duration,\n          // 可选：返回日志（仅当logType=Tail时）\n          log: response.Log ? Buffer.from(response.Log, 'base64').toString('utf-8') : undefined\n        }\n      };\n    } catch (error: unknown) {\n      // 艹，SCF调用失败了！\n      const err = error instanceof Error ? error : new Error(String(error));\n      const errorCode = typeof error === 'object' && error !== null && 'code' in error ? (error as Record<string, unknown>).code : undefined;\n\n      this.logger.error(`[${this.key}] SCF调用失败`, {\n        taskId: context.taskId,\n        functionName: params.functionName,\n        error: err.message,\n        code: errorCode\n      });\n\n      // 处理腾讯云API错误\n      return this.handleScfError(error, context.taskId, params.functionName);\n    }\n  }\n\n  /**\n   * 解析SCF响应结果\n   * @param response - SCF API响应\n   * @param invokeType - 调用类型\n   * @returns 解析后的结果\n   */\n  private parseScfResponse(response: Record<string, unknown>, invokeType: 'sync' | 'async'): unknown {\n    const scfResponse = response as {\n      RequestId?: string;\n      Result?: string | (Record<string, unknown> & { FunctionRequestId?: string; RetMsg?: string });\n    };\n\n    // 异步调用没有返回结果\n    if (invokeType === 'async') {\n      return {\n        message: '异步调用已提交',\n        requestId: scfResponse.RequestId\n      };\n    }\n\n    // 同步调用需要解析Result字段\n    if (!scfResponse.Result) {\n      return null;\n    }\n\n    try {\n      // 艹，Result是JSON字符串，需要解析\n      const resultPayload = scfResponse.Result;\n      const resultValue =\n        typeof resultPayload === 'object' && resultPayload !== null && 'FunctionRequestId' in resultPayload\n          ? (resultPayload as { RetMsg?: string }).RetMsg\n          : resultPayload;\n\n      // 如果Result是对象，直接返回\n      if (typeof resultValue === 'object' && resultValue !== null) {\n        return resultValue;\n      }\n\n      // 尝试解析JSON\n      if (typeof resultValue === 'string') {\n        return JSON.parse(resultValue);\n      }\n\n      return resultValue;\n    } catch (error) {\n      // 解析失败，返回原始字符串\n      this.logger.warn(`[${this.key}] 无法解析SCF返回结果为JSON`, {\n        result: scfResponse.Result\n      });\n      return scfResponse.Result;\n    }\n  }\n\n  /**\n   * 处理SCF错误（归一化错误码）\n   * @param error - 错误对象\n   * @param taskId - 任务ID\n   * @param functionName - 函数名称\n   * @returns ExecResult - 执行结果\n   */\n  private handleScfError(error: unknown, taskId: string, functionName: string): ExecResult {\n    let errorCode = ProviderErrorCode.ERR_PROVIDER_EXECUTION_FAILED;\n    let message = `SCF调用失败: ${error instanceof Error ? error.message : String(error)}`;\n    const details: Record<string, unknown> = {\n      taskId,\n      functionName,\n      originalCode: typeof error === 'object' && error !== null && 'code' in error ? (error as Record<string, unknown>).code : undefined,\n      originalMessage: error instanceof Error ? error.message : String(error)\n    };\n\n    // 艹，根据腾讯云错误码归一化\n    if (typeof error === 'object' && error !== null && 'code' in error) {\n      const code = (error as Record<string, unknown>).code;\n      switch (code) {\n        // 认证/权限错误\n        case 'AuthFailure.SecretIdNotFound':\n        case 'AuthFailure.SignatureFailure':\n        case 'AuthFailure.TokenFailure':\n        case 'AuthFailure.InvalidSecretId':\n          message = `认证失败: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'auth';\n          break;\n\n        case 'UnauthorizedOperation':\n        case 'UnauthorizedOperation.Role':\n          message = `权限不足: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'permission';\n          break;\n\n        // 参数错误\n        case 'InvalidParameterValue':\n        case 'InvalidParameter':\n        case 'MissingParameter':\n          errorCode = ProviderErrorCode.ERR_PROVIDER_VALIDATION_FAILED;\n          message = `参数错误: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'parameter';\n          break;\n\n        // 资源不存在\n        case 'ResourceNotFound.Function':\n        case 'ResourceNotFound.FunctionName':\n        case 'ResourceNotFound.Namespace':\n          message = `资源不存在: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'not_found';\n          break;\n\n        // 限流/配额\n        case 'LimitExceeded':\n        case 'RequestLimitExceeded':\n        case 'ResourceInUse.FunctionName':\n          message = `配额限制: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'quota';\n          break;\n\n        // 超时\n        case 'ResourceUnavailable.FunctionInsufficientBalance':\n          errorCode = ProviderErrorCode.ERR_PROVIDER_TIMEOUT;\n          message = `函数执行超时: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'timeout';\n          break;\n\n        // 内部错误（可重试）\n        case 'InternalError':\n        case 'InternalError.System':\n          message = `内部错误: ${error instanceof Error ? error.message : String(error)}`;\n          details.category = 'internal';\n          details.retryable = true;\n          break;\n\n        default:\n          message = `SCF调用失败: ${error instanceof Error ? error.message : String(error)} (${code})`;\n          details.category = 'unknown';\n          break;\n      }\n    }\n\n    // 记录详细错误\n    const stack = error instanceof Error ? error.stack : undefined;\n    this.logger.error(`[${this.key}] SCF错误详情`, {\n      ...details,\n      stack\n    });\n\n    return {\n      success: false,\n      error: {\n        code: errorCode,\n        message,\n        details\n      }\n    };\n  }\n\n  /**\n   * 健康检查（可选）\n   * 艹，这里可以调用一个测试函数检查SCF是否可达\n   * @returns Promise<boolean> - true表示健康\n   */\n  public async healthCheck(): Promise<boolean> {\n    // TODO: 实现真正的健康检查（可选）\n    // 例如：调用一个预设的健康检查函数\n    return true;\n  }\n}\n\n// 导出默认实例（兼容ProviderLoader）\nexport default ScfProvider;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/handlers/tencentCi.handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/provider-loader.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·······`","line":106,"column":28,"nodeType":null,"messageId":"insert","endLine":106,"endColumn":28,"fix":{"range":[2457,2457],"text":"\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·handlerKey,·originalError:·err.message,·stack:·err·instanceof·Error·?·err.stack·:·undefined` with `⏎··········handlerKey,⏎··········originalError:·err.message,⏎··········stack:·err·instanceof·Error·?·err.stack·:·undefined⏎·······`","line":149,"column":10,"nodeType":null,"messageId":"replace","endLine":149,"endColumn":102,"fix":{"range":[3787,3879],"text":"\n          handlerKey,\n          originalError: err.message,\n          stack: err instanceof Error ? err.stack : undefined\n       "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { IProvider, ProviderError, ProviderErrorCode } from './types.js';\n\n/**\n * Provider白名单配置\n * 艹，这个tm的是安全关键！只有这里列出的handlerKey才能加载！\n * 禁止从数据库动态加载代码，那是SB设计会导致代码注入漏洞！\n */\nconst ALLOW_LIST: Record<string, () => Promise<Record<string, unknown>>> = {\n  /**\n   * 通用HTTP Provider - 支持标准HTTP/HTTPS请求\n   */\n  GENERIC_HTTP: () => import('./handlers/genericHttp.handler.js'),\n\n  /**\n   * 腾讯云万象（CI）Provider - 图片/视频处理\n   */\n  TENCENT_CI: () => import('./handlers/tencentCi.handler.js'),\n\n  /**\n   * RunningHub工作流Provider - 第三方工作流编排\n   */\n  RUNNINGHUB: () => import('./handlers/runninghub.handler.js'),\n\n  /**\n   * 腾讯云云函数（SCF）Provider - Serverless函数调用\n   */\n  SCF: () => import('./handlers/scf.handler.js')\n};\n\n/**\n * ProviderLoader - Provider动态加载器\n *\n * 职责：\n * 1. 根据handlerKey从白名单动态加载Provider\n * 2. 缓存已加载的Provider实例（避免重复实例化）\n * 3. 拒绝非白名单的handlerKey（安全机制）\n *\n * 这个tm的类遵循单一职责原则（SOLID-S），只负责加载Provider！\n */\nclass ProviderLoader {\n  /**\n   * Provider实例缓存\n   * key: handlerKey (例如 \"GENERIC_HTTP\")\n   * value: IProvider实例\n   *\n   * 乖乖，这个缓存能避免重复实例化，提高性能！\n   */\n  private cache: Map<string, IProvider>;\n\n  /**\n   * 加载统计（用于监控和调试）\n   */\n  private stats: {\n    loadCount: number;\n    cacheHitCount: number;\n    errorCount: number;\n  };\n\n  constructor() {\n    this.cache = new Map();\n    this.stats = {\n      loadCount: 0,\n      cacheHitCount: 0,\n      errorCount: 0\n    };\n  }\n\n  /**\n   * 加载Provider实例\n   *\n   * @param handlerKey - Provider类型（必须在白名单中）\n   * @returns Promise<IProvider> - Provider实例\n   * @throws ProviderError - 当handlerKey不在白名单或加载失败时\n   *\n   * 使用示例：\n   * ```typescript\n   * const provider = await providerLoader.loadProvider('GENERIC_HTTP');\n   * const result = await provider.execute(input, taskId);\n   * ```\n   */\n  async loadProvider(handlerKey: string): Promise<IProvider> {\n    // 1. 检查缓存（艹，命中缓存就不用重复加载了！）\n    const cached = this.cache.get(handlerKey);\n    if (cached) {\n      this.stats.cacheHitCount++;\n      return cached;\n    }\n\n    // 2. 检查白名单（这个tm的是安全关键！）\n    const importFn = ALLOW_LIST[handlerKey];\n    if (!importFn) {\n      this.stats.errorCount++;\n      throw new ProviderError(\n        ProviderErrorCode.ERR_PROVIDER_NOT_ALLOWED,\n        `Provider不在白名单中: ${handlerKey}. 允许的类型: ${Object.keys(ALLOW_LIST).join(', ')}`,\n        { handlerKey, allowList: Object.keys(ALLOW_LIST) }\n      );\n    }\n\n    // 3. 动态加载Provider模块\n    try {\n      this.stats.loadCount++;\n      const module = await importFn();\n\n      // 获取默认导出或命名导出\n      const ProviderClass = module.default || (module as Record<string, unknown>)[Object.keys(module)[0]];\n\n      if (!ProviderClass) {\n        throw new Error(`Provider模块没有导出有效的类: ${handlerKey}`);\n      }\n\n      // 4. 实例化Provider\n      const provider: IProvider = new (ProviderClass as new () => IProvider)();\n\n      // 5. 验证Provider实现（艹，必须有execute方法！）\n      if (typeof provider.execute !== 'function') {\n        throw new Error(`Provider未实现execute方法: ${handlerKey}`);\n      }\n\n      // 6. 可选：执行健康检查\n      if (typeof provider.healthCheck === 'function') {\n        const isHealthy = await provider.healthCheck();\n        if (!isHealthy) {\n          throw new ProviderError(\n            ProviderErrorCode.ERR_PROVIDER_UNHEALTHY,\n            `Provider健康检查失败: ${handlerKey}`,\n            { handlerKey }\n          );\n        }\n      }\n\n      // 7. 缓存实例（乖乖，下次就能直接用了！）\n      this.cache.set(handlerKey, provider);\n\n      return provider;\n    } catch (error: unknown) {\n      this.stats.errorCount++;\n\n      // 如果已经是ProviderError，直接抛出\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n\n      // 否则包装成ProviderError\n      const err = error instanceof Error ? error : new Error(String(error));\n      throw new ProviderError(\n        ProviderErrorCode.ERR_PROVIDER_LOAD_FAILED,\n        `Provider加载失败: ${handlerKey}. 错误: ${err.message}`,\n        { handlerKey, originalError: err.message, stack: err instanceof Error ? err.stack : undefined }\n      );\n    }\n  }\n\n  /**\n   * 清除缓存（用于测试或热重载）\n   * 艹，生产环境别tm乱用这个方法！\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * 清除指定Provider的缓存\n   * @param handlerKey - Provider类型\n   */\n  clearCacheForProvider(handlerKey: string): void {\n    this.cache.delete(handlerKey);\n  }\n\n  /**\n   * 获取加载统计信息（用于监控）\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      cacheSize: this.cache.size,\n      cachedProviders: Array.from(this.cache.keys())\n    };\n  }\n\n  /**\n   * 检查Provider是否在白名单中\n   * @param handlerKey - Provider类型\n   * @returns boolean - true表示在白名单中\n   */\n  isAllowed(handlerKey: string): boolean {\n    return handlerKey in ALLOW_LIST;\n  }\n\n  /**\n   * 获取所有允许的Provider类型\n   */\n  getAllowedProviders(): string[] {\n    return Object.keys(ALLOW_LIST);\n  }\n}\n\n/**\n * 单例实例（遵循单例模式）\n * 整个应用只需要一个ProviderLoader实例\n */\nexport const providerLoader = new ProviderLoader();\n\n/**\n * 导出类型和类（用于测试）\n */\nexport { ProviderLoader };\nexport type { IProvider };\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/providers/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/pubsub/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/rag/ingest/chunker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/rag/ingest/parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/rag/ingest/worker.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎······`","line":111,"column":37,"nodeType":null,"messageId":"insert","endLine":111,"endColumn":37,"fix":{"range":[3173,3173],"text":"\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":112,"column":7,"nodeType":null,"messageId":"insert","endLine":112,"endColumn":7,"fix":{"range":[3225,3225],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":113,"column":1,"nodeType":null,"messageId":"replace","endLine":113,"endColumn":7,"fix":{"range":[3250,3256],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":114,"column":7,"nodeType":null,"messageId":"insert","endLine":114,"endColumn":7,"fix":{"range":[3288,3288],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":115,"column":1,"nodeType":null,"messageId":"insert","endLine":115,"endColumn":1,"fix":{"range":[3306,3306],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":116,"column":7,"nodeType":null,"messageId":"insert","endLine":116,"endColumn":7,"fix":{"range":[3351,3351],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":117,"column":1,"nodeType":null,"messageId":"insert","endLine":117,"endColumn":1,"fix":{"range":[3380,3380],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":118,"column":1,"nodeType":null,"messageId":"replace","endLine":118,"endColumn":7,"fix":{"range":[3417,3423],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":119,"column":7,"nodeType":null,"messageId":"insert","endLine":119,"endColumn":7,"fix":{"range":[3458,3458],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":120,"column":1,"nodeType":null,"messageId":"insert","endLine":120,"endColumn":1,"fix":{"range":[3485,3485],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":121,"column":9,"nodeType":null,"messageId":"insert","endLine":121,"endColumn":9,"fix":{"range":[3509,3509],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":122,"column":7,"nodeType":null,"messageId":"insert","endLine":122,"endColumn":7,"fix":{"range":[3551,3551],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":123,"column":1,"nodeType":null,"messageId":"replace","endLine":123,"endColumn":7,"fix":{"range":[3555,3561],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":124,"column":7,"nodeType":null,"messageId":"insert","endLine":124,"endColumn":7,"fix":{"range":[3591,3591],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····})` with `······})⏎····`","line":125,"column":1,"nodeType":null,"messageId":"replace","endLine":125,"endColumn":7,"fix":{"range":[3614,3620],"text":"      })\n    "}}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":15,"fixableWarningCount":0,"source":"﻿/**\n * RAG摄取Worker - BullMQ队列处理\n * 艹，这个憨批Worker负责解析→切块→嵌入→入库全链路！\n */\n\nimport { Queue, Worker, Job, QueueEvents } from 'bullmq';\nimport { Redis as IORedis } from 'ioredis';\nimport { redisConfig } from '../../config/redis.js';\nimport db from '../../db/index.js';\nimport logger from '../../utils/logger.js';\nimport { parser } from './parser.js';\nimport { chunker, type Chunk } from './chunker.js';\nimport { aiGateway } from '../../services/ai-gateway.service.js';\n\nconst QUEUE_NAME = 'kb-ingest';\nconst JOB_NAME = 'kb-ingest.process';\n\nconst createConnection = () => {\n  interface RedisConfigExtended {\n    host?: string;\n    port?: string | number;\n    password?: string;\n    db?: string | number;\n    maxRetriesPerRequest?: number;\n  }\n\n  return new IORedis({\n    host: redisConfig.host,\n    port: Number(redisConfig.port ?? 6379),\n    password: redisConfig.password,\n    db: Number(redisConfig.db ?? 3),\n    maxRetriesPerRequest: (redisConfig as unknown as RedisConfigExtended).maxRetriesPerRequest ?? 3\n  });\n};\n\nconst ingestQueue = new Queue<IngestJobData>(QUEUE_NAME, {\n  connection: createConnection(),\n  defaultJobOptions: {\n    attempts: 3,\n    backoff: {\n      type: 'exponential',\n      delay: 2000\n    },\n    removeOnComplete: true,\n    removeOnFail: false\n  }\n});\n\nconst ingestEvents = new QueueEvents(QUEUE_NAME, { connection: createConnection() });\ningestEvents.on('completed', ({ jobId }) => {\n  logger.info(`[IngestWorker] 队列任务完成 jobId=${jobId}`);\n});\ningestEvents.on('failed', ({ jobId, failedReason }) => {\n  logger.error(`[IngestWorker] 队列任务失败 jobId=${jobId}`, { failedReason });\n});\n\ntype JobProcessor = Job<IngestJobData>;\n\nconst ingestWorker = new Worker<IngestJobData>(QUEUE_NAME, async (job) => processIngestJob(job), {\n  connection: createConnection(),\n  concurrency: 5\n});\n\ningestWorker.on('error', (error) => {\n  logger.error('[IngestWorker] Worker 运行失败', error);\n});\n\n/**\n * 摄取任务数据\n */\nexport interface IngestJobData {\n  documentId: string;\n  userId: string;\n  content: string;\n  format: 'markdown' | 'html' | 'pdf' | 'text';\n  kbId?: string;\n  options?: {\n    chunkSize?: number;\n    overlap?: number;\n  };\n}\n\nasync function processIngestJob(job: JobProcessor) {\n  const { documentId, userId, content, format, options = {} } = job.data;\n\n  try {\n    logger.info(`[IngestWorker] 开始处理文档: documentId=${documentId}`);\n    await job.updateProgress(5);\n\n    await db('kb_documents').where('id', documentId).update({\n      status: 'processing',\n      updated_at: new Date()\n    });\n\n    await job.updateProgress(20);\n    const normalizedFormat: 'markdown' | 'html' | 'pdf' =\n      format === 'html' || format === 'pdf' ? format : 'markdown';\n    const parseResult = await parser.parse(content, normalizedFormat);\n    logger.info(\n      `[IngestWorker] 解析完成: documentId=${documentId} length=${parseResult.metadata.length}`\n    );\n\n    await job.updateProgress(40);\n    const chunks = chunker.chunk(parseResult.text, {\n      chunkSize: options.chunkSize,\n      overlap: options.overlap\n    });\n    logger.info(`[IngestWorker] 切块完成: documentId=${documentId} chunks=${chunks.length}`);\n\n    await job.updateProgress(60);\n    const chunkRecords = chunks.map((chunk: Chunk): Record<string, unknown> => ({\n      document_id: documentId,\n      chunk_index: chunk.index,\n      text: chunk.text,\n      start_pos: chunk.metadata.start,\n      end_pos: chunk.metadata.end,\n      length: chunk.metadata.length,\n      embedding_status: 'pending',\n      metadata: JSON.stringify({\n        format,\n        parseMetadata: parseResult.metadata\n      }),\n      created_at: new Date(),\n      updated_at: new Date()\n    }));\n\n    await db('kb_chunks').insert(chunkRecords);\n\n    await job.updateProgress(80);\n    await scheduleEmbedding(documentId, chunks);\n\n    await job.updateProgress(100);\n    await db('kb_documents').where('id', documentId).update({\n      status: 'completed',\n      chunk_count: chunks.length,\n      updated_at: new Date()\n    });\n\n    logger.info(`[IngestWorker] 处理完成: documentId=${documentId} chunks=${chunks.length}`);\n\n    return {\n      success: true,\n      documentId,\n      chunkCount: chunks.length\n    };\n  } catch (error: unknown) {\n    const err = error instanceof Error ? error : new Error(String(error));\n    logger.error(`[IngestWorker] 处理失败: documentId=${documentId}`, err);\n\n    await db('kb_documents').where('id', documentId).update({\n      status: 'failed',\n      error_message: err.message,\n      updated_at: new Date()\n    });\n\n    throw error;\n  }\n}\n\nasync function scheduleEmbedding(documentId: string, chunks: Chunk[]): Promise<void> {\n  logger.info(`[IngestWorker] 调度向量化: documentId=${documentId} chunks=${chunks.length}`);\n\n  interface AiGatewayWithEmbed {\n    embed?: (data: unknown) => unknown;\n  }\n\n  if (aiGateway && typeof (aiGateway as unknown as AiGatewayWithEmbed).embed === 'function') {\n    logger.debug('[IngestWorker] aiGateway embed 能力已注册，等待后续实现');\n  }\n}\n\nexport async function addIngestJob(data: IngestJobData): Promise<void> {\n  await ingestQueue.add(JOB_NAME, data, {\n    jobId: data.documentId,\n    removeOnComplete: true,\n    attempts: 3\n  });\n\n  logger.info(`[IngestWorker] 添加摄取任务: documentId=${data.documentId}`);\n}\n\nexport async function getQueueStats(): Promise<{\n  queue: string;\n  counts: {\n    waiting: number;\n    active: number;\n    completed: number;\n    failed: number;\n  };\n  timestamp: string;\n}> {\n  const [waiting, active, completed, failed] = await Promise.all([\n    ingestQueue.getWaitingCount(),\n    ingestQueue.getActiveCount(),\n    ingestQueue.getCompletedCount(),\n    ingestQueue.getFailedCount()\n  ]);\n\n  return {\n    queue: QUEUE_NAME,\n    counts: { waiting, active, completed, failed },\n    timestamp: new Date().toISOString()\n  };\n}\n\nexport async function shutdownIngestQueue(): Promise<void> {\n  await Promise.allSettled([ingestWorker.close(), ingestEvents.close(), ingestQueue.close()]);\n}\n\nexport default ingestQueue;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/announcements.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/auditLogs.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/banners.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/contentTexts.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/membershipBenefits.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/membershipPlans.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/providerEndpoints.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/repositories/users.repo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/account.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/kb.route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/mcp-endpoints.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/prompt-templates.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/providers.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/security.routes.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········?·maskedResult.test⏎·········` with `·?·maskedResult.test`","line":565,"column":46,"nodeType":null,"messageId":"replace","endLine":567,"endColumn":10,"fix":{"range":[13260,13300],"text":" ? maskedResult.test"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import express, { Request, Response, NextFunction } from 'express';\nimport rateLimit from 'express-rate-limit';\nimport * as securityService from '../../services/security.service.js';\nimport { authenticate as authenticateToken } from '../../middlewares/auth.middleware.js';\nimport { requireAdmin } from '../../middlewares/adminAuth.middleware.js';\nimport { requirePermission } from '../../middlewares/require-permission.middleware.js';\nimport { body, param, query } from 'express-validator';\nimport { validate } from '../../middlewares/validate.middleware.js';\nimport logger from '../../utils/logger.js';\n\nconst router = express.Router();\n\n// 频率限制\nconst securityRateLimit = rateLimit({\n  windowMs: 60 * 1000, // 1分钟\n  max: 30, // 最多30次请求\n  message: {\n    success: false,\n    error: {\n      code: 4290,\n      message: '请求过于频繁，请稍后再试'\n    }\n  }\n});\n\n// 验证规则\nconst rateLimitConfigValidation = [\n  body('windowMs')\n    .isInt({ min: 1000, max: 3600000 })\n    .withMessage('时间窗口必须是1000-3600000毫秒之间'),\n  body('maxRequests').isInt({ min: 1, max: 10000 }).withMessage('最大请求数必须是1-10000之间'),\n  body('key')\n    .notEmpty()\n    .withMessage('限流键不能为空')\n    .isLength({ max: 100 })\n    .withMessage('限流键最多100个字符')\n];\n\nconst dataMaskingValidation = [\n  body('data').notEmpty().withMessage('数据不能为空'),\n  body('rules').isArray({ min: 1 }).withMessage('脱敏规则不能为空'),\n  body('rules.*.field').notEmpty().withMessage('字段名不能为空'),\n  body('rules.*.type')\n    .isIn(['email', 'phone', 'id_card', 'bank_card', 'password', 'token', 'custom'])\n    .withMessage('无效的脱敏类型')\n];\n\nconst auditLogValidation = [\n  query('type')\n    .optional()\n    .isIn(['rate_limit', 'data_access', 'auth_attempt', 'permission_denied', 'suspicious_activity'])\n    .withMessage('无效的日志类型'),\n  query('severity')\n    .optional()\n    .isIn(['low', 'medium', 'high', 'critical'])\n    .withMessage('无效的严重级别'),\n  query('page').optional().isInt({ min: 1, max: 1000 }).withMessage('页码必须是1-1000之间的整数'),\n  query('limit').optional().isInt({ min: 1, max: 200 }).withMessage('每页数量必须是1-200之间的整数')\n];\n\nconst suspiciousActivityValidation = [\n  body('ip').notEmpty().withMessage('IP地址不能为空').isIP().withMessage('无效的IP地址'),\n  body('timeWindowMs')\n    .optional()\n    .isInt({ min: 60000, max: 3600000 })\n    .withMessage('时间窗口必须是60000-3600000毫秒之间')\n];\n\n/**\n * 安全防护路由\n *\n * 提供限流、数据脱敏、健康检查等安全防护功能\n */\n\n// 应用认证中间件\nrouter.use(authenticateToken);\nrouter.use(securityRateLimit);\n\n// 应用权限中间件\nrouter.use(\n  requirePermission({\n    resource: 'security',\n    actions: ['read']\n  })\n);\n\n/**\n * 获取安全统计信息\n * GET /api/admin/security/stats\n */\nrouter.get('/stats', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const stats = await securityService.getSecurityStats();\n\n    res.json({\n      success: true,\n      data: stats,\n      requestId: req.id\n    });\n  } catch (error) {\n    logger.error('获取安全统计失败:', error);\n    next(error);\n  }\n});\n\n/**\n * 执行健康检查\n * GET /api/admin/security/health\n */\nrouter.get('/health', async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const healthResult = await securityService.performHealthChecks();\n\n    res\n      .status(\n        healthResult.overall === 'healthy' ? 200 : healthResult.overall === 'warning' ? 200 : 503\n      )\n      .json({\n        success: healthResult.overall !== 'unhealthy',\n        data: healthResult,\n        requestId: req.id\n      });\n  } catch (error) {\n    logger.error('健康检查失败:', error);\n    next(error);\n  }\n});\n\n/**\n * 获取安全审计日志\n * GET /api/admin/security/audit-logs\n */\nrouter.get(\n  '/audit-logs',\n  auditLogValidation,\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const {\n        type,\n        severity,\n        userId,\n        ip,\n        startDate,\n        endDate,\n        page = '1',\n        limit = '50'\n      } = req.query;\n\n      type AuditLogFilters = {\n        page: number;\n        limit: number;\n        type?: string;\n        severity?: string;\n        userId?: string;\n        ip?: string;\n        startDate?: Date;\n        endDate?: Date;\n      };\n      const filters: AuditLogFilters = {\n        page: parseInt(page as string),\n        limit: parseInt(limit as string)\n      };\n\n      if (type) filters.type = type as string;\n      if (severity) filters.severity = severity as string;\n      if (userId) filters.userId = userId as string;\n      if (ip) filters.ip = ip as string;\n      if (startDate) filters.startDate = new Date(startDate as string);\n      if (endDate) filters.endDate = new Date(endDate as string);\n\n      const result = await securityService.getAuditLogs(filters);\n\n      res.json({\n        success: true,\n        data: result,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('获取安全审计日志失败:', error);\n      next(error);\n    }\n  }\n);\n\n// ============ 需要管理权限的路由 ============\nrouter.use(\n  requirePermission({\n    resource: 'security',\n    actions: ['manage', 'test']\n  })\n);\n\n/**\n * 检查频率限制\n * POST /api/admin/security/rate-limit/check\n */\nrouter.post(\n  '/rate-limit/check',\n  requirePermission({\n    resource: 'security',\n    actions: ['manage']\n  }),\n  rateLimitConfigValidation,\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { windowMs, maxRequests, key } = req.body;\n\n      const result = await securityService.checkRateLimit(key, {\n        windowMs,\n        maxRequests,\n        message: '请求过于频繁，请稍后再试'\n      });\n\n      logger.info('频率限制检查', {\n        key,\n        allowed: result.allowed,\n        remaining: result.remaining,\n        checkedBy: req.user?.id,\n        ip: req.ip\n      });\n\n      res.json({\n        success: true,\n        data: result,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('检查频率限制失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 重置频率限制\n * DELETE /api/admin/security/rate-limit/:key\n */\nrouter.delete(\n  '/rate-limit/:key',\n  requirePermission({\n    resource: 'security',\n    actions: ['manage']\n  }),\n  param('key').notEmpty().withMessage('限流键不能为空'),\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { key } = req.params;\n\n      const success = await securityService.resetRateLimit(key);\n\n      logger.info('频率限制重置', {\n        key,\n        success,\n        resetBy: req.user?.id,\n        ip: req.ip\n      });\n\n      res.json({\n        success,\n        message: success ? '频率限制重置成功' : '频率限制重置失败',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('重置频率限制失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 数据脱敏测试\n * POST /api/admin/security/data-masking\n */\nrouter.post(\n  '/data-masking',\n  requirePermission({\n    resource: 'security',\n    actions: ['test']\n  }),\n  dataMaskingValidation,\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { data, rules } = req.body;\n\n      const maskedData = securityService.maskData(data, rules);\n\n      logger.info('数据脱敏测试', {\n        rulesCount: rules.length,\n        fieldsCount: Object.keys(data).length,\n        testedBy: req.user?.id,\n        ip: req.ip\n      });\n\n      res.json({\n        success: true,\n        data: {\n          original: data,\n          masked: maskedData,\n          rules\n        },\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('数据脱敏测试失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 检测可疑活动\n * POST /api/admin/security/suspicious-activity/detect\n */\nrouter.post(\n  '/suspicious-activity/detect',\n  requirePermission({\n    resource: 'security',\n    actions: ['manage']\n  }),\n  suspiciousActivityValidation,\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { ip, timeWindowMs = 300000 } = req.body;\n\n      const result = await securityService.detectSuspiciousActivity(ip, timeWindowMs);\n\n      logger.info('可疑活动检测', {\n        targetIp: ip,\n        suspicious: result.suspicious,\n        riskScore: result.riskScore,\n        reasonsCount: result.reasons.length,\n        detectedBy: req.user?.id,\n        requestIp: req.ip\n      });\n\n      res.json({\n        success: true,\n        data: result,\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('检测可疑活动失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 手动记录安全事件\n * POST /api/admin/security/audit-logs\n */\nrouter.post(\n  '/audit-logs',\n  requirePermission({\n    resource: 'security',\n    actions: ['manage']\n  }),\n  body('type')\n    .isIn(['rate_limit', 'data_access', 'auth_attempt', 'permission_denied', 'suspicious_activity'])\n    .withMessage('无效的日志类型'),\n  body('severity').isIn(['low', 'medium', 'high', 'critical']).withMessage('无效的严重级别'),\n  body('ip').notEmpty().withMessage('IP地址不能为空').isIP().withMessage('无效的IP地址'),\n  body('endpoint').notEmpty().withMessage('端点不能为空'),\n  body('method').isIn(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).withMessage('无效的HTTP方法'),\n  body('details').optional().isObject().withMessage('详情必须是对象'),\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { type, severity, userId, ip, userAgent, endpoint, method, details = {} } = req.body;\n\n      await securityService.logSecurityEvent({\n        type,\n        severity,\n        // 使用请求中的值或从req中获取\n        userId: userId || req.user?.id,\n        ip: ip || req.ip,\n        userAgent: userAgent || req.get('User-Agent'),\n        endpoint: endpoint || req.path,\n        method: method || req.method,\n        details\n      });\n\n      logger.info('安全事件记录', {\n        type,\n        severity,\n        ip: ip || req.ip,\n        endpoint: endpoint || req.path,\n        method: method || req.method,\n        loggedBy: req.user?.id,\n        requestIp: req.ip\n      });\n\n      res.status(201).json({\n        success: true,\n        message: '安全事件记录成功',\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('记录安全事件失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 获取脱敏规则示例\n * GET /api/admin/security/masking-rules/examples\n */\nrouter.get(\n  '/masking-rules/examples',\n  requirePermission({\n    resource: 'security',\n    actions: ['read']\n  }),\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const examples = [\n        {\n          field: 'email',\n          type: 'email',\n          description: '邮箱地址脱敏'\n        },\n        {\n          field: 'phone',\n          type: 'phone',\n          description: '手机号脱敏'\n        },\n        {\n          field: 'idCard',\n          type: 'id_card',\n          description: '身份证号脱敏'\n        },\n        {\n          field: 'bankCard',\n          type: 'bank_card',\n          description: '银行卡号脱敏'\n        },\n        {\n          field: 'password',\n          type: 'password',\n          description: '密码脱敏'\n        },\n        {\n          field: 'token',\n          type: 'token',\n          description: 'Token脱敏'\n        },\n        {\n          field: 'customField',\n          type: 'custom',\n          customPattern: '\\\\d{4}',\n          replacement: '****',\n          description: '自定义脱敏规则'\n        }\n      ];\n\n      res.json({\n        success: true,\n        data: { examples },\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('获取脱敏规则示例失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 获取限流配置示例\n * GET /api/admin/security/rate-limit/examples\n */\nrouter.get(\n  '/rate-limit/examples',\n  requirePermission({\n    resource: 'security',\n    actions: ['read']\n  }),\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const examples = [\n        {\n          name: '严格限制',\n          config: {\n            windowMs: 60000,\n            maxRequests: 10,\n            key: 'strict_limit'\n          },\n          description: '每分钟最多10次请求'\n        },\n        {\n          name: '中等限制',\n          config: {\n            windowMs: 60000,\n            maxRequests: 100,\n            key: 'medium_limit'\n          },\n          description: '每分钟最多100次请求'\n        },\n        {\n          name: '宽松限制',\n          config: {\n            windowMs: 60000,\n            maxRequests: 1000,\n            key: 'loose_limit'\n          },\n          description: '每分钟最多1000次请求'\n        },\n        {\n          name: '小时限制',\n          config: {\n            windowMs: 3600000,\n            maxRequests: 5000,\n            key: 'hourly_limit'\n          },\n          description: '每小时最多5000次请求'\n        }\n      ];\n\n      res.json({\n        success: true,\n        data: { examples },\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('获取限流配置示例失败:', error);\n      next(error);\n    }\n  }\n);\n\n/**\n * 测试数据脱敏\n * POST /api/admin/security/masking-test\n */\nrouter.post(\n  '/masking-test',\n  requirePermission({\n    resource: 'security',\n    actions: ['test']\n  }),\n  body('testType')\n    .isIn(['email', 'phone', 'id_card', 'bank_card', 'password', 'token', 'custom'])\n    .withMessage('无效的测试类型'),\n  body('value').notEmpty().withMessage('测试值不能为空'),\n  validate,\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const { testType, value } = req.body;\n\n      const rule = {\n        field: 'test',\n        type: testType\n      };\n\n      const maskedResult = securityService.maskData({ test: value }, [rule]) as {\n        test?: unknown;\n      };\n      const maskedValue =\n        typeof maskedResult.test === 'string'\n          ? maskedResult.test\n          : String(maskedResult.test ?? '');\n\n      logger.info('数据脱敏测试', {\n        testType,\n        originalLength: value.length,\n        maskedLength: maskedValue.length,\n        testedBy: req.user?.id,\n        ip: req.ip\n      });\n\n      res.json({\n        success: true,\n        data: {\n          original: value,\n          masked: maskedValue,\n          type: testType\n        },\n        requestId: req.id\n      });\n    } catch (error) {\n      logger.error('测试数据脱敏失败:', error);\n      next(error);\n    }\n  }\n);\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/admin/uploads.route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/ai.route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/announcements.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/asset.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/auditLogs.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/auth.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/banners.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/buildingai-adaptor.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/cache.routes.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/stats',·authenticate,·requireRole('admin'),` with `⏎··'/stats',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":12,"column":12,"nodeType":null,"messageId":"replace","endLine":12,"endColumn":57,"fix":{"range":[418,463],"text":"\n  '/stats',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":13,"column":3,"nodeType":null,"messageId":"insert","endLine":13,"endColumn":3,"fix":{"range":[528,528],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":14,"column":1,"nodeType":null,"messageId":"insert","endLine":14,"endColumn":1,"fix":{"range":[534,534],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":15,"column":1,"nodeType":null,"messageId":"replace","endLine":15,"endColumn":5,"fix":{"range":[577,581],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":16,"column":5,"nodeType":null,"messageId":"insert","endLine":16,"endColumn":5,"fix":{"range":[646,646],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":17,"column":1,"nodeType":null,"messageId":"insert","endLine":17,"endColumn":1,"fix":{"range":[657,657],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":18,"column":1,"nodeType":null,"messageId":"insert","endLine":18,"endColumn":1,"fix":{"range":[678,678],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":19,"column":5,"nodeType":null,"messageId":"insert","endLine":19,"endColumn":5,"fix":{"range":[778,778],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":20,"column":1,"nodeType":null,"messageId":"insert","endLine":20,"endColumn":1,"fix":{"range":[782,782],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":21,"column":1,"nodeType":null,"messageId":"insert","endLine":21,"endColumn":1,"fix":{"range":[811,811],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":22,"column":1,"nodeType":null,"messageId":"replace","endLine":22,"endColumn":5,"fix":{"range":[862,866],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":23,"column":3,"nodeType":null,"messageId":"insert","endLine":23,"endColumn":3,"fix":{"range":[881,881],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":24,"column":1,"nodeType":null,"messageId":"replace","endLine":24,"endColumn":2,"fix":{"range":[883,884],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/health',·authenticate,·requireRole('admin'),` with `⏎··'/health',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":27,"column":12,"nodeType":null,"messageId":"replace","endLine":27,"endColumn":58,"fix":{"range":[909,955],"text":"\n  '/health',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":28,"column":3,"nodeType":null,"messageId":"insert","endLine":28,"endColumn":3,"fix":{"range":[1020,1020],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":29,"column":1,"nodeType":null,"messageId":"replace","endLine":29,"endColumn":5,"fix":{"range":[1026,1030],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":30,"column":1,"nodeType":null,"messageId":"insert","endLine":30,"endColumn":1,"fix":{"range":[1079,1079],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":31,"column":3,"nodeType":null,"messageId":"insert","endLine":31,"endColumn":3,"fix":{"range":[1128,1128],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":32,"column":1,"nodeType":null,"messageId":"insert","endLine":32,"endColumn":1,"fix":{"range":[1155,1155],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":33,"column":1,"nodeType":null,"messageId":"insert","endLine":33,"endColumn":1,"fix":{"range":[1206,1206],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":34,"column":3,"nodeType":null,"messageId":"insert","endLine":34,"endColumn":3,"fix":{"range":[1225,1225],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":35,"column":1,"nodeType":null,"messageId":"replace","endLine":35,"endColumn":2,"fix":{"range":[1227,1228],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/invalidate',·authenticate,·requireRole('admin'),` with `⏎··'/invalidate',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":38,"column":13,"nodeType":null,"messageId":"replace","endLine":38,"endColumn":63,"fix":{"range":[1254,1304],"text":"\n  '/invalidate',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":39,"column":3,"nodeType":null,"messageId":"insert","endLine":39,"endColumn":3,"fix":{"range":[1368,1368],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":40,"column":1,"nodeType":null,"messageId":"insert","endLine":40,"endColumn":1,"fix":{"range":[1374,1374],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":41,"column":7,"nodeType":null,"messageId":"insert","endLine":41,"endColumn":7,"fix":{"range":[1445,1445],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":42,"column":1,"nodeType":null,"messageId":"replace","endLine":42,"endColumn":7,"fix":{"range":[1465,1471],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":43,"column":7,"nodeType":null,"messageId":"insert","endLine":43,"endColumn":7,"fix":{"range":[1495,1495],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":44,"column":1,"nodeType":null,"messageId":"replace","endLine":44,"endColumn":5,"fix":{"range":[1512,1516],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":45,"column":1,"nodeType":null,"messageId":"insert","endLine":45,"endColumn":1,"fix":{"range":[1519,1519],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `res.status(400)` with `··res⏎··········.status(400)⏎··········`","line":46,"column":7,"nodeType":null,"messageId":"replace","endLine":46,"endColumn":22,"fix":{"range":[1547,1562],"text":"  res\n          .status(400)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":47,"column":7,"nodeType":null,"messageId":"insert","endLine":47,"endColumn":7,"fix":{"range":[1639,1639],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":48,"column":1,"nodeType":null,"messageId":"replace","endLine":48,"endColumn":5,"fix":{"range":[1647,1651],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":49,"column":1,"nodeType":null,"messageId":"insert","endLine":49,"endColumn":1,"fix":{"range":[1653,1653],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":50,"column":7,"nodeType":null,"messageId":"insert","endLine":50,"endColumn":7,"fix":{"range":[1709,1709],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":51,"column":1,"nodeType":null,"messageId":"insert","endLine":51,"endColumn":1,"fix":{"range":[1720,1720],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":52,"column":7,"nodeType":null,"messageId":"insert","endLine":52,"endColumn":7,"fix":{"range":[1748,1748],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":53,"column":5,"nodeType":null,"messageId":"insert","endLine":53,"endColumn":5,"fix":{"range":[1777,1777],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":54,"column":1,"nodeType":null,"messageId":"insert","endLine":54,"endColumn":1,"fix":{"range":[1780,1780],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":55,"column":1,"nodeType":null,"messageId":"replace","endLine":55,"endColumn":7,"fix":{"range":[1795,1801],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":56,"column":1,"nodeType":null,"messageId":"insert","endLine":56,"endColumn":1,"fix":{"range":[1816,1816],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":57,"column":1,"nodeType":null,"messageId":"insert","endLine":57,"endColumn":1,"fix":{"range":[1844,1844],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":58,"column":1,"nodeType":null,"messageId":"insert","endLine":58,"endColumn":1,"fix":{"range":[1929,1929],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":59,"column":3,"nodeType":null,"messageId":"insert","endLine":59,"endColumn":3,"fix":{"range":[1939,1939],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":60,"column":1,"nodeType":null,"messageId":"insert","endLine":60,"endColumn":1,"fix":{"range":[1966,1966],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":61,"column":5,"nodeType":null,"messageId":"insert","endLine":61,"endColumn":5,"fix":{"range":[2019,2019],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":62,"column":1,"nodeType":null,"messageId":"replace","endLine":62,"endColumn":3,"fix":{"range":[2032,2034],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":63,"column":1,"nodeType":null,"messageId":"replace","endLine":63,"endColumn":2,"fix":{"range":[2036,2037],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/version/update',·authenticate,·requireRole('admin'),` with `⏎··'/version/update',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":66,"column":13,"nodeType":null,"messageId":"replace","endLine":66,"endColumn":67,"fix":{"range":[2061,2115],"text":"\n  '/version/update',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":67,"column":1,"nodeType":null,"messageId":"replace","endLine":67,"endColumn":3,"fix":{"range":[2177,2179],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":68,"column":1,"nodeType":null,"messageId":"insert","endLine":68,"endColumn":1,"fix":{"range":[2185,2185],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":69,"column":5,"nodeType":null,"messageId":"insert","endLine":69,"endColumn":5,"fix":{"range":[2259,2259],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `res.status(400)` with `··res⏎··········.status(400)⏎··········`","line":70,"column":7,"nodeType":null,"messageId":"replace","endLine":70,"endColumn":22,"fix":{"range":[2283,2298],"text":"  res\n          .status(400)\n          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":71,"column":7,"nodeType":null,"messageId":"insert","endLine":71,"endColumn":7,"fix":{"range":[2375,2375],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":72,"column":5,"nodeType":null,"messageId":"insert","endLine":72,"endColumn":5,"fix":{"range":[2387,2387],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":73,"column":1,"nodeType":null,"messageId":"replace","endLine":73,"endColumn":5,"fix":{"range":[2389,2393],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":74,"column":1,"nodeType":null,"messageId":"insert","endLine":74,"endColumn":1,"fix":{"range":[2467,2467],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":75,"column":1,"nodeType":null,"messageId":"replace","endLine":75,"endColumn":3,"fix":{"range":[2552,2554],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":76,"column":1,"nodeType":null,"messageId":"insert","endLine":76,"endColumn":1,"fix":{"range":[2581,2581],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":77,"column":5,"nodeType":null,"messageId":"insert","endLine":77,"endColumn":5,"fix":{"range":[2634,2634],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":78,"column":3,"nodeType":null,"messageId":"insert","endLine":78,"endColumn":3,"fix":{"range":[2649,2649],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":79,"column":1,"nodeType":null,"messageId":"replace","endLine":79,"endColumn":2,"fix":{"range":[2651,2652],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/preload',·authenticate,·requireRole('admin'),` with `⏎··'/preload',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":82,"column":13,"nodeType":null,"messageId":"replace","endLine":82,"endColumn":60,"fix":{"range":[2676,2723],"text":"\n  '/preload',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":83,"column":3,"nodeType":null,"messageId":"insert","endLine":83,"endColumn":3,"fix":{"range":[2787,2787],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":84,"column":1,"nodeType":null,"messageId":"insert","endLine":84,"endColumn":1,"fix":{"range":[2793,2793],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":85,"column":1,"nodeType":null,"messageId":"replace","endLine":85,"endColumn":7,"fix":{"range":[2826,2832],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":86,"column":1,"nodeType":null,"messageId":"insert","endLine":86,"endColumn":1,"fix":{"range":[2845,2845],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":87,"column":7,"nodeType":null,"messageId":"insert","endLine":87,"endColumn":7,"fix":{"range":[2873,2873],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":88,"column":1,"nodeType":null,"messageId":"replace","endLine":88,"endColumn":5,"fix":{"range":[2886,2890],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":90,"column":1,"nodeType":null,"messageId":"insert","endLine":90,"endColumn":1,"fix":{"range":[2893,2893],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":91,"column":1,"nodeType":null,"messageId":"replace","endLine":91,"endColumn":7,"fix":{"range":[2905,2911],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":92,"column":1,"nodeType":null,"messageId":"insert","endLine":92,"endColumn":1,"fix":{"range":[2922,2922],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":93,"column":7,"nodeType":null,"messageId":"insert","endLine":93,"endColumn":7,"fix":{"range":[2941,2941],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":94,"column":1,"nodeType":null,"messageId":"insert","endLine":94,"endColumn":1,"fix":{"range":[2961,2961],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":95,"column":7,"nodeType":null,"messageId":"insert","endLine":95,"endColumn":7,"fix":{"range":[2997,2997],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":96,"column":1,"nodeType":null,"messageId":"replace","endLine":96,"endColumn":7,"fix":{"range":[3017,3023],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":97,"column":7,"nodeType":null,"messageId":"insert","endLine":97,"endColumn":7,"fix":{"range":[3057,3057],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":98,"column":5,"nodeType":null,"messageId":"insert","endLine":98,"endColumn":5,"fix":{"range":[3080,3080],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":99,"column":1,"nodeType":null,"messageId":"insert","endLine":99,"endColumn":1,"fix":{"range":[3083,3083],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":100,"column":7,"nodeType":null,"messageId":"insert","endLine":100,"endColumn":7,"fix":{"range":[3136,3136],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":101,"column":1,"nodeType":null,"messageId":"insert","endLine":101,"endColumn":1,"fix":{"range":[3140,3140],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":102,"column":1,"nodeType":null,"messageId":"insert","endLine":102,"endColumn":1,"fix":{"range":[3161,3161],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":103,"column":1,"nodeType":null,"messageId":"replace","endLine":103,"endColumn":7,"fix":{"range":[3245,3251],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":104,"column":5,"nodeType":null,"messageId":"insert","endLine":104,"endColumn":5,"fix":{"range":[3263,3263],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":105,"column":1,"nodeType":null,"messageId":"insert","endLine":105,"endColumn":1,"fix":{"range":[3265,3265],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":106,"column":1,"nodeType":null,"messageId":"insert","endLine":106,"endColumn":1,"fix":{"range":[3302,3302],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":107,"column":5,"nodeType":null,"messageId":"insert","endLine":107,"endColumn":5,"fix":{"range":[3399,3399],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":108,"column":1,"nodeType":null,"messageId":"insert","endLine":108,"endColumn":1,"fix":{"range":[3402,3402],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":109,"column":7,"nodeType":null,"messageId":"insert","endLine":109,"endColumn":7,"fix":{"range":[3443,3443],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":110,"column":1,"nodeType":null,"messageId":"replace","endLine":110,"endColumn":9,"fix":{"range":[3447,3455],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":111,"column":1,"nodeType":null,"messageId":"insert","endLine":111,"endColumn":1,"fix":{"range":[3468,3468],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":112,"column":7,"nodeType":null,"messageId":"insert","endLine":112,"endColumn":7,"fix":{"range":[3554,3554],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":113,"column":1,"nodeType":null,"messageId":"insert","endLine":113,"endColumn":1,"fix":{"range":[3562,3562],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":114,"column":5,"nodeType":null,"messageId":"insert","endLine":114,"endColumn":5,"fix":{"range":[3572,3572],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":115,"column":1,"nodeType":null,"messageId":"insert","endLine":115,"endColumn":1,"fix":{"range":[3621,3621],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":116,"column":1,"nodeType":null,"messageId":"insert","endLine":116,"endColumn":1,"fix":{"range":[3697,3697],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":117,"column":5,"nodeType":null,"messageId":"insert","endLine":117,"endColumn":5,"fix":{"range":[3793,3793],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":118,"column":1,"nodeType":null,"messageId":"insert","endLine":118,"endColumn":1,"fix":{"range":[3804,3804],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":119,"column":7,"nodeType":null,"messageId":"insert","endLine":119,"endColumn":7,"fix":{"range":[3831,3831],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":120,"column":1,"nodeType":null,"messageId":"replace","endLine":120,"endColumn":7,"fix":{"range":[3853,3859],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":121,"column":5,"nodeType":null,"messageId":"insert","endLine":121,"endColumn":5,"fix":{"range":[3943,3943],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":122,"column":1,"nodeType":null,"messageId":"insert","endLine":122,"endColumn":1,"fix":{"range":[3947,3947],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":123,"column":1,"nodeType":null,"messageId":"insert","endLine":123,"endColumn":1,"fix":{"range":[3976,3976],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":124,"column":5,"nodeType":null,"messageId":"insert","endLine":124,"endColumn":5,"fix":{"range":[4029,4029],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":125,"column":3,"nodeType":null,"messageId":"insert","endLine":125,"endColumn":3,"fix":{"range":[4044,4044],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":126,"column":1,"nodeType":null,"messageId":"replace","endLine":126,"endColumn":2,"fix":{"range":[4046,4047],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/batch',·authenticate,·requireRole('admin'),` with `⏎··'/batch',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":129,"column":15,"nodeType":null,"messageId":"replace","endLine":129,"endColumn":60,"fix":{"range":[4075,4120],"text":"\n  '/batch',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":130,"column":1,"nodeType":null,"messageId":"insert","endLine":130,"endColumn":1,"fix":{"range":[4182,4182],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":131,"column":5,"nodeType":null,"messageId":"insert","endLine":131,"endColumn":5,"fix":{"range":[4194,4194],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":132,"column":1,"nodeType":null,"messageId":"replace","endLine":132,"endColumn":5,"fix":{"range":[4256,4260],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":133,"column":1,"nodeType":null,"messageId":"insert","endLine":133,"endColumn":1,"fix":{"range":[4276,4276],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":134,"column":7,"nodeType":null,"messageId":"insert","endLine":134,"endColumn":7,"fix":{"range":[4372,4372],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":135,"column":1,"nodeType":null,"messageId":"insert","endLine":135,"endColumn":1,"fix":{"range":[4380,4380],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":136,"column":5,"nodeType":null,"messageId":"insert","endLine":136,"endColumn":5,"fix":{"range":[4390,4390],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":137,"column":1,"nodeType":null,"messageId":"insert","endLine":137,"endColumn":1,"fix":{"range":[4453,4453],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":138,"column":3,"nodeType":null,"messageId":"insert","endLine":138,"endColumn":3,"fix":{"range":[4539,4539],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":139,"column":1,"nodeType":null,"messageId":"replace","endLine":139,"endColumn":5,"fix":{"range":[4566,4570],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":140,"column":5,"nodeType":null,"messageId":"insert","endLine":140,"endColumn":5,"fix":{"range":[4621,4621],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":141,"column":3,"nodeType":null,"messageId":"insert","endLine":141,"endColumn":3,"fix":{"range":[4636,4636],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":142,"column":1,"nodeType":null,"messageId":"replace","endLine":142,"endColumn":2,"fix":{"range":[4638,4639],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/stats/reset',·authenticate,·requireRole('admin'),` with `⏎··'/stats/reset',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":145,"column":13,"nodeType":null,"messageId":"replace","endLine":145,"endColumn":64,"fix":{"range":[4665,4716],"text":"\n  '/stats/reset',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":146,"column":3,"nodeType":null,"messageId":"insert","endLine":146,"endColumn":3,"fix":{"range":[4781,4781],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":147,"column":1,"nodeType":null,"messageId":"replace","endLine":147,"endColumn":5,"fix":{"range":[4787,4791],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":148,"column":1,"nodeType":null,"messageId":"insert","endLine":148,"endColumn":1,"fix":{"range":[4818,4818],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":149,"column":1,"nodeType":null,"messageId":"replace","endLine":149,"endColumn":3,"fix":{"range":[4871,4873],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":150,"column":1,"nodeType":null,"messageId":"insert","endLine":150,"endColumn":1,"fix":{"range":[4900,4900],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":151,"column":5,"nodeType":null,"messageId":"insert","endLine":151,"endColumn":5,"fix":{"range":[4955,4955],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":152,"column":3,"nodeType":null,"messageId":"insert","endLine":152,"endColumn":3,"fix":{"range":[4970,4970],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":153,"column":1,"nodeType":null,"messageId":"replace","endLine":153,"endColumn":2,"fix":{"range":[4972,4973],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/health/broadcast',·authenticate,·requireRole('admin'),` with `⏎··'/health/broadcast',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":156,"column":13,"nodeType":null,"messageId":"replace","endLine":156,"endColumn":69,"fix":{"range":[4999,5055],"text":"\n  '/health/broadcast',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":157,"column":1,"nodeType":null,"messageId":"insert","endLine":157,"endColumn":1,"fix":{"range":[5118,5118],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":158,"column":5,"nodeType":null,"messageId":"insert","endLine":158,"endColumn":5,"fix":{"range":[5130,5130],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":159,"column":1,"nodeType":null,"messageId":"replace","endLine":159,"endColumn":5,"fix":{"range":[5183,5187],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":160,"column":3,"nodeType":null,"messageId":"insert","endLine":160,"endColumn":3,"fix":{"range":[5240,5240],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":161,"column":1,"nodeType":null,"messageId":"replace","endLine":161,"endColumn":5,"fix":{"range":[5267,5271],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":162,"column":1,"nodeType":null,"messageId":"insert","endLine":162,"endColumn":1,"fix":{"range":[5318,5318],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":163,"column":3,"nodeType":null,"messageId":"insert","endLine":163,"endColumn":3,"fix":{"range":[5337,5337],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":164,"column":1,"nodeType":null,"messageId":"replace","endLine":164,"endColumn":2,"fix":{"range":[5339,5340],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/subscriber/status',·authenticate,·requireRole('admin'),` with `⏎··'/subscriber/status',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":167,"column":12,"nodeType":null,"messageId":"replace","endLine":167,"endColumn":69,"fix":{"range":[5367,5424],"text":"\n  '/subscriber/status',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":168,"column":3,"nodeType":null,"messageId":"insert","endLine":168,"endColumn":3,"fix":{"range":[5489,5489],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":169,"column":1,"nodeType":null,"messageId":"replace","endLine":169,"endColumn":5,"fix":{"range":[5495,5499],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":170,"column":1,"nodeType":null,"messageId":"insert","endLine":170,"endColumn":1,"fix":{"range":[5550,5550],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":171,"column":3,"nodeType":null,"messageId":"insert","endLine":171,"endColumn":3,"fix":{"range":[5599,5599],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":172,"column":1,"nodeType":null,"messageId":"insert","endLine":172,"endColumn":1,"fix":{"range":[5626,5626],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":173,"column":5,"nodeType":null,"messageId":"insert","endLine":173,"endColumn":5,"fix":{"range":[5683,5683],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":174,"column":1,"nodeType":null,"messageId":"replace","endLine":174,"endColumn":3,"fix":{"range":[5696,5698],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":175,"column":1,"nodeType":null,"messageId":"replace","endLine":175,"endColumn":2,"fix":{"range":[5700,5701],"text":"  }\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'/subscriber/restart',·authenticate,·requireRole('admin'),` with `⏎··'/subscriber/restart',⏎··authenticate,⏎··requireRole('admin'),⏎·`","line":178,"column":13,"nodeType":null,"messageId":"replace","endLine":178,"endColumn":71,"fix":{"range":[5727,5785],"text":"\n  '/subscriber/restart',\n  authenticate,\n  requireRole('admin'),\n "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··` with `····`","line":179,"column":1,"nodeType":null,"messageId":"replace","endLine":179,"endColumn":3,"fix":{"range":[5848,5850],"text":"    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":180,"column":1,"nodeType":null,"messageId":"insert","endLine":180,"endColumn":1,"fix":{"range":[5856,5856],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":181,"column":1,"nodeType":null,"messageId":"insert","endLine":181,"endColumn":1,"fix":{"range":[5897,5897],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":182,"column":1,"nodeType":null,"messageId":"insert","endLine":182,"endColumn":1,"fix":{"range":[5960,5960],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":183,"column":5,"nodeType":null,"messageId":"insert","endLine":183,"endColumn":5,"fix":{"range":[6006,6006],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":184,"column":1,"nodeType":null,"messageId":"insert","endLine":184,"endColumn":1,"fix":{"range":[6056,6056],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":185,"column":5,"nodeType":null,"messageId":"insert","endLine":185,"endColumn":5,"fix":{"range":[6089,6089],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":186,"column":1,"nodeType":null,"messageId":"replace","endLine":186,"endColumn":5,"fix":{"range":[6136,6140],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":187,"column":3,"nodeType":null,"messageId":"insert","endLine":187,"endColumn":3,"fix":{"range":[6155,6155],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎`","line":188,"column":1,"nodeType":null,"messageId":"replace","endLine":188,"endColumn":2,"fix":{"range":[6157,6158],"text":"  }\n"}}],"suppressedMessages":[],"errorCount":158,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":158,"fixableWarningCount":0,"source":"import { Router, type Request, type Response, type NextFunction } from 'express';\nimport cacheService from '../services/cache.service.js';\nimport cacheSubscriberService, {\n  type CachePreloadPriority\n} from '../services/cache-subscriber.service.js';\nimport { authenticate, requireRole } from '../middlewares/auth.middleware.js';\nimport logger from '../utils/logger.js';\n\nconst router = Router();\n\n// 获取缓存统计\nrouter.get('/stats', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    const stats = cacheService.getStats();\n    const subscriberStatus = cacheSubscriberService.getStatus();\n    res.json({\n      success: true,\n      data: { cache: stats, subscriber: subscriberStatus, timestamp: new Date().toISOString() }\n    });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 获取缓存统计失败', error);\n    next(error);\n  }\n});\n\n// 缓存健康检查\nrouter.get('/health', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    const health = await cacheService.healthCheck();\n    res.json({ success: true, data: health });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 缓存健康检查失败', error);\n    next(error);\n  }\n});\n\n// 手动失效缓存\nrouter.post('/invalidate', authenticate, requireRole('admin'), async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { namespace, pattern, reason } = (req.body ?? {}) as {\n      namespace?: string;\n      pattern?: string;\n      reason?: string;\n    };\n    if (!namespace) {\n      res.status(400).json({ success: false, error: { code: 4001, message: '缺少命名空间参数' } });\n      return;\n    }\n    await cacheSubscriberService.invalidateCache(\n      namespace,\n      pattern || '*',\n      reason || 'admin_manual'\n    );\n    res.json({\n      success: true,\n      message: '缓存失效请求已发送',\n      data: { namespace, pattern: pattern || '*', reason: reason || 'admin_manual' }\n    });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 缓存失效失败', error);\n    next(error);\n  }\n});\n\n// 版本更新\nrouter.post('/version/update', authenticate, requireRole('admin'), async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { namespace } = (req.body ?? {}) as { namespace?: string };\n    if (!namespace) {\n      res.status(400).json({ success: false, error: { code: 4001, message: '缺少命名空间参数' } });\n      return;\n    }\n    const newVersion = await cacheSubscriberService.updateVersion(namespace);\n    res.json({ success: true, message: '版本更新成功', data: { namespace, newVersion } });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 版本更新失败', error);\n    next(error);\n  }\n});\n\n// 缓存预热\nrouter.post('/preload', authenticate, requireRole('admin'), async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    interface CachePreloadItem {\n      key: string;\n      value: unknown;\n      ttl: number;\n    }\n\n    const {\n      namespace,\n      items,\n      priority = 'normal'\n    } = (req.body ?? {}) as {\n      namespace?: string;\n      items?: CachePreloadItem[];\n      priority?: string;\n    };\n    if (!namespace || !Array.isArray(items)) {\n      res\n        .status(400)\n        .json({ success: false, error: { code: 4001, message: '缺少命名空间或预热项目参数' } });\n      return;\n    }\n    const validItems = items.filter(\n      (item) => item && item.key && item.value !== undefined && typeof item.ttl === 'number'\n    );\n    if (validItems.length === 0) {\n      res\n        .status(400)\n        .json({ success: false, error: { code: 4001, message: '没有有效的预热项目' } });\n      return;\n    }\n    const normalizedPriority: CachePreloadPriority =\n      priority === 'high' ? 'high' : priority === 'low' ? 'low' : 'normal';\n    await cacheSubscriberService.triggerPreload(namespace, validItems, normalizedPriority);\n    res.json({\n      success: true,\n      message: '缓存预热请求已发送',\n      data: { namespace, itemCount: validItems.length, priority: normalizedPriority }\n    });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 缓存预热失败', error);\n    next(error);\n  }\n});\n\n// 批量删除缓存\nrouter.delete('/batch', authenticate, requireRole('admin'), async (req: Request, res: Response, next: NextFunction) => {\n  try {\n    const { pattern } = (req.body ?? {}) as { pattern?: string };\n    if (!pattern) {\n      res.status(400).json({ success: false, error: { code: 4001, message: '缺少模式参数' } });\n      return;\n    }\n    const deleteCount = await cacheService.deletePattern(pattern);\n    res.json({ success: true, message: '批量删除完成', data: { pattern, deleteCount } });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 批量删除缓存失败', error);\n    next(error);\n  }\n});\n\n// 重置缓存统计\nrouter.post('/stats/reset', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    cacheService.resetStats();\n    res.json({ success: true, message: '缓存统计已重置' });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 重置缓存统计失败', error);\n    next(error);\n  }\n});\n\n// 广播健康检查\nrouter.post('/health/broadcast', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    await cacheSubscriberService.broadcastHealthCheck();\n    res.json({ success: true, message: '健康检查广播已发送' });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 广播健康检查失败', error);\n    next(error);\n  }\n});\n\n// 获取订阅服务状态\nrouter.get('/subscriber/status', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    const status = cacheSubscriberService.getStatus();\n    res.json({ success: true, data: status });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 获取订阅服务状态失败', error);\n    next(error);\n  }\n});\n\n// 重启订阅服务\nrouter.post('/subscriber/restart', authenticate, requireRole('admin'), async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    await cacheSubscriberService.stop();\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    await cacheSubscriberService.start();\n    res.json({ success: true, message: '订阅服务重启成功' });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 重启订阅服务失败', error);\n    next(error);\n  }\n});\n\n// 公共缓存统计接口（无需认证）\nrouter.get('/public/stats', async (_req: Request, res: Response, next: NextFunction) => {\n  try {\n    const stats = cacheService.getStats();\n    const publicStats = {\n      hitRate: stats.hitRate,\n      memoryHitRate: stats.memoryHitRate,\n      memoryCacheSize: stats.memoryCacheSize,\n      uptime: stats.uptime\n    };\n    res.json({ success: true, data: publicStats });\n  } catch (error: unknown) {\n    logger.error('[CacheRoutes] 获取公共缓存统计失败', error);\n    next(error);\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/circuitBreaker.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/cmsFeatures.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/cmsProviders.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/contentTexts.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/distribution.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/docs.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/error-management.routes.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·row.map((cell:·string·|·number)·=>·`\"${String(cell)}\"`).join(',')` with `⏎········row.map((cell:·string·|·number)·=>·`\"${String(cell)}\"`).join(',')⏎······`","line":132,"column":44,"nodeType":null,"messageId":"replace","endLine":132,"endColumn":110,"fix":{"range":[4530,4596],"text":"\n        row.map((cell: string | number) => `\"${String(cell)}\"`).join(',')\n      "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { Router, type Request, type Response } from 'express';\nimport { authenticate, requireRole } from '../middlewares/auth.middleware.js';\nimport enhancedErrorHandler from '../middlewares/enhanced-error-handler.middleware.js';\nimport {\n  ERROR_CODES,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  ERROR_METADATA,\n  type ErrorCode\n} from '../config/error-codes.js';\nimport type { SupportedLanguageCode } from '../config/i18n-messages.js';\nimport AppError from '../utils/AppError.js';\n\nconst router = Router();\n\nconst resolveLocale = (req: Request): SupportedLanguageCode => {\n  const locale = req.i18n?.locale;\n  return locale === 'zh-CN' || locale === 'ja-JP' ? locale : 'en-US';\n};\n\n// GET /stats - 错误统计\nrouter.get('/stats', authenticate, requireRole('admin'), (req: Request, res: Response) => {\n  try {\n    const stats = enhancedErrorHandler.getErrorStats();\n    res.json({ success: true, data: stats, timestamp: new Date().toISOString() });\n  } catch (error: unknown) {\n    const message =\n      req.i18n?.getErrorMessage?.(ERROR_CODES.INTERNAL_SERVER_ERROR) ??\n      'Failed to get error statistics';\n    res.status(500).json({\n      success: false,\n      error: {\n        code: ERROR_CODES.INTERNAL_SERVER_ERROR,\n        message,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n});\n\n// GET /codes - 错误码列表\nrouter.get('/codes', authenticate, requireRole('admin'), (req: Request, res: Response) => {\n  try {\n    interface ErrorMetadataEntry {\n      category?: string;\n      severity?: string;\n    }\n\n    const errorCodesList = Object.entries(ERROR_CODES)\n      .filter(([key]) => !Number.isNaN(Number(key)))\n      .map(([name, code]) => {\n        const metadata = (ERROR_METADATA as Record<string, ErrorMetadataEntry>)[code] ?? {};\n        return {\n          name,\n          code: code as unknown as number,\n          category: metadata.category ?? 'unknown',\n          severity: metadata.severity ?? 'medium'\n        };\n      })\n      .sort((a, b) => a.code - b.code);\n\n    res.json({\n      success: true,\n      data: { categories: ERROR_CATEGORIES, severity: ERROR_SEVERITY, codes: errorCodesList },\n      timestamp: new Date().toISOString()\n    });\n  } catch (error: unknown) {\n    const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    const locale = resolveLocale(req);\n    res.status(appError.statusCode).json(appError.toJSON(locale));\n  }\n});\n\n// POST /reset-stats - 重置错误统计\nrouter.post('/reset-stats', authenticate, requireRole('admin'), (req: Request, res: Response) => {\n  try {\n    enhancedErrorHandler.resetStats();\n    const message =\n      req.i18n?.getMessage?.('error.stats_reset') ?? 'Error statistics reset successfully';\n    res.json({ success: true, message, timestamp: new Date().toISOString() });\n  } catch (error: unknown) {\n    const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    const locale = resolveLocale(req);\n    res.status(appError.statusCode).json(appError.toJSON(locale));\n  }\n});\n\n// POST /test - 触发测试错误\nrouter.post('/test', authenticate, requireRole('admin'), (req: Request, res: Response, next) => {\n  try {\n    const {\n      code,\n      message,\n      context = {}\n    } = (req.body ?? {}) as { code?: number; message?: string; context?: Record<string, unknown> };\n    if (!code || typeof code !== 'number') {\n      const error = AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        field: 'code',\n        reason: 'Code must be a valid error code number'\n      });\n      const locale = resolveLocale(req);\n      res.status(error.statusCode).json(error.toJSON(locale));\n      return;\n    }\n    const testError = AppError.custom(code as ErrorCode, message ?? '', {\n      ...context,\n      testMode: true,\n      requestedBy: req.user?.id,\n      timestamp: new Date().toISOString()\n    });\n    next(testError);\n  } catch (error: unknown) {\n    const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    next(appError);\n  }\n});\n\n// GET /export - 导出CSV\nrouter.get('/export', authenticate, requireRole('admin'), (req: Request, res: Response) => {\n  try {\n    const stats = enhancedErrorHandler.getErrorStats();\n    const csvHeaders = ['Code', 'Category', 'Severity', 'Count', 'Last Occurrence', 'Message'];\n    const rows = (stats.topErrors ?? []).map((e) => [\n      e.code,\n      e.category ?? 'unknown',\n      e.severity ?? 'unknown',\n      e.count,\n      new Date(e.lastOccurrence).toISOString(),\n      ''\n    ]);\n    const csv = [csvHeaders, ...rows]\n      .map((row: Array<string | number>) => row.map((cell: string | number) => `\"${String(cell)}\"`).join(','))\n      .join('\\n');\n    res.setHeader('Content-Type', 'text/csv');\n    res.setHeader(\n      'Content-Disposition',\n      `attachment; filename=\"error-stats-${new Date().toISOString().split('T')[0]}.csv\"`\n    );\n    res.send(csv);\n  } catch (error: unknown) {\n    const appError = AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    const locale = resolveLocale(req);\n    res.status(appError.statusCode).json(appError.toJSON(locale));\n  }\n});\n\nexport default router;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/feature-catalog.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/feature.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/health.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/importExport.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/invite-code.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/kms.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/mcpEndpoints.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/media.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/membership.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/membershipBenefits.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/membershipPlans.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/payment.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/pipelineExecution.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/pipelineSchemas.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/promptTemplates.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/providers.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/referral-validation.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/scfCallback.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/systemConfig.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/task.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/ui.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/user-profile.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/users.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/routes/wechat-login.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/scripts/rollback-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/ai-gateway.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/aiModel.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/aiModel.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const aiModelService: {\n  createModelTask: (taskId: string, inputImageUrl: string, params?: any) => Promise<void>;\n};\nexport default aiModelService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/aiModel.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `taskId:·string,·inputImageUrl:·string,·params:·Record<string,·unknown>·=·{}` with `⏎····taskId:·string,⏎····inputImageUrl:·string,⏎····params:·Record<string,·unknown>·=·{}⏎··`","line":134,"column":25,"nodeType":null,"messageId":"replace","endLine":134,"endColumn":100,"fix":{"range":[4379,4454],"text":"\n    taskId: string,\n    inputImageUrl: string,\n    params: Record<string, unknown> = {}\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·errorMessage:·'RunningHub处理失败'` with `⏎············errorMessage:·'RunningHub处理失败'⏎·········`","line":257,"column":61,"nodeType":null,"messageId":"replace","endLine":257,"endColumn":92,"fix":{"range":[9614,9645],"text":"\n            errorMessage: 'RunningHub处理失败'\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·errorMessage:·'处理超时(3分钟)'` with `⏎············errorMessage:·'处理超时(3分钟)'⏎·········`","line":263,"column":61,"nodeType":null,"messageId":"replace","endLine":263,"endColumn":87,"fix":{"range":[9848,9874],"text":"\n            errorMessage: '处理超时(3分钟)'\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace ``${this.config.apiUrl}/v1/status/${runningHubTaskId}`,` with `⏎········`${this.config.apiUrl}/v1/status/${runningHubTaskId}`,⏎·······`","line":278,"column":60,"nodeType":null,"messageId":"replace","endLine":278,"endColumn":114,"fix":{"range":[10420,10474],"text":"\n        `${this.config.apiUrl}/v1/status/${runningHubTaskId}`,\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":279,"column":1,"nodeType":null,"messageId":"insert","endLine":279,"endColumn":1,"fix":{"range":[10477,10477],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":280,"column":9,"nodeType":null,"messageId":"insert","endLine":280,"endColumn":9,"fix":{"range":[10553,10553],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎······`","line":281,"column":7,"nodeType":null,"messageId":"replace","endLine":281,"endColumn":8,"fix":{"range":[10574,10575],"text":"  }\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace ``${this.config.apiUrl}/v1/outputs/${runningHubTaskId}`,` with `⏎········`${this.config.apiUrl}/v1/outputs/${runningHubTaskId}`,⏎·······`","line":298,"column":60,"nodeType":null,"messageId":"replace","endLine":298,"endColumn":115,"fix":{"range":[11222,11277],"text":"\n        `${this.config.apiUrl}/v1/outputs/${runningHubTaskId}`,\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":299,"column":1,"nodeType":null,"messageId":"insert","endLine":299,"endColumn":1,"fix":{"range":[11280,11280],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":300,"column":9,"nodeType":null,"messageId":"insert","endLine":300,"endColumn":9,"fix":{"range":[11356,11356],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎······`","line":301,"column":7,"nodeType":null,"messageId":"replace","endLine":301,"endColumn":8,"fix":{"range":[11377,11378],"text":"  }\n      "}}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":11,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport { nanoid } from 'nanoid';\nimport logger from '../utils/logger.js';\nimport taskService from './task.service.js';\nimport contentAuditService from './contentAudit.service.js';\nimport systemConfigService from './systemConfig.service.js';\nimport { db } from '../config/database.js';\n\ninterface SystemConfigService {\n  get(key: string, defaultValue?: string): Promise<string | unknown>;\n}\n\ninterface TaskStatusPayload {\n  errorMessage?: string;\n  resultUrls?: string[];\n}\n\ninterface RunningHubResponse {\n  taskId?: string;\n  status?: string;\n  outputs?: string[];\n  data?: {\n    data?: {\n      taskId?: string;\n    };\n    taskId?: string;\n    status?: string;\n    outputs?: string[];\n  };\n}\n\nclass AIModelService {\n  private config = {\n    apiUrl: process.env.RUNNING_HUB_API_URL || 'https://www.runninghub.cn/task/openapi/ai-app/run',\n    apiKey: process.env.RUNNING_HUB_API_KEY || '0e6c8dc1ed9543a498189cbd331ae85c',\n    timeout: 180000\n  };\n\n  private dynamicConfig: {\n    webappId: string | null;\n    nodePrompt: string | null;\n    nodeImage: string | null;\n  } = {\n    webappId: null,\n    nodePrompt: null,\n    nodeImage: null\n  };\n\n  private promptTemplatesCache: Record<string, unknown> | null = null;\n  private initialized = false;\n\n  private async _initialize(): Promise<void> {\n    if (this.initialized) return;\n    try {\n      this.dynamicConfig.webappId = String(\n        await (systemConfigService as unknown as SystemConfigService).get(\n          'runninghub_webapp_id',\n          '1982694711750213634'\n        )\n      );\n      this.dynamicConfig.nodePrompt = String(\n        await (systemConfigService as unknown as SystemConfigService).get(\n          'runninghub_node_prompt',\n          '103'\n        )\n      );\n      this.dynamicConfig.nodeImage = String(\n        await (systemConfigService as unknown as SystemConfigService).get(\n          'runninghub_node_image',\n          '74'\n        )\n      );\n      this.initialized = true;\n      logger.info('[AIModelService] 动态配置加载完成', this.dynamicConfig);\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('[AIModelService] 动态配置加载失败,使用默认值', errorMessage);\n      this.dynamicConfig.webappId = '1982694711750213634';\n      this.dynamicConfig.nodePrompt = '103';\n      this.dynamicConfig.nodeImage = '74';\n      this.initialized = true;\n    }\n  }\n\n  async generatePrompt(scene: string, category: string): Promise<string> {\n    try {\n      const configKey = `ai_model_prompt_${scene}_${category}`;\n      const prompt = await (systemConfigService as unknown as SystemConfigService).get(configKey);\n      if (!prompt) {\n        logger.warn(`[AIModelService] 未找到配置 ${configKey},使用默认Prompt`);\n        return this._getDefaultPrompt(scene, category);\n      }\n      logger.info(`[AIModelService] 使用动态Prompt配置 ${configKey}`);\n      return String(prompt);\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`[AIModelService] 加载Prompt配置失败: ${errorMessage}`, { scene, category });\n      return this._getDefaultPrompt(scene, category);\n    }\n  }\n\n  private _getDefaultPrompt(scene: string, category: string): string {\n    const defaults: Record<string, Record<string, string>> = {\n      street: {\n        shoes:\n          '这是一个模特拍摄，鞋子为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为街拍风格，不同运镜和角度，不同的视角和景别',\n        dress:\n          '这是一个模特拍摄，连衣裙为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为街拍风格，不同运镜和角度，不同的视角和景别',\n        hoodie:\n          '这是一个模特拍摄，卫衣为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为街拍风格，不同运镜和角度，不同的视角和景别'\n      },\n      studio: {\n        shoes:\n          '这是一个模特拍摄，鞋子为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为白棚摄影棚，不同运镜和角度，不同的视角和景别',\n        dress:\n          '这是一个模特拍摄，连衣裙为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为白棚摄影棚，不同运镜和角度，不同的视角和景别',\n        hoodie:\n          '这是一个模特拍摄，卫衣为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为白棚摄影棚，不同运镜和角度，不同的视角和景别'\n      },\n      indoor: {\n        shoes:\n          '这是一个模特拍摄，鞋子为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为室内居家环境，不同运镜和角度，不同的视角和景别',\n        dress:\n          '这是一个模特拍摄，连衣裙为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为室内居家环境，不同运镜和角度，不同的视角和景别',\n        hoodie:\n          '这是一个模特拍摄，卫衣为主题，参考图片，帮我生成12张不同分镜摆姿图片，场景为室内居家环境，不同运镜和角度，不同的视角和景别'\n      }\n    };\n    const prompt = defaults[scene]?.[category];\n    if (!prompt) throw new Error(`不支持的场景或品类: ${scene}/${category}`);\n    return prompt;\n  }\n\n  async createModelTask(taskId: string, inputImageUrl: string, params: Record<string, unknown> = {}) {\n    try {\n      const scene = (params.scene as string) || 'street';\n      const category = (params.category as string) || 'dress';\n      logger.info(\n        `[AIModelService] 创建AI模特任务 taskId=${taskId} scene=${scene} category=${category}`\n      );\n      await this._initialize();\n      await taskService.updateStatus(taskId, 'processing', {});\n      const prompt = await this.generatePrompt(scene, category);\n      const runningHubTaskId = await this.submitToRunningHub(inputImageUrl, prompt);\n      await this.saveRunningHubTaskId(taskId, runningHubTaskId);\n      logger.info(\n        `[AIModelService] AI模特任务已提交 taskId=${taskId} rhTaskId=${runningHubTaskId}`\n      );\n      this.startPolling(taskId, runningHubTaskId).catch((err: unknown) => {\n        const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n        logger.error(`[AIModelService] 轮询失败: ${errorMessage}`, { taskId });\n      });\n      return { taskId, runningHubTaskId, status: 'processing' };\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'AI模特任务创建失败';\n      logger.error(`[AIModelService] 创建AI模特任务失败: ${errorMessage}`, { taskId, error });\n      await taskService.updateStatus(taskId, 'failed', {\n        errorMessage\n      } as TaskStatusPayload);\n      throw error;\n    }\n  }\n\n  async submitToRunningHub(imageUrl: string, prompt: string): Promise<string> {\n    try {\n      const imageKey = this.extractImageKey(imageUrl);\n      const requestBody: Record<string, unknown> = {\n        webappId: this.dynamicConfig.webappId,\n        apiKey: this.config.apiKey,\n        nodeInfoList: [\n          {\n            nodeId: this.dynamicConfig.nodePrompt,\n            fieldName: 'text',\n            fieldValue: prompt,\n            description: '输入提示词'\n          },\n          {\n            nodeId: this.dynamicConfig.nodeImage,\n            fieldName: 'image',\n            fieldValue: imageKey,\n            description: '输入图片'\n          }\n        ]\n      };\n      logger.info('[AIModelService] 调用RunningHub API (使用动态配置)', {\n        webappId: this.dynamicConfig.webappId,\n        nodePrompt: this.dynamicConfig.nodePrompt,\n        nodeImage: this.dynamicConfig.nodeImage,\n        imageKey\n      });\n      const response = await axios.post<RunningHubResponse>(this.config.apiUrl, requestBody, {\n        headers: { Host: 'www.runninghub.cn', 'Content-Type': 'application/json' },\n        timeout: 30000\n      });\n      const taskId = (response.data?.data?.taskId ?? response.data?.taskId) as string | undefined;\n      if (!taskId) throw new Error('RunningHub未返回任务ID');\n      logger.info(`[AIModelService] RunningHub任务已创建 taskId=${taskId}`);\n      return taskId;\n    } catch (error: unknown) {\n      const axiosError = error as Record<string, unknown>;\n      if (axiosError.code === 'ECONNREFUSED' || axiosError.code === 'ENOTFOUND') {\n        logger.warn('[AIModelService] RunningHub未配置,使用模拟任务ID');\n        return `mock_${nanoid()}`;\n      }\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(`[AIModelService] RunningHub调用失败: ${errorMessage}`, error);\n      throw new Error(`RunningHub调用失败: ${errorMessage}`);\n    }\n  }\n\n  extractImageKey(url: string): string {\n    try {\n      const urlObj = new URL(url);\n      const pathname = urlObj.pathname;\n      const parts = pathname.split('/');\n      return parts[parts.length - 1];\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      logger.error(`[AIModelService] 提取图片key失败: ${errorMessage}`, { url });\n      throw new Error('无效的图片URL');\n    }\n  }\n\n  async saveRunningHubTaskId(taskId: string, runningHubTaskId: string): Promise<void> {\n    await db('tasks')\n      .where('id', taskId)\n      .update({ params: db.raw('JSON_SET(params, \"$.runningHubTaskId\", ?)', [runningHubTaskId]) });\n  }\n\n  async startPolling(taskId: string, runningHubTaskId: string): Promise<void> {\n    const maxAttempts = 60;\n    let attempts = 0;\n    const poll = async (): Promise<void> => {\n      try {\n        attempts++;\n        const task = await db('tasks').where('id', taskId).first();\n        if (!task || task.status !== 'processing') {\n          logger.info('[AIModelService] 任务已不在处理中,停止轮询', { taskId });\n          return;\n        }\n        const status = await this.queryRunningHubStatus(runningHubTaskId);\n        if (status === 'SUCCESS') {\n          const resultUrls = await this.fetchResults(runningHubTaskId);\n          logger.info('[AIModelService] 结果拉取完成,开始内容审核', {\n            taskId,\n            count: resultUrls.length\n          });\n          const auditResult = await contentAuditService.auditTaskResults(taskId, resultUrls);\n          if (!auditResult.pass) {\n            logger.warn('[AIModelService] 内容审核未通过', { taskId });\n            return;\n          }\n          await taskService.updateStatus(taskId, 'success', { resultUrls } as TaskStatusPayload);\n          logger.info('[AIModelService] AI模特任务完成', { taskId, count: resultUrls.length });\n          return;\n        } else if (status === 'FAILED') {\n          await taskService.updateStatus(taskId, 'failed', { errorMessage: 'RunningHub处理失败' } as TaskStatusPayload);\n          return;\n        }\n        if (attempts < maxAttempts) {\n          setTimeout(poll, 3000);\n        } else {\n          await taskService.updateStatus(taskId, 'failed', { errorMessage: '处理超时(3分钟)' } as TaskStatusPayload);\n        }\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        logger.error('[AIModelService] 轮询错误', { taskId, attempts, error: errorMessage });\n        if (attempts < maxAttempts) {\n          setTimeout(poll, 3000);\n        }\n      }\n    };\n    setTimeout(poll, 3000);\n  }\n\n  async queryRunningHubStatus(runningHubTaskId: string): Promise<'SUCCESS' | 'FAILED' | 'PENDING'> {\n    try {\n      const response = await axios.get<RunningHubResponse>(`${this.config.apiUrl}/v1/status/${runningHubTaskId}`, {\n        headers: { Authorization: `Bearer ${this.config.apiKey}` },\n        timeout: 10000\n      });\n      const status = String(response.data?.status || 'PENDING');\n      if (['SUCCESS', 'FAILED', 'PENDING'].includes(status)) {\n        return status as 'SUCCESS' | 'FAILED' | 'PENDING';\n      }\n      return 'PENDING';\n    } catch (error: unknown) {\n      const axiosError = error as Record<string, unknown>;\n      if (axiosError.code === 'ECONNREFUSED' || axiosError.code === 'ENOTFOUND') {\n        return runningHubTaskId.startsWith('mock_') ? 'SUCCESS' : 'PENDING';\n      }\n      throw error;\n    }\n  }\n\n  async fetchResults(runningHubTaskId: string): Promise<string[]> {\n    try {\n      const response = await axios.get<RunningHubResponse>(`${this.config.apiUrl}/v1/outputs/${runningHubTaskId}`, {\n        headers: { Authorization: `Bearer ${this.config.apiKey}` },\n        timeout: 30000\n      });\n      const outputs = response.data?.outputs;\n      if (Array.isArray(outputs)) {\n        return outputs as string[];\n      }\n      return [];\n    } catch (error: unknown) {\n      const axiosError = error as Record<string, unknown>;\n      if (axiosError.code === 'ECONNREFUSED' || axiosError.code === 'ENOTFOUND') {\n        const mockUrls: string[] = [];\n        for (let i = 0; i < 12; i++) mockUrls.push(`https://mock-cdn.com/result_${i + 1}.png`);\n        return mockUrls;\n      }\n      throw error;\n    }\n  }\n}\n\nexport default new AIModelService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/announcementScheduler.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/asset.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/auditLogger.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":28,"column":16,"nodeType":null,"messageId":"insert","endLine":28,"endColumn":16,"fix":{"range":[620,620],"text":"\n     "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Audit Logger Service\n * 艹，审计日志服务！便捷记录方法\n */\n\nimport * as auditRepo from '../repositories/auditLogs.repo.js';\nimport { Request } from 'express';\n\n/**\n * Request用户信息接口\n */\ninterface RequestUser {\n  id: string;\n  name?: string;\n  email?: string;\n}\n\n/**\n * 从Request提取用户信息和IP\n */\nfunction extractRequestInfo(req?: Request) {\n  const user = (req as Request & { user?: RequestUser })?.user;\n  const parsedUserId = user?.id !== undefined ? Number(user.id) : undefined;\n\n  return {\n    user_id: Number.isFinite(parsedUserId) ? (parsedUserId as number) : undefined,\n    user_name: user?.name || user?.email,\n    ip_address: req?.ip || (req?.connection as unknown as { remoteAddress?: string })?.remoteAddress,\n    user_agent: req?.get('user-agent')\n  };\n}\n\n/**\n * 审计日志参数接口\n */\ninterface AuditLogParams {\n  entity_type: string;\n  entity_id: number;\n  req?: Request;\n  changes?: Record<string, unknown>;\n  reason?: string;\n}\n\n/**\n * 记录创建操作\n */\nexport async function logCreate(params: AuditLogParams): Promise<void> {\n  const { entity_type, entity_id, req, changes, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'create',\n    changes,\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 记录更新操作\n */\nexport async function logUpdate(params: AuditLogParams): Promise<void> {\n  const { entity_type, entity_id, req, changes, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'update',\n    changes,\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 记录删除操作\n */\nexport async function logDelete(params: AuditLogParams): Promise<void> {\n  const { entity_type, entity_id, req, changes, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'delete',\n    changes,\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 发布/下线/审核操作参数接口\n */\ninterface AuditActionParams {\n  entity_type: string;\n  entity_id: number;\n  req?: Request;\n  reason?: string;\n}\n\n/**\n * 记录发布操作\n */\nexport async function logPublish(params: AuditActionParams): Promise<void> {\n  const { entity_type, entity_id, req, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'publish',\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 记录下线操作\n */\nexport async function logUnpublish(params: AuditActionParams): Promise<void> {\n  const { entity_type, entity_id, req, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'unpublish',\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 记录审核通过操作\n */\nexport async function logApprove(params: AuditActionParams): Promise<void> {\n  const { entity_type, entity_id, req, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'approve',\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n\n/**\n * 记录审核拒绝操作\n */\nexport async function logReject(params: AuditActionParams): Promise<void> {\n  const { entity_type, entity_id, req, reason } = params;\n\n  await auditRepo.createAuditLog({\n    entity_type,\n    entity_id,\n    action: 'reject',\n    reason,\n    ...extractRequestInfo(req)\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/auth.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····email:·string,⏎····code:·string,⏎····referrerId?:·string·|·null⏎··` with `email:·string,·code:·string,·referrerId?:·string·|·null`","line":45,"column":22,"nodeType":null,"messageId":"replace","endLine":49,"endColumn":3,"fix":{"range":[1532,1603],"text":"email: string, code: string, referrerId?: string | null"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `.where({·id:·recordId·})` with `⏎······.where({·id:·recordId·})⏎······`","line":536,"column":35,"nodeType":null,"messageId":"replace","endLine":536,"endColumn":59,"fix":{"range":[13973,13997],"text":"\n      .where({ id: recordId })\n      "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\n * 认证服务 - TS ESM版本\n * 艹，这个tm管理所有登录认证逻辑！\n * 支持三种登录方式：\n * 1. 验证码登录（主要方式）\n * 2. 密码登录（备用方式）\n * 3. 微信登录（P1核心功能）\n */\n\nimport bcrypt from 'bcryptjs';\nimport { nanoid } from 'nanoid';\nimport axios from 'axios';\nimport crypto from 'crypto';\nimport db from '../db/index.js';\nimport tokenService, { TokenPair, UserForToken } from './token.service.js';\nimport logger from '../utils/logger.js';\nimport * as userRepo from '../repositories/users.repo.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport cacheService from './cache.service.js';\nimport { sendVerificationEmail } from './email.service.js';\n\nexport interface TokenSigner {\n  generateTokenPair(user: UserForToken): TokenPair;\n  refreshTokens(refreshToken: string): Promise<TokenPair | null>;\n  revokeUserTokens(userId: string): Promise<boolean>;\n  isUserRevoked(userId: string): Promise<boolean>;\n  isTokenBlacklisted(jti: string): Promise<boolean>;\n}\n\nexport interface AuthResult extends TokenPair {\n  user: userRepo.SafeUser;\n}\n\nexport interface AuthProvider {\n  sendCode(phone: string, ip: string): Promise<{ expireIn: number }>;\n  loginWithCode(phone: string, code: string, referrerId?: string | null): Promise<AuthResult>;\n  loginWithPassword(phone: string, password: string): Promise<AuthResult>;\n  registerWithPassword(\n    phone: string,\n    password: string,\n    referrerId?: string | null\n  ): Promise<AuthResult>;\n  sendEmailCode(email: string, ip: string): Promise<{ expireIn: number }>;\n  loginWithEmailCode(\n    email: string,\n    code: string,\n    referrerId?: string | null\n  ): Promise<AuthResult>;\n  registerWithEmail(\n    email: string,\n    code: string,\n    password: string,\n    referrerId?: string | null\n  ): Promise<AuthResult>;\n  getUser(userId: string): Promise<userRepo.SafeUser>;\n  refreshToken(refreshToken: string): Promise<TokenPair | null>;\n  logout(userId: string): Promise<boolean>;\n  verifyTokenStatus(userId: string, jti?: string): Promise<boolean>;\n  resetPasswordWithEmail(email: string, code: string, newPassword: string): Promise<boolean>;\n}\n\n/**\n * 生成6位数字验证码\n * 艹，简单有效！\n */\nfunction generateCode(length: number = 6): string {\n  return Math.floor(Math.random() * Math.pow(10, length))\n    .toString()\n    .padStart(length, '0');\n}\n\n/**\n * 生成ID\n */\nfunction generateId(length: number = 16): string {\n  return nanoid(length * 2);\n}\n\ninterface VerificationCodeRecord {\n  id: number;\n  phone: string | null;\n  email: string | null;\n  code: string;\n  channel: 'sms' | 'email';\n  expireAt: Date;\n  used: boolean;\n}\n\n/**\n * 认证服务类\n */\nclass AuthService implements AuthProvider {\n  constructor(private readonly tokenSigner: TokenSigner = tokenService) {}\n  /**\n   * 发送验证码\n   * 艹，防刷限制一定要做！\n   */\n  async sendCode(phone: string, ip: string): Promise<{ expireIn: number }> {\n    // 1. 防刷限制检查\n    await this.checkSmsRateLimit(phone, ip);\n\n    // 2. 生成验证码\n    const code = generateCode(6);\n    const expireAt = new Date(Date.now() + 5 * 60 * 1000); // 5分钟有效期\n\n    // 3. 保存验证码到数据库\n    await db('verification_codes').insert({\n      phone,\n      code,\n      ip,\n      expireAt,\n      used: false,\n      created_at: new Date(),\n      updated_at: new Date()\n    });\n\n    // 4. 调用短信服务发送验证码\n    await this.sendSMS(phone, code);\n\n    // 5. 写入缓存用于后续校验\n    await cacheService.set(`sms:${phone}`, code, { ttl: 5 * 60, skipMemoryCache: true });\n\n    logger.info(`[AuthService] 验证码已发送: phone=${phone}, ip=${ip}`);\n\n    return {\n      expireIn: 300 // 5分钟\n    };\n  }\n\n  /**\n   * 防刷限制检查\n   * 艹，不能让恶意用户刷爆短信！\n   */\n  private async checkSmsRateLimit(phone: string, ip: string): Promise<void> {\n    const now = new Date();\n    const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n\n    // 同一手机号 1分钟内最多1次\n    const phoneCount = await db('verification_codes')\n      .where('phone', phone)\n      .where('created_at', '>=', oneMinuteAgo)\n      .count('* as count')\n      .first();\n\n    const phoneCountNum = phoneCount ? Number(phoneCount.count) : 0;\n    if (phoneCountNum >= 1) {\n      throw new Error('验证码发送过于频繁，请1分钟后再试');\n    }\n\n    // 同一IP 1小时内最多20次\n    const ipCount = await db('verification_codes')\n      .where('ip', ip)\n      .where('created_at', '>=', oneHourAgo)\n      .count('* as count')\n      .first();\n\n    const ipCountNum = ipCount ? Number(ipCount.count) : 0;\n    if (ipCountNum >= 20) {\n      throw new Error('请求过于频繁，请稍后再试');\n    }\n  }\n\n  private async checkEmailRateLimit(email: string, ip: string): Promise<void> {\n    const normalized = this.normalizeEmail(email);\n    const now = new Date();\n    const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);\n    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n\n    const emailCount = await db('verification_codes')\n      .where('email', normalized)\n      .where('channel', 'email')\n      .where('created_at', '>=', oneMinuteAgo)\n      .count('* as count')\n      .first();\n\n    if ((emailCount?.count ? Number(emailCount.count) : 0) >= 1) {\n      throw new Error('邮箱验证码发送过于频繁，请1分钟后再试');\n    }\n\n    const ipCount = await db('verification_codes')\n      .where('ip', ip)\n      .where('channel', 'email')\n      .where('created_at', '>=', oneHourAgo)\n      .count('* as count')\n      .first();\n\n    if ((ipCount?.count ? Number(ipCount.count) : 0) >= 50) {\n      throw new Error('请求过于频繁，请稍后再试');\n    }\n  }\n\n  /**\n   * 发送短信验证码\n   * 艹，生产环境要对接腾讯云短信！\n   */\n  private async sendSMS(phone: string, code: string): Promise<void> {\n    // 开发环境直接打印\n    if (process.env.NODE_ENV !== 'production') {\n      logger.info(`[SMS] 发送验证码到 ${phone}: ${code}`);\n      return;\n    }\n\n    // TODO: 生产环境对接腾讯云短信服务\n    logger.info(`[SMS] 发送验证码到 ${phone}: ${code}`);\n  }\n\n  /**\n   * 验证码登录/注册\n   * 艹，验证码校验通过后，自动注册或登录！\n   */\n  async loginWithCode(\n    phone: string,\n    code: string,\n    referrerId?: string | null\n  ): Promise<AuthResult> {\n    // 1. 验证码校验\n    const record = await this.verifyCode(phone, code);\n\n    // 2. 查询或创建用户\n    let user = await db('users').where('phone', phone).first();\n\n    if (!user) {\n      // 用户不存在，创建新用户（在事务中处理）\n      await db.transaction(async (trx) => {\n        const userId = generateId();\n\n        // 创建用户\n        await trx('users').insert({\n          id: userId,\n          phone,\n          referrer_id: referrerId || null,\n          isMember: false,\n          quota_remaining: 0,\n          quota_expireAt: null,\n          role: 'user',\n          created_at: new Date(),\n          updated_at: new Date()\n        });\n\n        // 如果有推荐人，绑定推荐关系\n        if (referrerId) {\n          // TODO: 调用distribution service绑定推荐关系\n          logger.info(`[AuthService] 推荐关系绑定尝试: referrerId=${referrerId}, userId=${userId}`);\n        }\n\n        logger.info(\n          `[AuthService] 新用户注册: userId=${userId}, phone=${phone}, referrerId=${referrerId}`\n        );\n      });\n\n      user = await db('users').where('phone', phone).first();\n    }\n\n    // 3. 标记验证码已使用\n    await this.markCodeUsed(record.id);\n\n    // 4. 生成双Token对\n    const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n\n    logger.info(`[AuthService] 用户登录成功: userId=${user.id}, phone=${phone}`);\n\n    return {\n      ...tokens,\n      user: userRepo.toSafeUser(user)\n    };\n  }\n\n  /**\n   * 密码登录\n   * 艹，备用登录方式！\n   */\n  async loginWithPassword(phone: string, password: string): Promise<AuthResult> {\n    // 1. 查找用户\n    const user = await userRepo.findUserByPhone(phone);\n    if (!user) {\n      throw new Error('手机号或密码错误');\n    }\n\n    // 2. 验证密码\n    if (!user.password) {\n      throw new Error('该账号未设置密码，请使用验证码登录');\n    }\n\n    const passwordMatch = await bcrypt.compare(password, user.password);\n    if (!passwordMatch) {\n      throw new Error('手机号或密码错误');\n    }\n\n    // 3. 生成Token对\n    const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n\n    logger.info(`[AuthService] 密码登录成功: userId=${user.id}, phone=${phone}`);\n\n    return {\n      ...tokens,\n      user: userRepo.toSafeUser(user)\n    };\n  }\n\n  /**\n   * 注册新用户（密码方式）\n   * 艹，设置密码注册！\n   */\n  async registerWithPassword(\n    phone: string,\n    password: string,\n    referrerId?: string | null\n  ): Promise<AuthResult> {\n    // 1. 检查手机号是否已存在\n    const exists = await userRepo.phoneExists(phone);\n    if (exists) {\n      throw new Error('手机号已被注册');\n    }\n\n    // 2. 密码加密\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // 3. 创建用户\n    const user = await userRepo.createUser({\n      id: nanoid(32),\n      phone,\n      password: hashedPassword,\n      role: 'user',\n      isMember: false,\n      quota_remaining: 0,\n      referrer_id: referrerId || null\n    });\n\n    // 4. 生成Token\n    const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n\n    logger.info(`[AuthService] 用户注册成功: userId=${user.id}, phone=${phone}`);\n\n    return {\n      ...tokens,\n      user: userRepo.toSafeUser(user)\n    };\n  }\n\n  /**\n   * 发送邮箱验证码\n   */\n  async sendEmailCode(email: string, ip: string): Promise<{ expireIn: number }> {\n    if (!email) {\n      throw new Error('邮箱不能为空');\n    }\n    if (!this.isValidEmail(email)) {\n      throw new Error('邮箱格式不正确');\n    }\n\n    const normalized = this.normalizeEmail(email);\n    await this.checkEmailRateLimit(normalized, ip);\n\n    const code = generateCode(6);\n    const expireAt = new Date(Date.now() + 5 * 60 * 1000);\n\n    await db('verification_codes').insert({\n      phone: null,\n      email: normalized,\n      code,\n      ip,\n      channel: 'email',\n      expireAt,\n      used: false,\n      created_at: new Date(),\n      updated_at: new Date()\n    });\n\n    await sendVerificationEmail(normalized, code);\n    await cacheService.set(`email:${normalized}`, code, { ttl: 5 * 60, skipMemoryCache: true });\n\n    logger.info(`[AuthService] 邮箱验证码已发送: email=${normalized}, ip=${ip}`);\n\n    return { expireIn: 300 };\n  }\n\n  /**\n   * 邮箱验证码登录（不存在则自动注册）\n   */\n  async loginWithEmailCode(\n    email: string,\n    code: string,\n    referrerId?: string | null\n  ): Promise<AuthResult> {\n    if (!email || !code) {\n      throw new Error('邮箱和验证码不能为空');\n    }\n    if (!this.isValidEmail(email)) {\n      throw new Error('邮箱格式不正确');\n    }\n\n    const normalized = this.normalizeEmail(email);\n    const record = await this.verifyEmailCode(normalized, code);\n\n    let user = await userRepo.findUserByEmail(normalized);\n\n    if (!user) {\n      const userId = generateId();\n      await db('users').insert({\n        id: userId,\n        email: normalized,\n        email_verified: true,\n        email_verified_at: new Date(),\n        referrer_id: referrerId || null,\n        isMember: false,\n        quota_remaining: 0,\n        quota_expireAt: null,\n        role: 'user',\n        created_at: new Date(),\n        updated_at: new Date()\n      });\n      user = await userRepo.findUserById(userId);\n    } else if (!user.email_verified) {\n      await userRepo.updateUser(user.id, {\n        email_verified: true,\n        email_verified_at: new Date()\n      });\n      user = await userRepo.findUserById(user.id);\n    }\n\n    await this.markCodeUsed(record.id);\n    await cacheService.delete(`email:${normalized}`);\n\n    const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n    logger.info(`[AuthService] 邮箱验证码登录成功: email=${normalized}, userId=${user?.id}`);\n\n    return {\n      ...tokens,\n      user: userRepo.toSafeUser(user)\n    };\n  }\n\n  /**\n   * 邮箱注册（验证码 + 密码）\n   */\n  async registerWithEmail(\n    email: string,\n    code: string,\n    password: string,\n    referrerId?: string | null\n  ): Promise<AuthResult> {\n    if (!email || !code || !password) {\n      throw new Error('邮箱、验证码和密码不能为空');\n    }\n    if (!this.isValidEmail(email)) {\n      throw new Error('邮箱格式不正确');\n    }\n\n    const normalized = this.normalizeEmail(email);\n    const exists = await userRepo.emailExists(normalized);\n    if (exists) {\n      throw new Error('邮箱已被注册');\n    }\n\n    if (password.length < 6) {\n      throw new Error('密码长度不能少于6位');\n    }\n\n    const record = await this.verifyEmailCode(normalized, code);\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    const user = await userRepo.createUser({\n      id: nanoid(32),\n      email: normalized,\n      password: hashedPassword,\n      role: 'user',\n      isMember: false,\n      quota_remaining: 0,\n      referrer_id: referrerId || null,\n      email_verified: true,\n      email_verified_at: new Date()\n    });\n\n    await this.markCodeUsed(record.id);\n    await cacheService.delete(`email:${normalized}`);\n\n    const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n    logger.info(`[AuthService] 邮箱注册成功: email=${normalized}, userId=${user.id}`);\n\n    return {\n      ...tokens,\n      user: userRepo.toSafeUser(user)\n    };\n  }\n\n  /**\n   * 验证验证码\n   * 艹，检查验证码是否有效！\n   */\n  private async verifyCode(phone: string, code: string): Promise<VerificationCodeRecord> {\n    const record = (await db('verification_codes')\n      .where('phone', phone)\n      .where('code', code)\n      .where('channel', 'sms')\n      .where('used', false)\n      .where('expireAt', '>=', new Date())\n      .orderBy('created_at', 'desc')\n      .first()) as VerificationCodeRecord | undefined;\n\n    if (!record) {\n      throw new Error('验证码错误或已过期');\n    }\n\n    return record;\n  }\n\n  private normalizeEmail(email: string): string {\n    return email.trim().toLowerCase();\n  }\n\n  private isValidEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n\n  private async verifyEmailCode(email: string, code: string): Promise<VerificationCodeRecord> {\n    const normalized = this.normalizeEmail(email);\n    const record = (await db('verification_codes')\n      .where('email', normalized)\n      .where('code', code)\n      .where('channel', 'email')\n      .where('used', false)\n      .where('expireAt', '>=', new Date())\n      .orderBy('created_at', 'desc')\n      .first()) as VerificationCodeRecord | undefined;\n\n    if (!record) {\n      throw new Error('验证码错误或已过期');\n    }\n\n    return record;\n  }\n\n  private async markCodeUsed(recordId: number): Promise<void> {\n    await db('verification_codes').where({ id: recordId }).update({ used: true, updated_at: new Date() });\n  }\n\n  /**\n   * 获取用户信息\n   * 艹，通过ID获取用户详情！\n   */\n  async getUser(userId: string): Promise<userRepo.SafeUser> {\n    const user = await userRepo.findUserById(userId);\n\n    if (!user) {\n      throw new Error('用户不存在');\n    }\n\n    return userRepo.toSafeUser(user);\n  }\n\n  /**\n   * 邮箱验证码重置密码\n   */\n  async resetPasswordWithEmail(email: string, code: string, newPassword: string): Promise<boolean> {\n    if (!email || !code || !newPassword) {\n      throw new Error('邮箱、验证码和新密码不能为空');\n    }\n    if (!this.isValidEmail(email)) {\n      throw new Error('邮箱格式不正确');\n    }\n    if (newPassword.length < 6) {\n      throw new Error('密码至少6位');\n    }\n\n    const normalized = this.normalizeEmail(email);\n    const record = await this.verifyEmailCode(normalized, code);\n    const user = await userRepo.findUserByEmail(normalized);\n\n    if (!user) {\n      throw new Error('用户不存在');\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    await userRepo.updateUser(user.id, { password: hashedPassword });\n    await this.markCodeUsed(record.id);\n    await cacheService.delete(`email:${normalized}`);\n\n    logger.info(`[AuthService] 邮箱密码重置成功: email=${normalized}, userId=${user.id}`);\n    return true;\n  }\n\n  /**\n   * 刷新Token\n   * 艹，用Refresh Token换新的Access Token！\n   */\n  async refreshToken(refreshToken: string): Promise<TokenPair | null> {\n    return this.tokenSigner.refreshTokens(refreshToken);\n  }\n\n  /**\n   * 登出\n   * 艹，撤销用户的所有Token！\n   */\n  async logout(userId: string): Promise<boolean> {\n    return this.tokenSigner.revokeUserTokens(userId);\n  }\n\n  /**\n   * 验证Token状态\n   * 艹，检查Token是否还有效！\n   */\n  async verifyTokenStatus(userId: string, jti?: string): Promise<boolean> {\n    // 检查用户是否被撤销\n    const isRevoked = await this.tokenSigner.isUserRevoked(userId);\n    if (isRevoked) {\n      return false;\n    }\n\n    // 检查Token是否在黑名单\n    if (jti) {\n      const isBlacklisted = await this.tokenSigner.isTokenBlacklisted(jti);\n      if (isBlacklisted) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * 微信登录 (P1核心功能)\n   * 艹！调用微信API获取用户信息并自动注册/登录\n   */\n  async wechatLogin(code: string): Promise<AuthResult> {\n    try {\n      // 1. 调用微信API code2Session获取openid和unionid\n      const wxAppId = process.env.WECHAT_APP_ID;\n      const wxAppSecret = process.env.WECHAT_APP_SECRET;\n\n      if (!wxAppId || !wxAppSecret) {\n        throw new Error('微信配置不完整');\n      }\n\n      const wxApiUrl = `https://api.weixin.qq.com/sns/jscode2session`;\n      const response = await axios.get(wxApiUrl, {\n        params: {\n          appid: wxAppId,\n          secret: wxAppSecret,\n          js_code: code,\n          grant_type: 'authorization_code'\n        }\n      });\n\n      if (response.data.errcode) {\n        logger.error(`微信code2Session失败: ${response.data.errmsg}`);\n        throw new Error('微信登录失败: ' + response.data.errmsg);\n      }\n\n      const { openid, unionid } = response.data;\n\n      // 2. 查询或创建用户（通过openid）\n      let user = await db('users').where('wechat_openid', openid).first();\n\n      if (!user) {\n        // 新用户，自动注册\n        await db.transaction(async (trx) => {\n          const userId = generateId();\n\n          await trx('users').insert({\n            id: userId,\n            phone: null, // 微信登录时phone为空，后续可绑定\n            wechat_openid: openid,\n            wechat_unionid: unionid || null,\n            isMember: false,\n            quota_remaining: 0,\n            quota_expireAt: null,\n            role: 'user',\n            created_at: new Date(),\n            updated_at: new Date()\n          });\n\n          logger.info(`微信新用户注册: userId=${userId}, openid=${openid}`);\n        });\n\n        user = await db('users').where('wechat_openid', openid).first();\n      }\n\n      // 3. 生成访问令牌\n      const tokens = this.tokenSigner.generateTokenPair(user as UserForToken);\n\n      logger.info(`微信登录成功: userId=${user.id}, openid=${openid}`);\n\n      return {\n        ...tokens,\n        user: userRepo.toSafeUser(user)\n      };\n    } catch (error: unknown) {\n      if (error instanceof Error) {\n        const appError = error as Error & { statusCode?: number };\n        if (appError.statusCode) {\n          throw error;\n        }\n        logger.error(`微信登录异常: ${error.message}`, error);\n      } else {\n        logger.error(`微信登录异常:`, error);\n      }\n      throw new Error('微信登录失败');\n    }\n  }\n\n  /**\n   * 设置/修改密码 (P1核心功能)\n   * 艹！用户可以设置或修改密码\n   */\n  async setPassword(\n    userId: string,\n    newPassword: string,\n    oldPassword: string | null = null\n  ): Promise<{ success: boolean }> {\n    // 1. 查询用户\n    const user = await db('users').where('id', userId).first();\n\n    if (!user) {\n      throw new AppError(ERROR_CODES.USER_NOT_FOUND);\n    }\n\n    // 2. 如果用户已有密码,验证旧密码\n    if (user.password && oldPassword) {\n      const isOldPasswordValid = await this.verifyPassword(oldPassword, user.password);\n      if (!isOldPasswordValid) {\n        throw new Error('旧密码错误');\n      }\n    } else if (user.password && !oldPassword) {\n      throw new Error('修改密码需要提供旧密码');\n    }\n\n    // 3. 密码强度校验（至少6位）\n    if (newPassword.length < 6) {\n      throw new Error('密码长度至少6位');\n    }\n\n    // 4. 加密新密码\n    const hashedPassword = await this.hashPassword(newPassword);\n\n    // 5. 更新数据库\n    await db('users').where('id', userId).update({\n      password: hashedPassword,\n      updated_at: new Date()\n    });\n\n    logger.info(`用户设置密码成功: userId=${userId}`);\n\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * 验证推荐人有效性 (P1-017)\n   * 艹！防止用户填写无效的推荐人ID\n   */\n  async validateReferrer(referrerId: string): Promise<boolean> {\n    // 1. 检查推荐人是否存在\n    const referrer = await db('users').where('id', referrerId).first();\n\n    if (!referrer) {\n      throw new Error('推荐人不存在');\n    }\n\n    // 2. 检查推荐人账号状态\n    if (referrer.deleted_at) {\n      throw new Error('推荐人账号已被删除');\n    }\n\n    // 3. 检查推荐人是否是分销员（可选）\n    const distributor = await db('distributors')\n      .where('user_id', referrerId)\n      .where('status', 'active')\n      .first();\n\n    if (distributor) {\n      logger.info(`推荐人验证通过（分销员）: referrerId=${referrerId}`);\n    } else {\n      logger.info(`推荐人验证通过（普通用户）: referrerId=${referrerId}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * 密码加密 (私有方法)\n   * 艹！使用bcrypt加密密码\n   */\n  private async hashPassword(password: string): Promise<string> {\n    const saltRounds = 10;\n    return await bcrypt.hash(password, saltRounds);\n  }\n\n  /**\n   * 密码验证 (私有方法)\n   * 艹！验证密码是否匹配\n   */\n  private async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n    return await bcrypt.compare(password, hashedPassword);\n  }\n}\n\n// 导出单例\nexport const authService = new AuthService();\nexport default authService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/bannerScheduler.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/buildingai-adaptor.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/buildingai-adaptor.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const buildingAIAdaptorService: {\n  callAPI<T = unknown>(action: string, payload: Record<string, unknown>): Promise<T>;\n  getSupportedFeatures(): string[];\n  getStats(): Record<string, unknown>;\n  resetStats(): void;\n};\n\nexport default buildingAIAdaptorService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/buildingai-adaptor.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/buildingai-client.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·······`","line":307,"column":22,"nodeType":null,"messageId":"insert","endLine":307,"endColumn":22,"fix":{"range":[7217,7217],"text":"\n       "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * BuildingAI Sidecar Client Service\n *\n * BFF层到BuildingAI侧车的调用封装\n * 提供统一的AI推理接口、MCP调用、知识库检索等能力\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\nimport logger from '../utils/logger.js';\n\ninterface BuildingAIConfig {\n  baseURL: string;\n  timeout: number;\n  apiPrefix: string;\n  healthCheckInterval?: number;\n}\n\ninterface ChatMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\ninterface ChatRequest {\n  model: string;\n  messages: ChatMessage[];\n  temperature?: number;\n  max_tokens?: number;\n  stream?: boolean;\n}\n\ninterface ChatResponse {\n  id: string;\n  model: string;\n  choices: Array<{\n    message: ChatMessage;\n    finish_reason: string;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\ninterface HealthStatus {\n  status: 'ok' | 'degraded' | 'down';\n  uptime: number;\n  timestamp: string;\n}\n\ninterface MCPToolCall {\n  tool: string;\n  parameters: Record<string, unknown>;\n}\n\ninterface MCPToolResponse {\n  tool: string;\n  result: unknown;\n  error?: string;\n}\n\ninterface KnowledgeBaseQuery {\n  query: string;\n  topK?: number;\n  filters?: Record<string, unknown>;\n}\n\ninterface KnowledgeBaseResult {\n  chunks: Array<{\n    content: string;\n    score: number;\n    metadata: Record<string, unknown>;\n  }>;\n}\n\ninterface NormalizedError extends Error {\n  code?: string;\n  httpStatus?: number;\n  details?: Record<string, unknown>;\n}\n\nclass BuildingAIClientService {\n  private client: AxiosInstance;\n  private config: BuildingAIConfig;\n  private isHealthy: boolean = false;\n  private lastHealthCheck: Date | null = null;\n\n  constructor(config?: Partial<BuildingAIConfig>) {\n    this.config = {\n      baseURL: process.env.BUILDINGAI_BASE_URL || 'http://localhost:4090',\n      timeout: parseInt(process.env.BUILDINGAI_TIMEOUT || '30000'),\n      apiPrefix: process.env.BUILDINGAI_API_PREFIX || '/api',\n      healthCheckInterval: parseInt(process.env.BUILDINGAI_HEALTH_CHECK_INTERVAL || '60000'),\n      ...config\n    };\n\n    this.client = axios.create({\n      baseURL: `${this.config.baseURL}${this.config.apiPrefix}`,\n      timeout: this.config.timeout,\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': 'BFF/1.0.0'\n      }\n    });\n\n    // 请求拦截器：添加日志和认证\n    this.client.interceptors.request.use(\n      (config) => {\n        const requestId = this.generateRequestId();\n        config.headers['X-Request-ID'] = requestId;\n\n        logger.debug('BuildingAI Request', {\n          requestId,\n          method: config.method,\n          url: config.url,\n          hasData: !!config.data\n        });\n\n        return config;\n      },\n      (error) => {\n        logger.error('BuildingAI Request Error', error);\n        return Promise.reject(error);\n      }\n    );\n\n    // 响应拦截器：统一错误处理\n    this.client.interceptors.response.use(\n      (response) => {\n        logger.debug('BuildingAI Response', {\n          requestId: response.config.headers['X-Request-ID'],\n          status: response.status,\n          hasData: !!response.data\n        });\n        return response;\n      },\n      (error) => {\n        const requestId = error.config?.headers?.['X-Request-ID'];\n        logger.error('BuildingAI Response Error', {\n          requestId,\n          message: error.message,\n          status: error.response?.status,\n          data: error.response?.data\n        });\n        return Promise.reject(this.normalizeError(error));\n      }\n    );\n\n    // 启动健康检查\n    this.startHealthCheck();\n  }\n\n  /**\n   * 健康检查\n   */\n  async healthCheck(): Promise<HealthStatus> {\n    try {\n      const response = await this.client.get<HealthStatus>('/health');\n      this.isHealthy = response.data.status === 'ok';\n      this.lastHealthCheck = new Date();\n\n      logger.info('BuildingAI Health Check', {\n        status: response.data.status,\n        healthy: this.isHealthy\n      });\n\n      return response.data;\n    } catch (error) {\n      this.isHealthy = false;\n      this.lastHealthCheck = new Date();\n\n      logger.error('BuildingAI Health Check Failed', error);\n\n      return {\n        status: 'down',\n        uptime: 0,\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * 统一推理接口：Chat\n   */\n  async chat(request: ChatRequest): Promise<ChatResponse> {\n    if (!this.isHealthy) {\n      logger.warn('BuildingAI service is unhealthy, attempting request anyway');\n    }\n\n    try {\n      const response = await this.client.post<ChatResponse>('/chat/completions', request);\n      return response.data;\n    } catch (error) {\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * 统一推理接口：Completions (SSE流式)\n   *\n   * 注意：SSE流式需要特殊处理，这里返回EventSource或可读流\n   */\n  async chatStream(request: ChatRequest): Promise<ReadableStream> {\n    if (!this.isHealthy) {\n      logger.warn('BuildingAI service is unhealthy, attempting stream anyway');\n    }\n\n    try {\n      const response = await this.client.post(\n        '/chat/completions',\n        { ...request, stream: true },\n        { responseType: 'stream' }\n      );\n\n      return response.data;\n    } catch (error) {\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * MCP工具调用\n   */\n  async invokeMCPTool(toolCall: MCPToolCall): Promise<MCPToolResponse> {\n    try {\n      const response = await this.client.post<MCPToolResponse>('/mcp/invoke', toolCall);\n      return response.data;\n    } catch (error) {\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * 知识库检索\n   */\n  async queryKnowledgeBase(query: KnowledgeBaseQuery): Promise<KnowledgeBaseResult> {\n    try {\n      const response = await this.client.post<KnowledgeBaseResult>('/kb/query', query);\n      return response.data;\n    } catch (error) {\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * 获取可用模型列表\n   */\n  async listModels(): Promise<Array<{ id: string; name: string; provider: string }>> {\n    try {\n      const response = await this.client.get('/models');\n      return response.data;\n    } catch (error) {\n      throw this.normalizeError(error);\n    }\n  }\n\n  /**\n   * 获取服务状态\n   */\n  getStatus() {\n    return {\n      healthy: this.isHealthy,\n      lastHealthCheck: this.lastHealthCheck,\n      baseURL: this.config.baseURL\n    };\n  }\n\n  // ============ 私有方法 ============\n\n  /**\n   * 启动定期健康检查\n   */\n  private startHealthCheck() {\n    // 立即执行一次\n    this.healthCheck().catch((err) => {\n      logger.error('Initial health check failed', err);\n    });\n\n    // 定期检查\n    if (this.config.healthCheckInterval && this.config.healthCheckInterval > 0) {\n      setInterval(() => {\n        this.healthCheck().catch((err) => {\n          logger.error('Periodic health check failed', err);\n        });\n      }, this.config.healthCheckInterval);\n    }\n  }\n\n  /**\n   * 生成请求ID\n   */\n  private generateRequestId(): string {\n    return `bff_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  /**\n   * 统一错误格式\n   */\n  private normalizeError(error: unknown): NormalizedError {\n    const err = error as Record<string, unknown>;\n\n    if (err?.response) {\n      // BuildingAI返回的错误\n      const response = err.response as Record<string, unknown>;\n      const status = response.status as number;\n      const data = response.data as Record<string, unknown>;\n      const message = (data?.message as string) || (data?.error as string) || 'BuildingAI service error';\n\n      const normalizedError = new Error(message) as NormalizedError;\n      normalizedError.code = (data?.code as string) || `BUILDINGAI_${status}`;\n      normalizedError.httpStatus = status;\n      normalizedError.details = data;\n\n      return normalizedError;\n    } else if (err?.request) {\n      // 请求发送但无响应\n      const message = 'BuildingAI service unavailable';\n      const normalizedError = new Error(message) as NormalizedError;\n      normalizedError.code = 'BUILDINGAI_UNAVAILABLE';\n      normalizedError.httpStatus = 503;\n\n      return normalizedError;\n    } else {\n      // 其他错误\n      const errorInstance = error instanceof Error ? error : new Error(String(error));\n      return errorInstance as NormalizedError;\n    }\n  }\n}\n\n// 单例实例\nconst buildingAIClient = new BuildingAIClientService();\n\nexport default buildingAIClient;\nexport { BuildingAIClientService };\nexport type {\n  ChatMessage,\n  ChatRequest,\n  ChatResponse,\n  HealthStatus,\n  MCPToolCall,\n  MCPToolResponse,\n  KnowledgeBaseQuery,\n  KnowledgeBaseResult,\n  NormalizedError\n};\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cache-subscriber.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/cache-subscriber.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const cacheSubscriberService: {\n  getStatus: () => any;\n  invalidateCache: (namespace: string, pattern: string, reason: string) => Promise<void>;\n  updateVersion: (namespace: string) => Promise<string | number>;\n  triggerPreload: (namespace: string, items: any[], priority?: string) => Promise<void>;\n  broadcastHealthCheck: () => Promise<void>;\n  start: () => Promise<void> | void;\n  stop: () => Promise<void> | void;\n};\n\nexport default cacheSubscriberService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cache-subscriber.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/circuit-breaker.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/circuit-breaker.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const circuitBreakerService: {\n  getCircuitBreaker: (name: string, config?: any) => any;\n  execute: (\n    name: string,\n    operation: () => Promise<any>,\n    fallback?: ((error: any) => Promise<any>) | null,\n    config?: any\n  ) => Promise<any>;\n  getAllCircuitBreakerStates: () => any;\n  getCircuitBreakerState: (name: string) => any;\n  openCircuitBreaker: (name: string, reason?: string) => boolean;\n  closeCircuitBreaker: (name: string) => boolean;\n  resetCircuitBreaker: (name: string) => boolean;\n  getStats: () => any;\n  cleanupInactiveCircuitBreakers: (inactiveThresholdMs: number) => number;\n  healthCheck: () => Promise<{ status: string } & Record<string, any>>;\n};\n\nexport default circuitBreakerService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/circuit-breaker.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cmsCache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cmsFeature.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cmsProvider.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.where('id',·id)⏎········.first())·as·Provider` with `.where('id',·id).first())·as⏎········|·Provider⏎·······`","line":99,"column":55,"nodeType":null,"messageId":"replace","endLine":101,"endColumn":30,"fix":{"range":[2938,2993],"text":".where('id', id).first()) as\n        | Provider\n       "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎········.where('id',·id)⏎········.first())·as·Provider` with `.where('id',·id).first())·as⏎········|·Provider⏎·······`","line":169,"column":55,"nodeType":null,"messageId":"replace","endLine":171,"endColumn":30,"fix":{"range":[5776,5831],"text":".where('id', id).first()) as\n        | Provider\n       "}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8694,8697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8694,8697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":267,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8929,8932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8929,8932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9407,9410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9407,9410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":281,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9540,9543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9540,9543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import { db } from '../config/database.js';\nimport cmsCacheService from './cmsCache.service.js';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport crypto from 'crypto';\nimport axios from 'axios';\nimport type { Knex } from 'knex';\nimport type {\n  Provider,\n  ProviderWithSecret,\n  ProviderQueryOptions,\n  ProviderListResponse,\n  CreateProviderData,\n  UpdateProviderData,\n  ProviderSecret,\n  EncryptedData,\n  TestResult,\n  ProviderStats,\n  BatchTestResult,\n  CmsCacheService\n} from '../types/cms-provider.types.js';\n\nclass CmsProviderService {\n  private readonly ENCRYPTION_ALGORITHM = 'aes-256-gcm';\n  private readonly ENCRYPTION_KEY =\n    process.env.PROVIDER_SECRET_KEY || crypto.randomBytes(32).toString('hex');\n  private readonly CONNECT_TIMEOUT = 10000;\n\n  async getProviders(options: ProviderQueryOptions = {}): Promise<ProviderListResponse> {\n    const {\n      page = 1,\n      limit = 20,\n      type,\n      status,\n      enabled,\n      search,\n      sortBy = 'created_at',\n      sortOrder = 'desc'\n    } = options;\n\n    try {\n      let query: Knex.QueryBuilder = db('provider_endpoints').select([\n        'id',\n        'name',\n        'description',\n        'type',\n        'base_url',\n        'weight',\n        'timeout',\n        'retry',\n        'enabled',\n        'status',\n        'last_tested_at',\n        'last_test_result',\n        'created_by',\n        'created_at',\n        'updated_at'\n      ]);\n\n      if (type) query = query.where('type', type);\n      if (status) query = query.where('status', status);\n      if (enabled !== undefined) query = query.where('enabled', enabled);\n      if (search) {\n        query = query.where(function (this: Knex.QueryBuilder) {\n          this.where('name', 'like', `%${search}%`).orWhere('description', 'like', `%${search}%`);\n        });\n      }\n      if (sortBy) query = query.orderBy(sortBy, sortOrder);\n\n      const offset = (page - 1) * limit;\n      const totalCount = (await query.clone().clearSelect().count('* as count')) as Array<{\n        count: number;\n      }>;\n      const providers = (await query.limit(limit).offset(offset)) as Provider[];\n\n      const sanitizedProviders = providers.map((p) => ({\n        ...p,\n        last_test_result: this.sanitizeTestResult(p.last_test_result)\n      }));\n\n      return {\n        providers: sanitizedProviders,\n        pagination: {\n          current: page,\n          pageSize: limit,\n          total: parseInt(String(totalCount[0].count)),\n          totalPages: Math.ceil(totalCount[0].count / limit)\n        }\n      };\n    } catch (error) {\n      logger.error('[CmsProviderService] Get providers failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '获取供应商列表失败');\n    }\n  }\n\n  async getProviderById(id: string): Promise<ProviderWithSecret> {\n    try {\n      const provider = (await db('provider_endpoints')\n        .where('id', id)\n        .first()) as Provider | undefined;\n      if (!provider) throw AppError.custom(ERROR_CODES.USER_NOT_FOUND, '供应商不存在');\n      const secret = await this.getProviderSecret(id);\n      return { ...provider, secret: secret ? this.maskSecret(secret) : null };\n    } catch (error) {\n      if (AppError.isAppError?.(error)) throw error;\n      logger.error('[CmsProviderService] Get provider by ID failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '获取供应商详情失败');\n    }\n  }\n\n  async createProvider(data: CreateProviderData, userId: string): Promise<Provider> {\n    try {\n      const [provider] = (await db('provider_endpoints')\n        .insert({\n          ...data,\n          created_by: userId,\n          created_at: new Date(),\n          updated_at: new Date()\n        })\n        .returning('*')) as Provider[];\n      if (data.secret) await this.saveProviderSecret(String(provider.id), data.secret);\n      await (cmsCacheService as unknown as CmsCacheService).invalidateScope('providers');\n      logger.info(`[CmsProviderService] Provider created: ${provider.id}`);\n      return provider;\n    } catch (error) {\n      logger.error('[CmsProviderService] Create provider failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '创建供应商失败');\n    }\n  }\n\n  async updateProvider(\n    id: string,\n    updateData: UpdateProviderData,\n    userId: string\n  ): Promise<Provider> {\n    try {\n      const [updated] = (await db('provider_endpoints')\n        .where('id', id)\n        .update({ ...updateData, updated_at: new Date() })\n        .returning('*')) as Provider[];\n      if (updateData.secret !== undefined) {\n        if (updateData.secret) await this.saveProviderSecret(id, updateData.secret);\n        else await this.deleteProviderSecret(id);\n      }\n      await (cmsCacheService as unknown as CmsCacheService).invalidateScope('providers');\n      logger.info(`[CmsProviderService] Provider updated: ${id} by ${userId}`);\n      return updated;\n    } catch (error) {\n      logger.error('[CmsProviderService] Update provider failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '更新供应商失败');\n    }\n  }\n\n  async deleteProvider(id: string): Promise<void> {\n    try {\n      await db('provider_endpoints').where('id', id).del();\n      await this.deleteProviderSecret(id);\n      await (cmsCacheService as unknown as CmsCacheService).invalidateScope('providers');\n      logger.info(`[CmsProviderService] Provider deleted: ${id}`);\n    } catch (error) {\n      logger.error('[CmsProviderService] Delete provider failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '删除供应商失败');\n    }\n  }\n\n  async testProvider(id: string, userId: string): Promise<TestResult> {\n    try {\n      const provider = (await db('provider_endpoints')\n        .where('id', id)\n        .first()) as Provider | undefined;\n      if (!provider) throw AppError.custom(ERROR_CODES.USER_NOT_FOUND, '供应商不存在');\n\n      const start = Date.now();\n      let success = false;\n      let message = 'OK';\n      try {\n        const secret = await this.getProviderSecret(id);\n        await axios.get(provider.base_url, {\n          timeout: this.CONNECT_TIMEOUT,\n          headers: secret ? { Authorization: `Bearer ${secret}` } : undefined\n        });\n        success = true;\n      } catch (err) {\n        const error = err as Error;\n        success = false;\n        message = error?.message || '连接失败';\n      }\n\n      const responseTime = Date.now() - start;\n      const testResult: TestResult = {\n        success,\n        responseTime,\n        message,\n        timestamp: new Date().toISOString()\n      };\n\n      await db('provider_endpoints')\n        .where('id', id)\n        .update({\n          last_tested_at: new Date(),\n          last_test_result: JSON.stringify(testResult),\n          updated_at: new Date()\n        });\n\n      return testResult;\n    } catch (error) {\n      logger.error('[CmsProviderService] Test provider failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '测试供应商失败');\n    }\n  }\n\n  async getProviderSecret(providerId: string): Promise<string | null> {\n    try {\n      const secretRecord = (await db('provider_secrets')\n        .where('provider_id', providerId)\n        .first()) as ProviderSecret | undefined;\n\n      if (!secretRecord) return null;\n      const encrypted_secret = secretRecord.encrypted_secret;\n      const iv = secretRecord.iv;\n      return this.decryptSecret(encrypted_secret, iv);\n    } catch (error) {\n      logger.error('[CmsProviderService] Get provider secret failed:', error);\n      return null;\n    }\n  }\n\n  async saveProviderSecret(providerId: string, secret: string): Promise<void> {\n    try {\n      const { encrypted, iv } = this.encryptSecret(secret);\n      await db('provider_secrets')\n        .insert({\n          provider_id: providerId,\n          encrypted_secret: encrypted,\n          iv,\n          created_at: new Date(),\n          updated_at: new Date()\n        })\n        .onConflict()\n        .merge();\n    } catch (error) {\n      logger.error('[CmsProviderService] Save provider secret failed:', error);\n      throw error;\n    }\n  }\n\n  async deleteProviderSecret(providerId: string): Promise<void> {\n    try {\n      await db('provider_secrets').where('provider_id', providerId).del();\n    } catch (error) {\n      logger.error('[CmsProviderService] Delete provider secret failed:', error);\n    }\n  }\n\n  encryptSecret(secret: string): EncryptedData {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipher(\n      this.ENCRYPTION_ALGORITHM,\n      Buffer.from(this.ENCRYPTION_KEY, 'hex')\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (cipher as any).setAAD(Buffer.from('provider-secret'));\n    let encrypted = cipher.update(secret, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const tag = (cipher as any).getAuthTag();\n    return { encrypted: encrypted + ':' + tag.toString('hex'), iv: iv.toString('hex') };\n  }\n\n  decryptSecret(encryptedSecret: string, iv: string): string | null {\n    try {\n      const [encrypted, tag] = encryptedSecret.split(':');\n      const decipher = crypto.createDecipher(\n        this.ENCRYPTION_ALGORITHM,\n        Buffer.from(this.ENCRYPTION_KEY, 'hex')\n      );\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (decipher as any).setAAD(Buffer.from('provider-secret'));\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (decipher as any).setAuthTag(Buffer.from(tag, 'hex'));\n      let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n    } catch (error) {\n      logger.error('[CmsProviderService] Decrypt secret failed:', error);\n      return null;\n    }\n  }\n\n  maskSecret(secret: string | null): string | null {\n    if (!secret || secret.length < 8) return secret;\n    return secret.substring(0, 4) + '****' + secret.substring(secret.length - 4);\n  }\n\n  sanitizeTestResult(testResult: string | TestResult | null | undefined): TestResult | null {\n    if (!testResult) return null;\n    try {\n      const result: TestResult =\n        typeof testResult === 'string' ? (JSON.parse(testResult) as TestResult) : testResult;\n      if (result.details && result.details.headers) {\n        const headers = { ...result.details.headers };\n        delete headers.authorization;\n        delete headers['x-api-key'];\n        result.details.headers = headers;\n      }\n      return result;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async getProviderStats(): Promise<ProviderStats> {\n    try {\n      const stats = (await db('provider_endpoints')\n        .select(\n          db.raw('COUNT(*) as total'),\n          db.raw('COUNT(CASE WHEN enabled = true THEN 1 END) as enabled'),\n          db.raw(\"COUNT(CASE WHEN status = 'active' THEN 1 END) as active\"),\n          db.raw(\"COUNT(CASE WHEN status = 'error' THEN 1 END) as error\")\n        )\n        .first()) as ProviderStats | undefined;\n      return (\n        stats || {\n          total: 0,\n          enabled: 0,\n          active: 0,\n          error: 0\n        }\n      );\n    } catch (error) {\n      logger.error('[CmsProviderService] Get provider stats failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '获取供应商统计失败');\n    }\n  }\n\n  async testAllProviders(userId: string): Promise<BatchTestResult> {\n    try {\n      const providers = await this.getProviders({ limit: 1000 });\n      const results: BatchTestResult = {\n        total: providers.providers.length,\n        success: 0,\n        failed: 0,\n        details: []\n      };\n      for (const provider of providers.providers) {\n        try {\n          const testResult = await this.testProvider(String(provider.id), userId);\n          results.details.push({\n            id: provider.id,\n            name: provider.name,\n            success: testResult.success,\n            responseTime: testResult.responseTime,\n            error: testResult.success ? null : testResult.message\n          });\n          if (testResult.success) results.success++;\n          else results.failed++;\n        } catch (error) {\n          const err = error as Error;\n          results.details.push({\n            id: provider.id,\n            name: provider.name,\n            success: false,\n            error: err.message\n          });\n          results.failed++;\n        }\n      }\n      logger.info(\n        `[CmsProviderService] Batch test completed: ${results.success} success, ${results.failed} failed`\n      );\n      return results;\n    } catch (error) {\n      logger.error('[CmsProviderService] Batch test providers failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '批量测试供应商失败');\n    }\n  }\n}\n\nexport default new CmsProviderService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/commission.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/configCache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/configSnapshot.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `snapshotId:·number,·userId?:·number` with `⏎··snapshotId:·number,⏎··userId?:·number⏎`","line":136,"column":42,"nodeType":null,"messageId":"replace","endLine":136,"endColumn":77,"fix":{"range":[2548,2583],"text":"\n  snapshotId: number,\n  userId?: number\n"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 配置快照服务\n * 艹，这个tm负责配置的快照创建和回滚！\n */\n\nimport db from '../db/index.js';\n\n/**\n * 配置数据类型定义\n */\nexport type ConfigData = Record<string, unknown>;\n\n/**\n * 回滚操作返回结果\n */\nexport interface RollbackResult {\n  [key: string]: unknown;\n}\n\n/**\n * 配置快照接口\n */\nexport interface ConfigSnapshot {\n  id: number;\n  snapshot_name: string;\n  description?: string;\n  config_type: string;\n  config_ref?: string;\n  config_data: ConfigData;\n  created_by?: number;\n  created_at: Date;\n  is_rollback: boolean;\n  rollback_from_id?: number;\n}\n\n/**\n * 创建快照输入\n */\nexport interface CreateSnapshotInput {\n  snapshot_name: string;\n  description?: string;\n  config_type: string;\n  config_ref?: string;\n  config_data: ConfigData;\n  created_by?: number;\n}\n\n/**\n * 创建配置快照\n * @param input - 快照输入\n * @returns 创建的快照\n */\nexport async function createSnapshot(input: CreateSnapshotInput): Promise<ConfigSnapshot> {\n  const { snapshot_name, description, config_type, config_ref, config_data, created_by } = input;\n\n  const [id] = await db('config_snapshots').insert({\n    snapshot_name,\n    description,\n    config_type,\n    config_ref,\n    config_data: JSON.stringify(config_data),\n    created_by,\n    created_at: db.fn.now(),\n    is_rollback: false\n  });\n\n  console.log(`[SNAPSHOT] 快照创建成功: ${snapshot_name} (ID: ${id})`);\n\n  const snapshot = await getSnapshotById(id);\n  if (!snapshot) {\n    throw new Error('创建快照后读取失败');\n  }\n\n  return snapshot;\n}\n\n/**\n * 根据ID获取快照\n * @param id - 快照ID\n * @returns 快照或null\n */\nexport async function getSnapshotById(id: number): Promise<ConfigSnapshot | null> {\n  const row = await db('config_snapshots').where({ id }).first();\n\n  if (!row) {\n    return null;\n  }\n\n  return {\n    ...row,\n    config_data: JSON.parse(row.config_data)\n  };\n}\n\n/**\n * 列出快照\n * @param options - 查询选项\n * @returns 快照列表\n */\nexport async function listSnapshots(options: {\n  config_type?: string;\n  config_ref?: string;\n  limit?: number;\n  offset?: number;\n}): Promise<ConfigSnapshot[]> {\n  const { config_type, config_ref, limit = 50, offset = 0 } = options;\n\n  let query = db('config_snapshots')\n    .select('*')\n    .orderBy('created_at', 'desc')\n    .limit(limit)\n    .offset(offset);\n\n  if (config_type) {\n    query = query.where({ config_type });\n  }\n\n  if (config_ref) {\n    query = query.where({ config_ref });\n  }\n\n  const rows = await query;\n\n  return rows.map((row) => ({\n    ...row,\n    config_data: JSON.parse(row.config_data)\n  }));\n}\n\n/**\n * 回滚到指定快照\n * @param snapshotId - 快照ID\n * @param userId - 操作用户ID\n * @returns 回滚后的配置数据\n */\nexport async function rollbackToSnapshot(snapshotId: number, userId?: number): Promise<RollbackResult> {\n  // 1. 获取快照\n  const snapshot = await getSnapshotById(snapshotId);\n  if (!snapshot) {\n    throw new Error(`快照不存在: ${snapshotId}`);\n  }\n\n  console.log(`[SNAPSHOT] 开始回滚到快照: ${snapshot.snapshot_name}`);\n\n  // 2. 根据配置类型执行回滚\n  let result: RollbackResult;\n\n  switch (snapshot.config_type) {\n    case 'provider':\n      // 艹，回滚Provider配置\n      result = await rollbackProviderConfig(snapshot);\n      break;\n\n    case 'announcement':\n      // 回滚公告配置\n      result = await rollbackAnnouncementConfig(snapshot);\n      break;\n\n    case 'banner':\n      // 回滚轮播图配置\n      result = await rollbackBannerConfig(snapshot);\n      break;\n\n    default:\n      throw new Error(`不支持的配置类型: ${snapshot.config_type}`);\n  }\n\n  // 3. 创建回滚记录快照\n  await createSnapshot({\n    snapshot_name: `[回滚] ${snapshot.snapshot_name}`,\n    description: `从快照ID ${snapshotId} 回滚`,\n    config_type: snapshot.config_type,\n    config_ref: snapshot.config_ref,\n    config_data: result,\n    created_by: userId\n  });\n\n  // 4. 标记原快照为已回滚\n  await db('config_snapshots').where({ id: snapshotId }).update({\n    is_rollback: true\n  });\n\n  console.log(`[SNAPSHOT] 回滚成功: ${snapshot.snapshot_name}`);\n\n  return result;\n}\n\n/**\n * 回滚Provider配置\n */\nasync function rollbackProviderConfig(snapshot: ConfigSnapshot): Promise<RollbackResult> {\n  const { config_ref, config_data } = snapshot;\n\n  if (!config_ref) {\n    throw new Error('Provider配置缺少config_ref');\n  }\n\n  // 艹，这里应该调用providerEndpoints.repo的更新方法\n  // 但为了避免循环依赖，暂时直接操作数据库\n  const affected = await db('provider_endpoints').where({ provider_ref: config_ref }).update({\n    provider_name: config_data.provider_name,\n    endpoint_url: config_data.endpoint_url,\n    credentials_encrypted: config_data.credentials_encrypted,\n    auth_type: config_data.auth_type,\n    updated_at: db.fn.now()\n  });\n\n  if (affected === 0) {\n    throw new Error(`Provider不存在: ${config_ref}`);\n  }\n\n  return config_data as RollbackResult;\n}\n\n/**\n * 回滚公告配置\n */\nasync function rollbackAnnouncementConfig(snapshot: ConfigSnapshot): Promise<RollbackResult> {\n  // TODO: 实现公告回滚（CMS-401实现后集成）\n  console.log('[SNAPSHOT] 公告回滚功能待实现');\n  return snapshot.config_data as RollbackResult;\n}\n\n/**\n * 回滚轮播图配置\n */\nasync function rollbackBannerConfig(snapshot: ConfigSnapshot): Promise<RollbackResult> {\n  // TODO: 实现轮播图回滚（CMS-402实现后集成）\n  console.log('[SNAPSHOT] 轮播图回滚功能待实现');\n  return snapshot.config_data as RollbackResult;\n}\n\n/**\n * 删除快照\n * @param id - 快照ID\n * @returns 是否成功删除\n */\nexport async function deleteSnapshot(id: number): Promise<boolean> {\n  const affected = await db('config_snapshots').where({ id }).delete();\n\n  if (affected > 0) {\n    console.log(`[SNAPSHOT] 快照删除成功: ${id}`);\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 自动创建Provider配置快照（在更新前调用）\n * @param providerRef - Provider引用ID\n * @param userId - 操作用户ID\n */\nexport async function autoSnapshotProvider(providerRef: string, userId?: number): Promise<void> {\n  // 读取当前配置\n  const currentConfig = await db('provider_endpoints').where({ provider_ref: providerRef }).first();\n\n  if (!currentConfig) {\n    return;\n  }\n\n  // 创建快照\n  await createSnapshot({\n    snapshot_name: `Auto: ${currentConfig.provider_name}`,\n    description: '自动快照（更新前）',\n    config_type: 'provider',\n    config_ref: providerRef,\n    config_data: currentConfig,\n    created_by: userId\n  });\n\n  console.log(`[SNAPSHOT] 已自动创建Provider快照: ${providerRef}`);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/contentAudit.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····taskId:·string,⏎····imageUrls:·string[]⏎··` with `taskId:·string,·imageUrls:·string[]`","line":86,"column":26,"nodeType":null,"messageId":"replace","endLine":89,"endColumn":3,"fix":{"range":[3186,3233],"text":"taskId: string, imageUrls: string[]"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1431,1434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1431,1434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import tencentcloud from 'tencentcloud-sdk-nodejs';\nimport COS from 'cos-nodejs-sdk-v5';\nimport logger from '../utils/logger.js';\nimport taskService from './task.service.js';\n\ninterface IAuditImageResult {\n  pass: boolean;\n  reason?: string;\n  auditResults?: Record<string, unknown>;\n}\n\ninterface IAuditTaskResult {\n  pass: boolean;\n  reasons?: string[];\n  auditResults?: IAuditImageResult[];\n}\n\ninterface IImsModerationResponse {\n  Data: Record<string, unknown>;\n}\n\n// 腾讯云IMS客户端类型定义\ninterface ImsClientType {\n  ImageModeration(params: Record<string, string>): Promise<IImsModerationResponse>;\n}\n\ntype COSClient = InstanceType<typeof COS>;\n\nclass ContentAuditService {\n  private readonly config = {\n    secretId: process.env.TENCENT_SECRET_ID,\n    secretKey: process.env.TENCENT_SECRET_KEY,\n    region: process.env.TENCENT_COS_REGION || 'ap-guangzhou',\n    bucket: process.env.TENCENT_COS_BUCKET\n  };\n\n  private imsClient: ImsClientType;\n  private cos: COSClient;\n\n  constructor() {\n    const tencentCloudSdk = tencentcloud as Record<string, unknown>;\n    const imsModule = tencentCloudSdk.ims as Record<string, unknown>;\n    const ImsClientConstructor =\n      ((imsModule?.v20201229 as Record<string, unknown>)?.Client as unknown) ||\n      ((imsModule?.v20200307 as Record<string, unknown>)?.Client as unknown);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.imsClient = new (ImsClientConstructor as any)({\n      credential: { secretId: this.config.secretId, secretKey: this.config.secretKey },\n      region: this.config.region\n    });\n    this.cos = new COS({ SecretId: this.config.secretId, SecretKey: this.config.secretKey });\n  }\n\n  async auditImage(imageUrl: string): Promise<IAuditImageResult> {\n    try {\n      logger.info(`[ContentAudit] 开始审核图片: ${imageUrl}`);\n      const params = { FileUrl: imageUrl, Biztype: 'default' };\n      const response = await this.imsClient.ImageModeration(params);\n      const result = response.Data as Record<string, unknown>;\n      const suggestion: string = (result?.Suggestion as string) || '';\n      const pass = suggestion === 'Pass';\n\n      let reason = '';\n      if (!pass) {\n        const labels: string[] = [];\n        const pornInfo = result?.PornInfo as Record<string, unknown> | undefined;\n        const terrorismInfo = result?.TerrorismInfo as Record<string, unknown> | undefined;\n        const illegalInfo = result?.IllegalInfo as Record<string, unknown> | undefined;\n        const adsInfo = result?.AdsInfo as Record<string, unknown> | undefined;\n\n        if (pornInfo?.HitFlag === 1) labels.push(`色情(${pornInfo.Label})`);\n        if (terrorismInfo?.HitFlag === 1) labels.push(`暴力(${terrorismInfo.Label})`);\n        if (illegalInfo?.HitFlag === 1) labels.push(`违法(${illegalInfo.Label})`);\n        if (adsInfo?.HitFlag === 1) labels.push(`广告(${adsInfo.Label})`);\n        reason = labels.join('; ');\n      }\n      return { pass, reason, auditResults: result };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ContentAudit] 审核图片失败: ${err.message}`, { imageUrl, error });\n      throw err;\n    }\n  }\n\n  async auditTaskResults(\n    taskId: string,\n    imageUrls: string[]\n  ): Promise<IAuditTaskResult> {\n    try {\n      const audits: IAuditImageResult[] = [];\n      const violationReasons: string[] = [];\n\n      for (const url of imageUrls) {\n        const single = await this.auditImage(url);\n        audits.push(single);\n        if (!single.pass && single.reason) violationReasons.push(single.reason);\n      }\n\n      if (violationReasons.length > 0) {\n        logger.warn(`[ContentAudit] 发现违规内容, 删除结果并回滚任务 taskId=${taskId}`);\n        await this.deleteResultImages(imageUrls);\n        const updateParams: Record<string, string> = {\n          errorMessage: `内容审核未通过: ${violationReasons.join('; ')}`\n        };\n        await taskService.updateStatus(taskId, 'failed', updateParams);\n        return { pass: false, reasons: violationReasons, auditResults: audits };\n      }\n\n      logger.info(`[ContentAudit] 任务审核通过 taskId=${taskId}`);\n      return { pass: true, auditResults: audits };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ContentAudit] 审核任务结果失败: ${err.message}`, { taskId, error });\n      throw err;\n    }\n  }\n\n  async deleteResultImages(imageUrls: string[]): Promise<void> {\n    const promises = imageUrls.map((url) => {\n      try {\n        const u = new URL(url);\n        const key = u.pathname.startsWith('/') ? u.pathname.slice(1) : u.pathname;\n        return new Promise<void>((resolve, reject) => {\n          this.cos.deleteObject(\n            { Bucket: this.config.bucket, Region: this.config.region, Key: key },\n            (err: Error | null, data: Record<string, unknown> | undefined) => {\n              if (err) {\n                logger.error(`[ContentAudit] 删除图片失败: ${key}`, err);\n                reject(err);\n              } else {\n                logger.info(`[ContentAudit] 图片已删除: ${key}`);\n                resolve();\n              }\n            }\n          );\n        });\n      } catch (e: unknown) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        logger.warn(`[ContentAudit] 跳过无法解析的URL: ${url}`);\n        return Promise.resolve();\n      }\n    });\n    await Promise.allSettled(promises);\n  }\n}\n\nexport default new ContentAuditService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cos-storage.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·?·Math.max(1,·Math.min(1000,·maxKeysValue))` with `⏎······?·Math.max(1,·Math.min(1000,·maxKeysValue))⏎·····`","line":441,"column":50,"nodeType":null,"messageId":"replace","endLine":441,"endColumn":94,"fix":{"range":[11779,11823],"text":"\n      ? Math.max(1, Math.min(1000, maxKeysValue))\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":484,"column":39,"nodeType":null,"messageId":"insert","endLine":484,"endColumn":39,"fix":{"range":[13147,13147],"text":"\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":485,"column":7,"nodeType":null,"messageId":"insert","endLine":485,"endColumn":7,"fix":{"range":[13217,13217],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":486,"column":1,"nodeType":null,"messageId":"insert","endLine":486,"endColumn":1,"fix":{"range":[13238,13238],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··············?·overallTotals.totalSize·/·overallTotals.totalFiles⏎·············` with `·?·overallTotals.totalSize·/·overallTotals.totalFiles`","line":609,"column":41,"nodeType":null,"messageId":"replace","endLine":611,"endColumn":14,"fix":{"range":[16935,17016],"text":" ? overallTotals.totalSize / overallTotals.totalFiles"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎············?·this.stats.lastCleanup.toISOString()⏎···········` with `·?·this.stats.lastCleanup.toISOString()`","line":661,"column":46,"nodeType":null,"messageId":"replace","endLine":663,"endColumn":12,"fix":{"range":[18409,18472],"text":" ? this.stats.lastCleanup.toISOString()"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎············?·this.stats.lastCleanup.toISOString()⏎···········` with `·?·this.stats.lastCleanup.toISOString()`","line":681,"column":46,"nodeType":null,"messageId":"replace","endLine":683,"endColumn":12,"fix":{"range":[19095,19158],"text":" ? this.stats.lastCleanup.toISOString()"}}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":7,"fixableWarningCount":0,"source":"import crypto from 'node:crypto';\nimport { createReadStream } from 'node:fs';\nimport logger from '../utils/logger.js';\nimport type {\n  FileCategory,\n  FileMetadata,\n  FileStorageClass,\n  StorageCleanupOptions,\n  StorageCleanupResult,\n  StorageDeleteResult,\n  StorageFileInfo,\n  StorageFileListResult,\n  StorageStats,\n  StorageUploadMetadata,\n  StorageUploadOptions,\n  StorageUploadResult,\n  UploadFileDescriptor,\n  UploadProgress\n} from '../types/file.types.js';\n\ntype UnknownRecord = Record<string, unknown>;\n\ninterface LifecycleRuleConfig {\n  days: number;\n  storageClass?: FileStorageClass;\n}\n\ntype LifecycleRuleMap = Partial<Record<FileCategory, LifecycleRuleConfig>>;\n\ninterface CosServiceConfig {\n  SecretId?: string;\n  SecretKey?: string;\n  Region: string;\n  Bucket?: string;\n  Domain?: string;\n  lifecycleRules: LifecycleRuleMap;\n}\n\ninterface CosClient {\n  uploadFile: (options: UnknownRecord) => Promise<UnknownRecord>;\n  downloadFile: (options: UnknownRecord) => Promise<UnknownRecord>;\n  deleteFile: (options: UnknownRecord) => Promise<{ deleted: boolean }>;\n  getFileList: (options: UnknownRecord) => Promise<UnknownRecord>;\n  getFileMeta: (options: UnknownRecord) => Promise<UnknownRecord>;\n  updateLifecycle: (rules: UnknownRecord[]) => Promise<{ success: boolean }>;\n}\n\n/**\n * COS对象存储服务\n *\n * 提供腾讯云COS集成，支持：\n * - 文件上传/下载\n * - 生命周期管理\n * - 中间文件清理\n * - 存储成本优化\n * - 多媒体处理\n */\ninterface StorageRuntimeStats {\n  totalFiles: number;\n  totalSize: number;\n  uploadCount: number;\n  downloadCount: number;\n  deleteCount: number;\n  lastCleanup: Date | null;\n}\n\ninterface StorageHealthStatus {\n  status: 'healthy' | 'unhealthy';\n  initialized: boolean;\n  config: {\n    region: string;\n    bucket?: string;\n  };\n  stats: {\n    uploadCount: number;\n    downloadCount: number;\n    deleteCount: number;\n    lastCleanup: string | null;\n  };\n  timestamp: string;\n  error?: string;\n}\n\nclass CosStorageService {\n  private config: CosServiceConfig;\n\n  private cosClient: CosClient | null = null;\n\n  private initialized = false;\n\n  private stats: StorageRuntimeStats;\n\n  constructor() {\n    this.config = {\n      SecretId: process.env.COS_SECRET_ID,\n      SecretKey: process.env.COS_SECRET_KEY,\n      Region: process.env.COS_REGION || 'ap-guangzhou',\n      Bucket: process.env.COS_BUCKET,\n      Domain: process.env.COS_DOMAIN,\n      // 生命周期配置\n      lifecycleRules: {\n        // 临时文件：7天后删除\n        temp: { days: 7 },\n        // 中间文件：30天后删除\n        intermediate: { days: 30 },\n        // 用户上传：90天后转为低频访问\n        userUpload: { days: 90, storageClass: 'Standard_IA' },\n        // 处理结果：180天后转为归档存储\n        result: { days: 180, storageClass: 'Archive' },\n        // 日志文件：30天后删除\n        log: { days: 30 }\n      }\n    };\n\n    // COS客户端（模拟实现）\n    this.cosClient = null;\n    this.initialized = false;\n\n    // 存储统计\n    this.stats = {\n      totalFiles: 0,\n      totalSize: 0,\n      uploadCount: 0,\n      downloadCount: 0,\n      deleteCount: 0,\n      lastCleanup: null\n    };\n  }\n\n  /**\n   * 初始化COS服务\n   */\n  async initialize() {\n    if (this.initialized) {\n      logger.warn('[CosStorage] COS服务已初始化');\n      return;\n    }\n\n    try {\n      // 验证配置\n      this.validateConfig();\n\n      // 初始化COS客户端（模拟）\n      this.cosClient = this.createCosClient();\n\n      // 设置生命周期规则\n      await this.setupLifecycleRules();\n\n      this.initialized = true;\n      logger.info('[CosStorage] COS服务初始化成功');\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] COS服务初始化失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 验证配置\n   * @private\n   */\n  validateConfig() {\n    const missing: string[] = [];\n    if (!this.config.SecretId) missing.push('SecretId');\n    if (!this.config.SecretKey) missing.push('SecretKey');\n    if (!this.config.Region) missing.push('Region');\n    if (!this.config.Bucket) missing.push('Bucket');\n    if (missing.length > 0) {\n      throw new Error(`COS配置缺少必要参数: ${missing.join(', ')}`);\n    }\n  }\n\n  /**\n   * 创建COS客户端（模拟）\n   * @private\n   */\n  private createCosClient(): CosClient {\n    // 在实际项目中，这里会初始化真实的COS SDK\n    return {\n      uploadFile: async (options: UnknownRecord) => this.mockUploadFile(options),\n      downloadFile: async (options: UnknownRecord) => this.mockDownloadFile(options),\n      deleteFile: async (options: UnknownRecord) => this.mockDeleteFile(options),\n      getFileList: async (options: UnknownRecord) => this.mockGetFileList(options),\n      getFileMeta: async (options: UnknownRecord) => this.mockGetFileMeta(options),\n      updateLifecycle: async (rules: UnknownRecord[]) => this.mockUpdateLifecycle(rules)\n    };\n  }\n\n  private getCosClient(): CosClient {\n    if (!this.cosClient) {\n      throw new Error('COS client is not initialized');\n    }\n    return this.cosClient;\n  }\n\n  /**\n   * 设置生命周期规则\n   * @private\n   */\n  async setupLifecycleRules() {\n    try {\n      const rules = this.buildLifecycleRules();\n      const client = this.getCosClient();\n      await client.updateLifecycle(rules);\n      logger.info('[CosStorage] 生命周期规则设置完成');\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 设置生命周期规则失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 构建生命周期规则\n   * @returns {Array} 生命周期规则列表\n   * @private\n   */\n  buildLifecycleRules(): UnknownRecord[] {\n    const rules: UnknownRecord[] = [];\n\n    Object.entries(this.config.lifecycleRules ?? {}).forEach(([prefix, config]) => {\n      if (!config) return;\n      const rule: UnknownRecord = {\n        ID: `rule_${prefix}`,\n        Status: 'Enabled',\n        Filter: {\n          Prefix: `${prefix}/`\n        },\n        Transitions: [] as UnknownRecord[]\n      };\n\n      if (config.storageClass) {\n        (rule.Transitions as UnknownRecord[]).push({\n          Days: config.days,\n          StorageClass: config.storageClass\n        });\n      }\n\n      // 删除规则\n      if (!config.storageClass || config.storageClass === 'Archive') {\n        rule.Expiration = {\n          Days: (config.days || 0) + (config.storageClass === 'Archive' ? 365 : 0)\n        };\n      }\n\n      rules.push(rule);\n    });\n\n    return rules;\n  }\n\n  /**\n   * 上传文件\n   * @param {Object} options - 上传选项\n   * @returns {Promise<Object>} 上传结果\n   */\n  async uploadFile(options: StorageUploadOptions): Promise<StorageUploadResult> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const { file, category, metadata = {}, key } = options;\n    if (!file || typeof file.name !== 'string' || typeof file.size !== 'number') {\n      throw new Error('上传文件必须包含有效的 name 和 size');\n    }\n\n    const uploadTime = new Date().toISOString();\n    const fileMetadata: StorageUploadMetadata = {\n      ...metadata,\n      category,\n      uploadTime,\n      originalName: file.name,\n      fileSize: file.size,\n      fileType: file.type ?? 'application/octet-stream',\n      checksum: await this.calculateChecksum(file)\n    };\n\n    try {\n      const fileKey = key || this.generateFileKey(file.name, category);\n      logger.info(`[CosStorage] 开始上传文件: ${fileKey}`);\n\n      const client = this.getCosClient();\n      const onProgress = options.onProgress\n        ? (progress: UnknownRecord) => {\n            const percent =\n              typeof progress === 'number'\n                ? Number(progress)\n                : Number((progress as { percent?: number }).percent ?? 0);\n            const loadedValue = (progress as { loaded?: number }).loaded;\n            const totalValue = (progress as { total?: number }).total;\n            const payload: UploadProgress = {\n              percent,\n              loaded: typeof loadedValue === 'number' ? loadedValue : 0,\n              total: typeof totalValue === 'number' ? totalValue : undefined\n            };\n            logger.debug(`[CosStorage] 上传进度 ${fileKey}: ${payload.percent}%`);\n            options.onProgress?.(payload);\n          }\n        : undefined;\n\n      await client.uploadFile({\n        file,\n        key: fileKey,\n        metadata: fileMetadata,\n        onProgress\n      });\n\n      this.stats.uploadCount++;\n      this.stats.totalFiles++;\n      this.stats.totalSize += file.size;\n\n      logger.info(`[CosStorage] 文件上传成功: ${fileKey}`);\n\n      return {\n        success: true,\n        key: fileKey,\n        url: this.getFileUrl(fileKey),\n        metadata: fileMetadata,\n        size: file.size,\n        uploadTime\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 文件上传失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 下载文件\n   * @param {string} key - 文件Key\n   * @param {Object} options - 下载选项\n   * @returns {Promise<Object>} 下载结果\n   */\n  async downloadFile(key: string, options: UnknownRecord = {}): Promise<UnknownRecord> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    try {\n      logger.info(`[CosStorage] 开始下载文件: ${key}`);\n\n      const downloadOptions: UnknownRecord = options ?? {};\n      const client = this.getCosClient();\n      const result = await client.downloadFile({\n        key,\n        range: downloadOptions.range,\n        onProgress: downloadOptions.onProgress\n      });\n\n      // 更新统计\n      this.stats.downloadCount++;\n\n      logger.info(`[CosStorage] 文件下载成功: ${key}`);\n\n      return {\n        success: true,\n        key,\n        data: result.data,\n        metadata: result.metadata,\n        size: result.size\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[CosStorage] 文件下载失败: ${key}`, err);\n      throw err;\n    }\n  }\n\n  /**\n   * 删除文件\n   * @param {string|string[]} keys - 文件Key或Key数组\n   * @returns {Promise<Object>} 删除结果\n   */\n  async deleteFile(keys: string | string[]): Promise<StorageDeleteResult> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const keyArray = Array.isArray(keys) ? keys : [keys];\n    const results: StorageDeleteResult['results'] = [];\n\n    try {\n      for (const key of keyArray) {\n        logger.info(`[CosStorage] 删除文件: ${key}`);\n\n        const client = this.getCosClient();\n        const result = await client.deleteFile({ key });\n\n        results.push({\n          key,\n          success: true,\n          deleted: Boolean(result.deleted)\n        });\n\n        if (result.deleted) {\n          // 更新统计\n          this.stats.deleteCount++;\n        }\n      }\n\n      logger.info(\n        `[CosStorage] 批量删除完成，成功: ${results.filter((r) => r.success).length}/${results.length}`\n      );\n\n      return {\n        success: true,\n        results,\n        total: keyArray.length,\n        deleted: results.filter((r) => r.deleted).length\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 文件删除失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 获取文件列表\n   * @param {Object} options - 查询选项\n   * @returns {Promise<Object>} 文件列表\n   */\n  async getFileList(options: UnknownRecord = {}): Promise<StorageFileListResult> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const listOptions: UnknownRecord = options ?? {};\n    const prefix = typeof listOptions.prefix === 'string' ? listOptions.prefix : '';\n    const category =\n      typeof listOptions.category === 'string' && this.isFileCategory(listOptions.category)\n        ? listOptions.category\n        : undefined;\n    const maxKeysValue =\n      typeof listOptions.maxKeys === 'number'\n        ? listOptions.maxKeys\n        : Number(listOptions.maxKeys ?? 1000);\n    const marker = typeof listOptions.marker === 'string' ? listOptions.marker : '';\n    const delimiter = typeof listOptions.delimiter === 'string' ? listOptions.delimiter : '';\n    const maxKeys = Number.isFinite(maxKeysValue) ? Math.max(1, Math.min(1000, maxKeysValue)) : 1000;\n\n    try {\n      const searchPrefix = category ? `${category}/` : prefix;\n\n      const client = this.getCosClient();\n      const result = (await client.getFileList({\n        prefix: searchPrefix,\n        maxKeys,\n        marker,\n        delimiter\n      })) as UnknownRecord;\n\n      const files: UnknownRecord[] = Array.isArray(result.files) ? result.files : [];\n      const directories = Array.isArray(result.directories)\n        ? result.directories.filter((item): item is string => typeof item === 'string')\n        : [];\n\n      return {\n        success: true,\n        files: files.map((file) => this.toStorageFileInfo(file)),\n        directories,\n        isTruncated: Boolean(result.isTruncated),\n        nextMarker: typeof result.nextMarker === 'string' ? result.nextMarker : null,\n        totalCount: files.length\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 获取文件列表失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 清理过期文件\n   * @param {Object} options - 清理选项\n   * @returns {Promise<Object>} 清理结果\n   */\n  async cleanupExpiredFiles(options: StorageCleanupOptions = {}): Promise<StorageCleanupResult> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const categories: FileCategory[] = Array.isArray(options.categories) && options.categories.length\n      ? options.categories\n      : ['temp', 'intermediate'];\n    const olderThanDays = options.olderThanDays ?? 7;\n    const dryRun = options.dryRun ?? false;\n    const batchSize = options.batchSize ?? 100;\n\n    try {\n      logger.info(`[CosStorage] 开始清理过期文件 ${dryRun ? '(干运行)' : ''}`);\n\n      const cleanupDate = new Date();\n      cleanupDate.setDate(cleanupDate.getDate() - olderThanDays);\n\n      let totalCleaned = 0;\n      let totalSize = 0;\n      const errors = [];\n\n      for (const category of categories) {\n        logger.info(`[CosStorage] 清理类别: ${category}`);\n\n        let marker = '';\n        let hasMore = true;\n\n        while (hasMore) {\n          const fileList = await this.getFileList({\n            category,\n            maxKeys: batchSize,\n            marker\n          });\n\n          const expiredFiles = fileList.files.filter(\n            (file) => new Date(file.lastModified) < cleanupDate\n          );\n\n          if (expiredFiles.length > 0) {\n            if (!dryRun) {\n              const deleteResult = await this.deleteFile(expiredFiles.map((file) => file.key));\n\n              const deletedCount = Number(deleteResult.deleted ?? 0);\n              totalCleaned += deletedCount;\n              totalSize += expiredFiles.reduce((sum, file) => sum + (file.size || 0), 0);\n\n              logger.info(`[CosStorage] 已删除 ${deletedCount} 个${category ?? '全部'}文件`);\n            } else {\n              totalCleaned += expiredFiles.length;\n              totalSize += expiredFiles.reduce((sum, file) => sum + (file.size || 0), 0);\n              logger.info(\n                `[CosStorage] [干运行] 将删除 ${expiredFiles.length} 个${category ?? '全部'}文件`\n              );\n            }\n          }\n\n          hasMore = Boolean(fileList.isTruncated);\n          marker = fileList.nextMarker || '';\n\n          // 避免API限制\n          if (hasMore) {\n            await this.sleep(100);\n          }\n        }\n      }\n\n      this.stats.lastCleanup = new Date();\n\n      const result = {\n        success: true,\n        totalCleaned,\n        totalSize,\n        categories,\n        olderThanDays,\n        dryRun,\n        cleanupDate: cleanupDate.toISOString()\n      };\n\n      logger.info(\n        `[CosStorage] 清理完成: ${totalCleaned}个文件, 释放空间: ${this.formatBytes(totalSize)}`\n      );\n\n      return result;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 清理过期文件失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 获取存储统计信息\n   * @returns {Promise<Object>} 统计信息\n   */\n  async getStorageStats(): Promise<StorageStats> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    try {\n      const categories: FileCategory[] = ['temp', 'intermediate', 'userUpload', 'result', 'log'];\n      const categoryStats = {} as StorageStats['categoryStats'];\n\n      for (const category of categories) {\n        const fileList = await this.getFileList({ category, maxKeys: 1000 });\n        const files = fileList.files;\n        const totalSize = files.reduce((sum, file) => sum + (file.size || 0), 0);\n        categoryStats[category] = {\n          count: files.length,\n          totalSize,\n          averageSize: files.length > 0 ? totalSize / files.length : 0\n        };\n      }\n\n      const overallTotals = Object.values(categoryStats).reduce(\n        (acc, stat) => {\n          acc.totalFiles += stat.count;\n          acc.totalSize += stat.totalSize;\n          return acc;\n        },\n        { totalFiles: 0, totalSize: 0 }\n      );\n\n      return {\n        categoryStats,\n        overall: {\n          totalFiles: overallTotals.totalFiles,\n          totalSize: overallTotals.totalSize,\n          averageSize:\n            overallTotals.totalFiles > 0\n              ? overallTotals.totalSize / overallTotals.totalFiles\n              : 0\n        },\n        storageClassDistribution: await this.getStorageClassDistribution(),\n        lastCleanup: this.stats.lastCleanup ? this.stats.lastCleanup.toISOString() : null\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 获取存储统计失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 健康检查\n   * @returns {Promise<Object>} 健康状态\n   */\n  async healthCheck(): Promise<StorageHealthStatus> {\n    try {\n      if (!this.initialized) {\n        return {\n          status: 'unhealthy',\n          initialized: false,\n          config: {\n            region: this.config.Region,\n            bucket: this.config.Bucket\n          },\n          stats: {\n            uploadCount: 0,\n            downloadCount: 0,\n            deleteCount: 0,\n            lastCleanup: null\n          },\n          timestamp: new Date().toISOString(),\n          error: 'COS服务未初始化'\n        };\n      }\n\n      await this.getFileList({ maxKeys: 1 });\n\n      return {\n        status: 'healthy',\n        initialized: true,\n        config: {\n          region: this.config.Region,\n          bucket: this.config.Bucket\n        },\n        stats: {\n          uploadCount: this.stats.uploadCount,\n          downloadCount: this.stats.downloadCount,\n          deleteCount: this.stats.deleteCount,\n          lastCleanup: this.stats.lastCleanup\n            ? this.stats.lastCleanup.toISOString()\n            : null\n        },\n        timestamp: new Date().toISOString()\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[CosStorage] 健康检查失败:', err);\n      return {\n        status: 'unhealthy',\n        initialized: this.initialized,\n        config: {\n          region: this.config.Region,\n          bucket: this.config.Bucket\n        },\n        stats: {\n          uploadCount: this.stats.uploadCount,\n          downloadCount: this.stats.downloadCount,\n          deleteCount: this.stats.deleteCount,\n          lastCleanup: this.stats.lastCleanup\n            ? this.stats.lastCleanup.toISOString()\n            : null\n        },\n        timestamp: new Date().toISOString(),\n        error: err.message\n      };\n    }\n  }\n\n  // 辅助方法\n\n  /**\n   * 生成文件Key\n   * @param {string} originalName - 原始文件名\n   * @param {string} category - 文件分类\n   * @returns {string} 文件Key\n   * @private\n   */\n  generateFileKey(originalName: string, category: FileCategory): string {\n    const timestamp = Date.now();\n    const randomId = crypto.randomBytes(8).toString('hex');\n    const extension = originalName.split('.').pop();\n\n    return `${category}/${timestamp}_${randomId}.${extension}`;\n  }\n\n  /**\n   * 计算文件校验和\n   * @param {Object} file - 文件对象\n   * @returns {Promise<string>} MD5校验和\n   * @private\n   */\n  async calculateChecksum(file: UploadFileDescriptor): Promise<string> {\n    const hash = crypto.createHash('md5');\n\n    if (file.buffer) {\n      hash.update(file.buffer);\n      return hash.digest('hex');\n    }\n\n    if (!file.path) {\n      hash.update(`${file.name}-${file.size}`);\n      return hash.digest('hex');\n    }\n\n    return new Promise((resolve, reject) => {\n      const stream = createReadStream(file.path as string);\n      stream.on('data', (data: Buffer) => hash.update(data));\n      stream.on('end', () => resolve(hash.digest('hex')));\n      stream.on('error', reject);\n    });\n  }\n\n  /**\n   * 获取文件URL\n   * @param {string} key - 文件Key\n   * @returns {string} 文件URL\n   * @private\n   */\n  getFileUrl(key: string): string {\n    if (this.config.Domain) {\n      return `https://${this.config.Domain}/${key}`;\n    }\n    return `https://${this.config.Bucket}.cos.${this.config.Region}.myqcloud.com/${key}`;\n  }\n\n  private toStorageFileInfo(file: UnknownRecord): StorageFileInfo {\n    const key = typeof file.key === 'string' ? file.key : '';\n    const sizeRaw = (file as { size?: number }).size;\n    const lastModifiedRaw = (file as { lastModified?: string }).lastModified;\n    const etagRaw = (file as { etag?: string }).etag;\n    const storageClassRaw = (file as { storageClass?: string }).storageClass;\n\n    return {\n      key,\n      size: typeof sizeRaw === 'number' ? sizeRaw : 0,\n      lastModified:\n        typeof lastModifiedRaw === 'string' ? lastModifiedRaw : new Date().toISOString(),\n      etag: typeof etagRaw === 'string' ? etagRaw : '',\n      storageClass: this.toStorageClass(storageClassRaw),\n      category: this.extractCategory(key)\n    };\n  }\n\n  private toStorageClass(value: unknown): FileStorageClass {\n    if (value === 'Standard_IA' || value === 'Archive') {\n      return value;\n    }\n    return 'Standard';\n  }\n\n  private extractCategory(key: string): FileCategory | 'unknown' {\n    const parts = key.split('/');\n    const candidate = parts[0] || 'unknown';\n    return this.isFileCategory(candidate) ? candidate : 'unknown';\n  }\n\n  private isFileCategory(value: string): value is FileCategory {\n    return (['temp', 'intermediate', 'userUpload', 'result', 'log'] as FileCategory[]).includes(\n      value as FileCategory\n    );\n  }\n\n  /**\n   * 格式化字节数\n   * @param {number} bytes - 字节数\n   * @returns {string} 格式化后的大小\n   * @private\n   */\n  formatBytes(bytes: number): string {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  /**\n   * 获取存储类别分布\n   * @returns {Promise<Object>} 存储类别分布\n   * @private\n   */\n  async getStorageClassDistribution(): Promise<Record<FileStorageClass, number>> {\n    // 模拟实现\n    return {\n      Standard: 60,\n      Standard_IA: 30,\n      Archive: 10\n    };\n  }\n\n  /**\n   * 延迟函数\n   * @param {number} ms - 延迟毫秒数\n   * @private\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  // 模拟方法（在实际项目中会被真实COS SDK调用替换）\n\n  async mockUploadFile(options: UnknownRecord): Promise<UnknownRecord> {\n    await this.sleep(Math.random() * 2000 + 1000);\n    return {\n      key: options.key,\n      etag: crypto.randomBytes(16).toString('hex'),\n      location: this.getFileUrl(options.key)\n    };\n  }\n\n  async mockDownloadFile(options: UnknownRecord): Promise<UnknownRecord> {\n    await this.sleep(Math.random() * 1000 + 500);\n    return {\n      data: Buffer.from('mock file data'),\n      metadata: { category: 'temp' },\n      size: 1024\n    };\n  }\n\n  async mockDeleteFile(options: UnknownRecord): Promise<{ deleted: boolean }> {\n    await this.sleep(100);\n    return { deleted: true };\n  }\n\n  async mockGetFileList(options: UnknownRecord): Promise<UnknownRecord> {\n    await this.sleep(500);\n    const mockFiles: UnknownRecord[] = [];\n    const maxKeys = Number(options.maxKeys ?? 10) || 10;\n    const count = Math.min(maxKeys, 50);\n    const prefix = typeof options.prefix === 'string' ? options.prefix : 'temp/';\n\n    for (let i = 0; i < count; i++) {\n      mockFiles.push({\n        key: `${prefix}file_${i}.jpg`,\n        size: Math.floor(Math.random() * 1000000) + 100000,\n        lastModified: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),\n        etag: crypto.randomBytes(16).toString('hex'),\n        storageClass: 'Standard'\n      });\n    }\n\n    return {\n      files: mockFiles,\n      isTruncated: count >= maxKeys,\n      nextMarker: count >= maxKeys ? 'next_marker' : null\n    };\n  }\n\n  async mockGetFileMeta(options: UnknownRecord): Promise<UnknownRecord> {\n    return {\n      key: options.key,\n      size: 1024000,\n      lastModified: new Date().toISOString(),\n      metadata: { category: 'temp' }\n    };\n  }\n\n  async mockUpdateLifecycle(rules: UnknownRecord[]): Promise<{ success: boolean }> {\n    await this.sleep(1000);\n    return { success: true };\n  }\n}\n\nconst cosStorageService = new CosStorageService();\n\nexport default cosStorageService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cos-sts.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cos.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/cronJobs.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/db-optimization.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·········`","line":262,"column":18,"nodeType":null,"messageId":"insert","endLine":262,"endColumn":18,"fix":{"range":[7558,7558],"text":"\n         "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 数据库优化服务 - TypeScript ESM版本\n * 艹！提供EXPLAIN分析、性能监控和优化建议\n */\n\nimport logger from '../utils/logger.js';\nimport dbMetrics from '../utils/db-metrics.js';\nimport type { MetricsReport, SlowQuery, ExplainAnalysis } from '../utils/db-metrics.js';\nimport { db } from '../config/database.js';\n\ninterface QueryAnalysis {\n  sql: string;\n  analysis: Record<string, unknown>;\n  timestamp: Date;\n  analysisTime: number;\n}\n\ninterface IndexSuggestion {\n  table: string;\n  columns: string[];\n  type: string;\n  reason: string;\n  priority: string;\n}\n\ninterface TableIndexInfo {\n  keyName: string;\n  columnName: string;\n  [key: string]: unknown;\n}\n\n/**\n * 数据库优化服务\n *\n * 提供EXPLAIN分析、性能监控和优化建议\n */\nclass DatabaseOptimizationService {\n  private baselineQueries: Map<string, QueryAnalysis>;\n  private analysisQueue: ExplainAnalysis[];\n  private isAnalyzing: boolean;\n\n  constructor() {\n    this.baselineQueries = new Map();\n    this.analysisQueue = [];\n    this.isAnalyzing = false;\n  }\n\n  /**\n   * 分析查询执行计划\n   * @param {string} sql - SQL语句\n   * @param {Array} params - 参数\n   * @returns {Promise<Object>} 分析结果\n   */\n  async analyzeQueryExecution(sql: string, params: Array<unknown> = []): Promise<ExplainAnalysis> {\n    try {\n      logger.info('[DB Optimization] 开始分析查询', {\n        sql: this.sanitizeSQL(sql)\n      });\n\n      const startTime = Date.now();\n\n      // 执行EXPLAIN\n      const result = await dbMetrics.analyzeQuery(sql, params);\n\n      const analysisTime = Date.now() - startTime;\n\n      // 缓存分析结果\n      const queryHash = this.hashQuery(sql);\n      this.baselineQueries.set(queryHash, {\n        sql: this.sanitizeSQL(sql),\n        analysis: result,\n        timestamp: new Date(),\n        analysisTime\n      });\n\n      logger.info('[DB Optimization] 查询分析完成', {\n        queryHash,\n        analysisTime: `${analysisTime}ms`,\n        performance: result.performance.level,\n        recommendations: result.recommendations.length\n      });\n\n      return result;\n    } catch (error) {\n      logger.error('[DB Optimization] 查询分析失败', {\n        sql: this.sanitizeSQL(sql),\n        error: (error as Error).message\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * 批量分析核心查询\n   * @returns {Promise<Array>} 分析结果数组\n   */\n  async analyzeCoreQueries() {\n    const coreQueries = [\n      {\n        name: '用户查询',\n        sql: 'SELECT id, phone, isMember, quota_remaining FROM users WHERE id = ?',\n        params: ['sample_user_id']\n      },\n      {\n        name: '任务列表查询',\n        sql: 'SELECT id, userId, status, type, created_at FROM tasks WHERE userId = ? ORDER BY created_at DESC LIMIT ?',\n        params: ['sample_user_id', 10]\n      },\n      {\n        name: '配额事务查询',\n        sql: 'SELECT * FROM quota_transactions WHERE task_id = ? AND phase = ?',\n        params: ['sample_task_id', 'reserved']\n      },\n      {\n        name: '特征定义查询',\n        sql: 'SELECT * FROM feature_definitions WHERE feature_id = ? AND is_enabled = ?',\n        params: ['sample_feature', true]\n      }\n    ];\n\n    const results = [];\n\n    for (const query of coreQueries) {\n      try {\n        const analysis = await this.analyzeQueryExecution(query.sql, query.params);\n        results.push({\n          name: query.name,\n          ...analysis,\n          sql: query.sql\n        });\n      } catch (error) {\n        logger.error(`[DB Optimization] ${query.name} 分析失败`, error);\n        results.push({\n          name: query.name,\n          error: (error as Error).message,\n          sql: this.sanitizeSQL(query.sql)\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * 获取索引建议\n   * @returns {Promise<Array>} 索引建议列表\n   */\n  async getIndexSuggestions(): Promise<IndexSuggestion[]> {\n    const suggestions: IndexSuggestion[] = [];\n\n    try {\n      // 检查核心表的索引情况\n      const tables = ['users', 'tasks', 'quota_transactions', 'feature_definitions'];\n\n      for (const table of tables) {\n        const indexes = await this.getTableIndexes(table);\n        const tableSuggestions = this.generateIndexSuggestions(table, indexes);\n        suggestions.push(...tableSuggestions);\n      }\n    } catch (error) {\n      logger.error('[DB Optimization] 获取索引建议失败', error);\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * 获取表的索引信息\n   * @param {string} tableName - 表名\n   */\n  async getTableIndexes(tableName: string): Promise<TableIndexInfo[]> {\n    try {\n      const result = await db.raw(`\n        SHOW INDEX FROM ${tableName}\n      `);\n\n      return result.map((row: Record<string, unknown>) => ({\n        table: String(row.Table ?? tableName),\n        nonUnique: row.Non_unique === 0,\n        keyName: String(row.Key_name ?? ''),\n        seqInIndex: Number(row.Seq_in_index ?? 0),\n        columnName: String(row.Column_name ?? ''),\n        collation: row.Collation,\n        cardinality: row.Cardinality,\n        subPart: row.Sub_part,\n        packed: row.Packed,\n        null: row.Null,\n        indexType: row.Index_type,\n        comment: row.Comment,\n        indexComment: row.Index_comment,\n        visible: row.Visible\n      }));\n    } catch (error) {\n      logger.error(`[DB Optimization] 获取表 ${tableName} 索引失败`, error);\n      return [];\n    }\n  }\n\n  /**\n   * 生成索引建议\n   * @param {string} table - 表名\n   * @param {Array} indexes - 现有索引\n   */\n  generateIndexSuggestions(table: string, indexes: TableIndexInfo[]): IndexSuggestion[] {\n    const suggestions: IndexSuggestion[] = [];\n    const indexMap = new Map<string, string[]>();\n\n    // 创建索引映射\n    indexes.forEach((idx) => {\n      const keyName = idx.keyName || '';\n      const columnName = idx.columnName || '';\n      if (!keyName || !columnName) {\n        return;\n      }\n      if (!indexMap.has(keyName)) {\n        indexMap.set(keyName, []);\n      }\n      const columns = indexMap.get(keyName);\n      if (columns) {\n        columns.push(columnName);\n      }\n    });\n\n    // 建议的核心索引\n    const recommendedIndexes: Record<\n      string,\n      Array<{ columns: string[]; type: string; reason: string }>\n    > = {\n      users: [\n        { columns: ['id'], type: 'PRIMARY', reason: '主键索引' },\n        { columns: ['phone'], type: 'UNIQUE', reason: '登录查询' },\n        { columns: ['isMember', 'quota_remaining'], type: 'INDEX', reason: '会员和配额查询' },\n        { columns: ['created_at'], type: 'INDEX', reason: '时间排序' }\n      ],\n      tasks: [\n        { columns: ['id'], type: 'PRIMARY', reason: '主键索引' },\n        { columns: ['userId', 'created_at', 'id'], type: 'INDEX', reason: '用户任务列表' },\n        { columns: ['userId', 'status'], type: 'INDEX', reason: '用户状态筛选' },\n        { columns: ['status', 'created_at', 'id'], type: 'INDEX', reason: '状态时间排序' },\n        { columns: ['feature_id'], type: 'INDEX', reason: '功能筛选' },\n        { columns: ['vendorTaskId'], type: 'UNIQUE', reason: '外部任务ID唯一性' }\n      ],\n      quota_transactions: [\n        { columns: ['id'], type: 'PRIMARY', reason: '主键索引' },\n        { columns: ['task_id'], type: 'UNIQUE', reason: '任务唯一性' },\n        { columns: ['user_id'], type: 'INDEX', reason: '用户配额查询' },\n        { columns: ['phase'], type: 'INDEX', reason: '状态筛选' },\n        { columns: ['user_id', 'phase'], type: 'INDEX', reason: '用户状态组合查询' },\n        { columns: ['created_at'], type: 'INDEX', reason: '时间排序' }\n      ],\n      feature_definitions: [\n        { columns: ['feature_id'], type: 'PRIMARY', reason: '主键索引' },\n        { columns: ['is_enabled'], type: 'INDEX', reason: '启用状态筛选' },\n        { columns: ['pipeline_schema_ref'], type: 'INDEX', reason: 'Schema引用' }\n      ]\n    };\n\n    const recommended = recommendedIndexes[table] || [];\n\n    recommended.forEach((rec) => {\n      const exists = Array.from(indexMap.values()).some(\n        (cols) => cols.length === rec.columns.length && cols.every((col) => rec.columns.includes(col))\n      );\n\n      if (!exists) {\n        suggestions.push({\n          table,\n          columns: rec.columns,\n          type: rec.type,\n          reason: rec.reason,\n          priority: this.getIndexPriority(rec.type)\n        });\n      }\n    });\n\n    return suggestions;\n  }\n\n  /**\n   * 获取索引优先级\n   * @param {string} indexType - 索引类型\n   */\n  getIndexPriority(indexType: string): string {\n    const priorities: Record<string, string> = {\n      PRIMARY: 'high',\n      UNIQUE: 'high',\n      INDEX: 'medium'\n    };\n    return priorities[indexType] || 'low';\n  }\n\n  /**\n   * 生成数据库性能报告\n   * @returns {Promise<Object>} 性能报告\n   */\n  async generatePerformanceReport() {\n    try {\n      const startTime = Date.now();\n\n      const [coreQueriesAnalysis, indexSuggestions, metricsReport, slowQueries]: [\n        Array<Record<string, unknown>>,\n        IndexSuggestion[],\n        MetricsReport,\n        SlowQuery[]\n      ] = await Promise.all([\n        this.analyzeCoreQueries(),\n        this.getIndexSuggestions(),\n        Promise.resolve(dbMetrics.getMetricsReport()),\n        Promise.resolve(this.getRecentSlowQueries())\n      ]);\n\n      const reportTime = Date.now() - startTime;\n\n      const report = {\n        timestamp: new Date(),\n        generationTime: reportTime,\n        summary: {\n          coreQueriesCount: coreQueriesAnalysis.length,\n          indexSuggestionsCount: indexSuggestions.length,\n          slowQueriesCount: slowQueries.length,\n          healthStatus: metricsReport.health.status\n        },\n        coreQueries: coreQueriesAnalysis,\n        indexSuggestions,\n        metrics: metricsReport,\n        slowQueries,\n        recommendations: this.generateOverallRecommendations(\n          coreQueriesAnalysis,\n          indexSuggestions,\n          metricsReport\n        )\n      };\n\n      logger.info('[DB Optimization] 性能报告生成完成', {\n        reportTime: `${reportTime}ms`,\n        coreQueries: report.summary.coreQueriesCount,\n        indexSuggestions: report.summary.indexSuggestionsCount,\n        slowQueries: report.summary.slowQueriesCount\n      });\n\n      return report;\n    } catch (error) {\n      logger.error('[DB Optimization] 生成性能报告失败', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取最近的慢查询\n   */\n  getRecentSlowQueries(): SlowQuery[] {\n    return dbMetrics.getRecentSlowQueries(20);\n  }\n\n  /**\n   * 生成整体优化建议\n   */\n  generateOverallRecommendations(\n    queries: Array<Record<string, unknown>>,\n    indexes: IndexSuggestion[],\n    metrics: MetricsReport\n  ): Array<Record<string, unknown>> {\n    const recommendations: Array<Record<string, unknown>> = [];\n\n    // 连接池建议\n    const poolUtilization = Number(metrics.pool.utilization.replace('%', ''));\n    if (poolUtilization > 80) {\n      recommendations.push({\n        category: 'connection-pool',\n        priority: 'high',\n        title: '连接池利用率过高',\n        description: `当前连接池利用率为 ${metrics.pool.utilization}，建议增加连接池大小`,\n        action: '增加 DATABASE_POOL_MAX 环境变量'\n      });\n    }\n\n    // 慢查询建议\n    if (metrics.performance.slowQueriesCount > 10) {\n      recommendations.push({\n        category: 'slow-queries',\n        priority: 'high',\n        title: '慢查询数量过多',\n        description: `检测到 ${metrics.performance.slowQueriesCount} 个慢查询`,\n        action: '检查并优化慢查询，添加适当索引'\n      });\n    }\n\n    // 索引建议\n    const highPriorityIndexes = indexes.filter((idx) => idx.priority === 'high');\n    if (highPriorityIndexes.length > 0) {\n      recommendations.push({\n        category: 'indexes',\n        priority: 'high',\n        title: '缺少关键索引',\n        description: `发现 ${highPriorityIndexes.length} 个高优先级索引建议`,\n        action: '创建建议的索引以提升查询性能'\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 清理SQL语句中的敏感信息\n   */\n  sanitizeSQL(sql: string): string {\n    return dbMetrics.publicSanitize(sql);\n  }\n\n  /**\n   * 生成SQL哈希\n   */\n  hashQuery(sql: string): string {\n    return String(dbMetrics.publicHash(sql));\n  }\n\n  /**\n   * 执行定时分析任务\n   */\n  async scheduleAnalysis() {\n    if (this.isAnalyzing) {\n      return;\n    }\n\n    this.isAnalyzing = true;\n    try {\n      logger.info('[DB Optimization] 开始定时分析任务');\n\n      const report = await this.generatePerformanceReport();\n\n      // 这里可以将报告保存到文件或发送到监控系统\n      logger.info('[DB Optimization] 定时分析完成', {\n        healthStatus: report.summary.healthStatus,\n        recommendationsCount: report.recommendations.length\n      });\n    } catch (error) {\n      logger.error('[DB Optimization] 定时分析失败', error);\n    } finally {\n      this.isAnalyzing = false;\n    }\n  }\n}\n\nconst dbOptimizationService = new DatabaseOptimizationService();\n\nexport default dbOptimizationService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/distribution.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/distribution.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const distributionService: {\n  applyDistributor: (userId: string, data: any) => Promise<any>;\n  getDistributorStatus: (userId: string) => Promise<any>;\n  getDistributorDetail: (userId: string) => Promise<any>;\n  getDashboard: (userId: string) => Promise<any>;\n  getReferrals: (userId: string, options: any) => Promise<any>;\n  getCommissions: (userId: string, options: any) => Promise<any>;\n  getWithdrawals: (userId: string, options: any) => Promise<any>;\n  createWithdrawal: (userId: string, payload: any) => Promise<string | number>;\n};\n\nexport default distributionService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/distribution.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[258,261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[258,261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { db } from '../config/database.js';\nimport logger from '../utils/logger.js';\nimport { generateId } from '../utils/generator.js';\nimport encryptionUtils from '../utils/encryption.js';\nimport type { Knex } from 'knex';\n\ntype AnyObject = Record<string, any>;\n\ntype CountRow = {\n  count?: string | number | bigint | null;\n};\n\ntype SumRow = {\n  total?: string | number | bigint | null;\n};\n\nconst toNumber = (value: string | number | bigint | null | undefined): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'bigint') return Number(value);\n  if (typeof value === 'string') {\n    const parsed = Number(value);\n    return Number.isFinite(parsed) ? parsed : 0;\n  }\n  return 0;\n};\n\nconst parseCount = (row?: CountRow): number => toNumber(row?.count);\nconst parseTotal = (row?: SumRow): number => toNumber(row?.total);\n\n/**\n * 分销代理服务\n */\nclass DistributionService {\n  /**\n   * 生成唯一邀请码\n   */\n  async generateInviteCode() {\n    let code;\n    let exists = true;\n\n    while (exists) {\n      // 生成6位大写字母+数字邀请码\n      code = Math.random().toString(36).substring(2, 8).toUpperCase();\n      const distributor = await db('distributors').where({ invite_code: code }).first();\n      exists = !!distributor;\n    }\n\n    return code;\n  }\n\n  /**\n   * 申请成为分销员\n   */\n  async applyDistributor(userId: string, applyData: AnyObject): Promise<AnyObject> {\n    const { realName, idCard, contact, channel } = applyData;\n\n    // 检查用户是否存在\n    const user = await db('users').where({ id: userId }).first();\n    if (!user) {\n      throw {\n        statusCode: 404,\n        errorCode: 6001,\n        message: '用户不存在'\n      };\n    }\n\n    // 检查是否已申请\n    const existingDistributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (existingDistributor) {\n      if (existingDistributor.status === 'pending') {\n        throw {\n          statusCode: 400,\n          errorCode: 6002,\n          message: '您的申请正在审核中'\n        };\n      } else if (existingDistributor.status === 'active') {\n        throw {\n          statusCode: 400,\n          errorCode: 6003,\n          message: '您已经是分销员'\n        };\n      } else if (existingDistributor.status === 'disabled') {\n        throw {\n          statusCode: 400,\n          errorCode: 6004,\n          message: '您的分销员资格已被禁用'\n        };\n      }\n    }\n\n    // 生成邀请码\n    const inviteCode = await this.generateInviteCode();\n    // 🔥 加密身份证号（法律合规）\n    const encryptedIdCard = encryptionUtils.encryptIdCard(idCard);\n\n    // 创建分销员记录\n    const distributorId = generateId(8);\n    await db('distributors').insert({\n      id: distributorId,\n      user_id: userId,\n      real_name: realName,\n      id_card: encryptedIdCard, // 🔥 存储加密后的身份证号\n      contact,\n      channel,\n      status: 'pending',\n      invite_code: inviteCode,\n      total_commission: 0,\n      available_commission: 0,\n      withdrawn_commission: 0,\n      created_at: new Date(),\n      updated_at: new Date()\n    });\n\n    logger.info(`分销员申请提交: userId=${userId}, distributorId=${distributorId}`);\n\n    return {\n      distributorId,\n      inviteCode,\n      status: 'pending'\n    };\n  }\n\n  /**\n   * 绑定推荐关系（在事务中执行）\n   */\n  async bindReferralRelationship(\n    trx: Knex.Transaction,\n    referrerUserId: string,\n    referredUserId: string\n  ): Promise<string | null> {\n    // 检查自己推荐自己\n    if (referrerUserId === referredUserId) {\n      logger.warn(`自己推荐自己,忽略: referrerUserId=${referrerUserId}`);\n      return null;\n    }\n\n    // 查询推荐人是否是分销员\n    const referrer = await trx('distributors')\n      .where({ user_id: referrerUserId, status: 'active' })\n      .first();\n\n    if (!referrer) {\n      logger.info(`推荐人不是分销员,不绑定关系: referrerUserId=${referrerUserId}`);\n      return null;\n    }\n\n    // 检查被推荐人是否已有推荐关系\n    const existingRelation = await trx('referral_relationships')\n      .where({ referred_user_id: referredUserId })\n      .first();\n\n    if (existingRelation) {\n      logger.info(`被推荐人已有推荐关系,不重复绑定: referredUserId=${referredUserId}`);\n      return null;\n    }\n\n    // 创建推荐关系\n    const relationId = generateId(8);\n    await trx('referral_relationships').insert({\n      id: relationId,\n      referrer_user_id: referrerUserId,\n      referred_user_id: referredUserId,\n      referrer_distributor_id: referrer.id,\n      created_at: new Date()\n    });\n\n    logger.info(\n      `推荐关系绑定成功: relationId=${relationId}, referrerId=${referrerUserId}, referredId=${referredUserId}`\n    );\n\n    return relationId;\n  }\n\n  /**\n   * 查询分销员状态（简单版本）\n   */\n  async getDistributorStatus(userId: string): Promise<AnyObject> {\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor) {\n      return {\n        isDistributor: false,\n        status: null,\n        inviteCode: null,\n        inviteLink: null\n      };\n    }\n\n    const baseUrl = process.env.FRONTEND_URL || 'https://yourapp.com';\n    const inviteLink = `${baseUrl}/register?ref=${distributor.user_id}`;\n\n    return {\n      isDistributor: true,\n      status: distributor.status,\n      inviteCode: distributor.invite_code,\n      inviteLink: inviteLink,\n      approvalTime: distributor.approval_time\n    };\n  }\n\n  /**\n   * 查询分销员详细信息（用户端）\n   */\n  async getDistributorDetail(userId: string): Promise<AnyObject> {\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor) {\n      throw {\n        statusCode: 404,\n        errorCode: 6007,\n        message: '您不是分销员'\n      };\n    }\n\n    // 查询用户信息\n    const user = await db('users')\n      .where({ id: userId })\n      .select('id', 'phone', 'created_at')\n      .first();\n\n    // 查询推荐用户总数\n    const totalReferralsRow = (await db('referral_relationships')\n      .where({ referrer_distributor_id: distributor.id })\n      .count('id as count')\n      .first()) as CountRow | undefined;\n\n    // 查询已付费推荐用户数\n    const paidReferralsRow = (await db('referral_relationships as rr')\n      .join('orders as o', 'rr.referred_user_id', 'o.userId')\n      .where({ 'rr.referrer_distributor_id': distributor.id, 'o.status': 'paid' })\n      .countDistinct('rr.referred_user_id as count')\n      .first()) as CountRow | undefined;\n\n    // 查询冻结佣金\n    const frozenCommissionRow = (await db('commissions')\n      .where({ distributor_id: distributor.id, status: 'frozen' })\n      .sum('commission_amount as total')\n      .first()) as SumRow | undefined;\n\n    // 查询待审核提现\n    const pendingWithdrawalRow = (await db('withdrawals')\n      .where({ distributor_id: distributor.id, status: 'pending' })\n      .sum('amount as total')\n      .first()) as SumRow | undefined;\n\n    const totalReferrals = parseCount(totalReferralsRow);\n    const paidReferrals = parseCount(paidReferralsRow);\n    const frozenCommission = parseTotal(frozenCommissionRow);\n    const pendingWithdrawal = parseTotal(pendingWithdrawalRow);\n\n    const baseUrl = process.env.FRONTEND_URL || 'https://yourapp.com';\n    const inviteLink = `${baseUrl}/register?ref=${distributor.user_id}`;\n\n    return {\n      // 基本信息\n      id: distributor.id,\n      userId: distributor.user_id,\n      phone: user.phone,\n      realName: distributor.real_name,\n      contact: distributor.contact,\n      channel: distributor.channel,\n      status: distributor.status,\n      inviteCode: distributor.invite_code,\n      inviteLink: inviteLink,\n\n      // 申请与审核信息\n      appliedAt: distributor.created_at,\n      approvalTime: distributor.approval_time,\n\n      // 推广数据\n      totalReferrals,\n      paidReferrals,\n\n      // 佣金数据\n      totalCommission: toNumber(distributor.total_commission),\n      availableCommission: toNumber(distributor.available_commission),\n      frozenCommission,\n      withdrawnCommission: toNumber(distributor.withdrawn_commission),\n      pendingWithdrawal\n    };\n  }\n\n  /**\n   * 获取分销中心数据概览\n   */\n  async getDashboard(userId: string): Promise<AnyObject> {\n    // 查询分销员信息\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor || distributor.status !== 'active') {\n      throw {\n        statusCode: 403,\n        errorCode: 6005,\n        message: '您不是活跃的分销员'\n      };\n    }\n\n    // 查询推荐用户总数\n    const totalReferralsRow = (await db('referral_relationships')\n      .where({ referrer_distributor_id: distributor.id })\n      .count('id as count')\n      .first()) as CountRow | undefined;\n\n    // 查询已付费推荐用户数\n    const paidReferralsRow = (await db('referral_relationships as rr')\n      .join('orders as o', 'rr.referred_user_id', 'o.userId')\n      .where({ 'rr.referrer_distributor_id': distributor.id, 'o.status': 'paid' })\n      .countDistinct('rr.referred_user_id as count')\n      .first()) as CountRow | undefined;\n\n    // 查询冻结佣金\n    const frozenCommissionRow = (await db('commissions')\n      .where({ distributor_id: distributor.id, status: 'frozen' })\n      .sum('commission_amount as total')\n      .first()) as SumRow | undefined;\n\n    return {\n      totalReferrals: parseCount(totalReferralsRow),\n      paidReferrals: parseCount(paidReferralsRow),\n      totalCommission: toNumber(distributor.total_commission),\n      availableCommission: toNumber(distributor.available_commission),\n      frozenCommission: parseTotal(frozenCommissionRow),\n      withdrawnCommission: toNumber(distributor.withdrawn_commission)\n    };\n  }\n\n  /**\n   * 获取推广用户列表\n   */\n  async getReferrals(\n    userId: string,\n    {\n      status = 'all',\n      limit = 20,\n      offset = 0\n    }: { status?: string; limit?: number; offset?: number } = {}\n  ): Promise<AnyObject> {\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor || distributor.status !== 'active') {\n      throw {\n        statusCode: 403,\n        errorCode: 6005,\n        message: '您不是活跃的分销员'\n      };\n    }\n\n    // 构建查询\n    let query = db('referral_relationships as rr')\n      .join('users as u', 'rr.referred_user_id', 'u.id')\n      .leftJoin('orders as o', function () {\n        this.on('u.id', 'o.userId').andOn('o.status', db.raw('?', ['paid']));\n      })\n      .leftJoin('commissions as c', function () {\n        this.on('rr.referred_user_id', 'c.referred_user_id').andOn(\n          'c.distributor_id',\n          db.raw('?', [distributor.id])\n        );\n      })\n      .where('rr.referrer_distributor_id', distributor.id)\n      .select(\n        'u.id as userId',\n        'u.phone',\n        'rr.created_at as registeredAt',\n        db.raw('IF(o.id IS NOT NULL, true, false) as hasPaid'),\n        db.raw('MAX(o.paidAt) as paidAt'),\n        db.raw('SUM(c.commission_amount) as commissionAmount')\n      )\n      .groupBy('u.id', 'u.phone', 'rr.created_at');\n\n    // 状态过滤\n    if (status === 'paid') {\n      query = query.havingRaw('hasPaid = true');\n    } else if (status === 'unpaid') {\n      query = query.havingRaw('hasPaid = false');\n    }\n\n    // 获取总数\n    const countQuery = query.clone();\n    const totalResult = (await countQuery.count('* as count').first()) as CountRow | undefined;\n    const total = parseCount(totalResult);\n\n    // 分页查询\n    const referrals = await query.orderBy('rr.created_at', 'desc').limit(limit).offset(offset);\n\n    // 脱敏手机号\n    const formattedReferrals = referrals.map((r: AnyObject) => ({\n      userId: r.userId,\n      phone: r.phone.replace(/(\\d{3})\\d{4}(\\d{4})/, '$1****$2'),\n      registeredAt: r.registeredAt,\n      hasPaid: r.hasPaid,\n      paidAt: r.paidAt,\n      commissionAmount: toNumber(r.commissionAmount)\n    }));\n\n    return {\n      referrals: formattedReferrals,\n      total\n    };\n  }\n\n  /**\n   * 获取佣金明细\n   */\n  async getCommissions(\n    userId: string,\n    {\n      status = 'all',\n      limit = 20,\n      offset = 0\n    }: { status?: string; limit?: number; offset?: number } = {}\n  ): Promise<AnyObject> {\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor || distributor.status !== 'active') {\n      throw {\n        statusCode: 403,\n        errorCode: 6005,\n        message: '您不是活跃的分销员'\n      };\n    }\n\n    // 构建查询\n    let query = db('commissions as c')\n      .join('users as u', 'c.referred_user_id', 'u.id')\n      .where('c.distributor_id', distributor.id)\n      .select(\n        'c.id',\n        'c.order_id as orderId',\n        'u.phone',\n        'c.order_amount as orderAmount',\n        'c.commission_amount as commissionAmount',\n        'c.status',\n        'c.created_at as createdAt',\n        'c.settled_at as settledAt'\n      );\n\n    // 状态过滤\n    if (status !== 'all') {\n      query = query.where('c.status', status);\n    }\n\n    // 获取总数\n    const totalRow = (await query.clone().count('* as count').first()) as CountRow | undefined;\n\n    // 分页查询\n    const commissions = await query.orderBy('c.created_at', 'desc').limit(limit).offset(offset);\n\n    // 脱敏手机号\n    const formattedCommissions = commissions.map((c: AnyObject) => ({\n      id: c.id,\n      orderId: c.orderId,\n      referredUserPhone: c.phone.replace(/(\\d{3})\\d{4}(\\d{4})/, '$1****$2'),\n      orderAmount: toNumber(c.orderAmount),\n      commissionAmount: toNumber(c.commissionAmount),\n      status: c.status,\n      createdAt: c.createdAt,\n      settledAt: c.settledAt\n    }));\n\n    return {\n      commissions: formattedCommissions,\n      total: parseCount(totalRow)\n    };\n  }\n\n  /**\n   * 申请提现（使用行锁+事务）\n   */\n  async createWithdrawal(userId: string, withdrawalData: AnyObject): Promise<string> {\n    const { amount, method, accountInfo } = withdrawalData;\n\n    // 校验金额格式\n    if (!amount || amount < 0) {\n      throw {\n        statusCode: 400,\n        errorCode: 6006,\n        message: '提现金额无效'\n      };\n    }\n\n    return await db.transaction(async (trx) => {\n      // 使用行锁查询分销员\n      const distributor = await trx('distributors').where({ user_id: userId }).forUpdate().first();\n\n      if (!distributor) {\n        throw {\n          statusCode: 403,\n          errorCode: 6007,\n          message: '您不是分销员'\n        };\n      }\n\n      if (distributor.status !== 'active') {\n        throw {\n          statusCode: 403,\n          errorCode: 6008,\n          message: '您的分销员资格已被禁用'\n        };\n      }\n\n      // 获取最低提现金额配置\n      const settings = await trx('distribution_settings').where({ id: 1 }).first();\n      const minAmount = settings?.min_withdrawal_amount || 100;\n\n      if (amount < minAmount) {\n        throw {\n          statusCode: 400,\n          errorCode: 6009,\n          message: `提现金额不能低于¥${minAmount}`\n        };\n      }\n\n      // 检查可提现余额\n      if (distributor.available_commission < amount) {\n        throw {\n          statusCode: 400,\n          errorCode: 6010,\n          message: `可提现余额不足(当前¥${distributor.available_commission})`\n        };\n      }\n\n      // 扣除可提现余额\n      await trx('distributors')\n        .where({ id: distributor.id })\n        .decrement('available_commission', amount);\n\n      // 创建提现记录\n      const withdrawalId = generateId(8);\n      await trx('withdrawals').insert({\n        id: withdrawalId,\n        distributor_id: distributor.id,\n        amount,\n        method,\n        account_info: JSON.stringify(accountInfo),\n        status: 'pending',\n        created_at: new Date()\n      });\n\n      logger.info(`提现申请创建成功: withdrawalId=${withdrawalId}, amount=${amount}`);\n\n      return withdrawalId;\n    });\n  }\n\n  /**\n   * 获取提现记录\n   */\n  async getWithdrawals(\n    userId: string,\n    { limit = 20, offset = 0 }: { limit?: number; offset?: number } = {}\n  ): Promise<AnyObject> {\n    const distributor = await db('distributors').where({ user_id: userId }).first();\n\n    if (!distributor || distributor.status !== 'active') {\n      throw {\n        statusCode: 403,\n        errorCode: 6005,\n        message: '您不是活跃的分销员'\n      };\n    }\n\n    // 查询提现记录\n    const withdrawals = await db('withdrawals')\n      .where({ distributor_id: distributor.id })\n      .select('*')\n      .orderBy('created_at', 'desc')\n      .limit(limit)\n      .offset(offset);\n\n    // 获取总数\n    const totalRow = (await db('withdrawals')\n      .where({ distributor_id: distributor.id })\n      .count('id as count')\n      .first()) as CountRow | undefined;\n\n    // 格式化结果\n    const formattedWithdrawals = withdrawals.map((w: AnyObject) => ({\n      id: w.id,\n      amount: toNumber(w.amount),\n      method: w.method,\n      accountInfo: JSON.parse(w.account_info),\n      status: w.status,\n      rejectReason: w.reject_reason,\n      createdAt: w.created_at,\n      approvedAt: w.approved_at\n    }));\n\n    return {\n      withdrawals: formattedWithdrawals,\n      total: parseCount(totalRow)\n    };\n  }\n}\n\nconst distributionService = new DistributionService();\n\nexport default distributionService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/email.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/feature-catalog.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········?·new·Date(row.usage_date).toISOString().split('T')[0]⏎·········` with `·?·new·Date(row.usage_date).toISOString().split('T')[0]`","line":824,"column":34,"nodeType":null,"messageId":"replace","endLine":826,"endColumn":10,"fix":{"range":[23055,23130],"text":" ? new Date(row.usage_date).toISOString().split('T')[0]"}}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2039,2042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2039,2042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2072,2075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2072,2075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4786,4789],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4786,4789],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6717,6720],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6717,6720],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7465,7468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7465,7468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7480,7483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7480,7483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":356,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9349,9352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9349,9352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":357,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9382,9385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9382,9385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":432,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":432,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11614,11617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11614,11617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":465,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12565,12568],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12565,12568],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12584,12587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12584,12587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":475,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":475,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12846,12849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12846,12849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":520,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":520,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14387,14390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14387,14390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":604,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":604,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16621,16624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16621,16624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":642,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":642,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17635,17638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17635,17638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport logger from '../utils/logger.js';\nimport { db } from '../config/database.js';\nimport cacheService from './cache.service.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport type { Knex } from 'knex';\n\n/**\n * 功能目录服务类\n *\n * 管理应用中的所有功能特性：\n * - 功能定义和元数据管理\n * - 功能配置和参数管理\n * - 功能权限控制\n * - 功能版本管理\n * - 功能使用统计\n */\ntype FeatureQueryOptions = {\n  category?: string;\n  type?: string;\n  isPublic?: boolean;\n  is_active?: boolean;\n  tags?: string[];\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n};\n\ntype UsageFilterOptions = {\n  userId?: string;\n  startDate?: string | Date;\n  endDate?: string | Date;\n  limit?: number;\n  offset?: number;\n};\n\ntype FeatureUsageStatus = 'success' | 'failed' | 'partial';\n\ntype FeatureMetricValue = string | number | boolean | null;\n\ntype FeatureUsageMetrics = Record<string, FeatureMetricValue>;\n\ntype FeatureUsageError = Record<string, unknown> | Record<string, unknown>[] | null;\n\ninterface FeatureUsageRecordInput {\n  usageCount?: number;\n  cost?: number;\n  metrics?: FeatureUsageMetrics;\n  status?: FeatureUsageStatus;\n  errorDetails?: FeatureUsageError;\n}\n\ntype AccessContext = {\n  userId?: string;\n  role?: string;\n  roles?: string[];\n  permissions?: Record<string, boolean>;\n  membershipTier?: string;\n  membership?: string;\n  organizationId?: string;\n  [key: string]: unknown;\n};\n\ninterface FeatureUsageStatsOptions {\n  featureKey?: string;\n  userId?: string;\n  startDate?: string | Date;\n  endDate?: string | Date;\n  groupBy?: 'feature' | 'user' | 'day';\n}\n\ninterface FeatureUsageStatSummary {\n  featureId: string;\n  featureKey: string;\n  featureName: string;\n  category: string;\n  usageDate: string | null;\n  userId: string | null;\n  totalUsage: number;\n  totalCost: number;\n  activeDays: number;\n}\n\ntype FeatureDefinitionRecord = Record<string, any>;\ntype FeatureDefinitionCacheEntry = FeatureDefinitionRecord & {\n  configurations: Map<string, any>;\n  permissions: Map<string, any>;\n};\n\nclass FeatureCatalogService {\n  private initialized: boolean;\n  private readonly cachePrefix: string;\n  private readonly cacheTTL: number;\n  private readonly featureDefinitions: Map<string, FeatureDefinitionCacheEntry>;\n  private lastCacheUpdate: number;\n  private readonly cacheUpdateInterval: number;\n  private cacheRefreshTimer?: ReturnType<typeof setInterval>;\n\n  constructor() {\n    this.initialized = false;\n    this.cachePrefix = 'feature_catalog:';\n    this.cacheTTL = 3600; // 1小时缓存\n    this.featureDefinitions = new Map(); // 内存缓存\n    this.lastCacheUpdate = 0;\n    this.cacheUpdateInterval = 300000; // 5分钟更新一次\n    this.cacheRefreshTimer = undefined;\n  }\n\n  /**\n   * 初始化功能目录服务\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    try {\n      logger.info('[FeatureCatalogService] Initializing feature catalog service...');\n\n      // 加载所有功能定义到内存\n      await this.loadFeatureDefinitions();\n\n      // 设置定时缓存更新\n      this.setupCacheRefresh();\n\n      this.initialized = true;\n      logger.info('[FeatureCatalogService] Feature catalog service initialized successfully');\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to initialize feature catalog service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 加载所有功能定义\n   */\n  async loadFeatureDefinitions(): Promise<void> {\n    try {\n      const features = await db('feature_definitions')\n        .where('is_active', true)\n        .orderBy('category', 'asc')\n        .orderBy('name', 'asc');\n\n      this.featureDefinitions.clear();\n      for (const feature of features) {\n        this.featureDefinitions.set(feature.feature_key, {\n          ...feature,\n          configurations: new Map(),\n          permissions: new Map()\n        });\n      }\n\n      this.lastCacheUpdate = Date.now();\n      logger.info(`[FeatureCatalogService] Loaded ${features.length} feature definitions`);\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to load feature definitions:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 设置定时缓存刷新\n   */\n  setupCacheRefresh(): void {\n    if (this.cacheRefreshTimer) {\n      clearInterval(this.cacheRefreshTimer);\n    }\n\n    this.cacheRefreshTimer = setInterval(async () => {\n      try {\n        await this.loadFeatureDefinitions();\n        logger.debug('[FeatureCatalogService] Feature definitions cache refreshed');\n      } catch (error) {\n        logger.error('[FeatureCatalogService] Failed to refresh feature definitions cache:', error);\n      }\n    }, this.cacheUpdateInterval);\n  }\n\n  /**\n   * 获取功能列表\n   * @param {Object} options - 查询选项\n   * @returns {Array} 功能列表\n   */\n  async getFeatures(options: FeatureQueryOptions = {}): Promise<any[]> {\n    const {\n      category,\n      type,\n      isPublic,\n      is_active = true,\n      tags,\n      limit = 50,\n      offset = 0,\n      sortBy = 'name',\n      sortOrder = 'asc'\n    } = options;\n\n    try {\n      let query = db('feature_definitions');\n\n      // 应用过滤条件\n      if (category) {\n        query = query.where('category', category);\n      }\n      if (type) {\n        query = query.where('type', type);\n      }\n      if (typeof isPublic === 'boolean') {\n        query = query.where('is_public', isPublic);\n      }\n      if (typeof is_active === 'boolean') {\n        query = query.where('is_active', is_active);\n      }\n      if (tags && tags.length > 0) {\n        query = query.whereRaw('JSON_CONTAINS(tags, ?)', [JSON.stringify(tags)]);\n      }\n\n      // 应用排序\n      const validSortFields = ['name', 'category', 'type', 'released_at', 'created_at'];\n      const sortField = validSortFields.includes(sortBy) ? sortBy : 'name';\n      query = query.orderBy(sortField, sortOrder === 'desc' ? 'desc' : 'asc');\n\n      // 应用分页\n      query = query.limit(limit).offset(offset);\n\n      const features = await query;\n\n      // 为每个功能添加配置和权限信息\n      const featuresWithDetails = await Promise.all(\n        features.map(async (feature) => {\n          const [configurations, permissions] = await Promise.all([\n            this.getFeatureConfigurations(feature.id),\n            this.getFeaturePermissions(feature.id)\n          ]);\n\n          return {\n            ...feature,\n            configurations,\n            permissions\n          };\n        })\n      );\n\n      return featuresWithDetails;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to get features:', error);\n      throw AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * 根据key获取功能定义\n   * @param {string} featureKey - 功能key\n   * @returns {Object|null} 功能定义\n   */\n  async getFeatureByKey(featureKey: string): Promise<any> {\n    try {\n      // 先从内存缓存查找\n      if (this.featureDefinitions.has(featureKey)) {\n        return this.featureDefinitions.get(featureKey);\n      }\n\n      // 从数据库查找\n      const feature = await db('feature_definitions').where('feature_key', featureKey).first();\n\n      if (!feature) {\n        return null;\n      }\n\n      // 添加到内存缓存\n      this.featureDefinitions.set(featureKey, feature);\n\n      return feature;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to get feature by key:', error);\n      throw AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * 创建功能定义\n   * @param {Object} featureData - 功能数据\n   * @returns {Object} 创建的功能\n   */\n  async createFeature(featureData: Record<string, any>): Promise<any> {\n    try {\n      const {\n        feature_key,\n        name,\n        description,\n        category,\n        type = 'basic',\n        is_active = true,\n        is_public = true,\n        tags,\n        metadata,\n        icon,\n        version = '1.0.0',\n        requirements,\n        limits,\n        pricing\n      } = featureData;\n\n      // 检查功能key是否已存在\n      const existingFeature = await this.getFeatureByKey(feature_key);\n      if (existingFeature) {\n        throw AppError.create(ERROR_CODES.USER_ALREADY_EXISTS, {\n          field: 'feature_key',\n          value: feature_key,\n          message: 'Feature key already exists'\n        });\n      }\n\n      // 插入功能定义\n      const [feature] = await db('feature_definitions')\n        .insert({\n          feature_key,\n          name,\n          description,\n          category,\n          type,\n          is_active,\n          is_public,\n          tags: tags ? JSON.stringify(tags) : null,\n          metadata: metadata ? JSON.stringify(metadata) : null,\n          icon,\n          version,\n          requirements: requirements ? JSON.stringify(requirements) : null,\n          limits: limits ? JSON.stringify(limits) : null,\n          pricing: pricing ? JSON.stringify(pricing) : null,\n          released_at: new Date()\n        })\n        .returning('*');\n\n      // 更新内存缓存\n      this.featureDefinitions.set(feature_key, feature);\n\n      logger.info(`[FeatureCatalogService] Created feature: ${feature_key}`);\n\n      return feature;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to create feature:', error);\n      throw AppError.fromError(error, ERROR_CODES.TASK_CREATION_FAILED);\n    }\n  }\n\n  /**\n   * 更新功能定义\n   * @param {string} featureKey - 功能key\n   * @param {Object} updateData - 更新数据\n   * @returns {Object} 更新后的功能\n   */\n  async updateFeature(\n    featureKey: string,\n    updateData: Record<string, any>\n  ): Promise<Record<string, any>> {\n    try {\n      const feature = await this.getFeatureByKey(featureKey);\n      if (!feature) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          feature_key: featureKey,\n          resource: 'feature'\n        });\n      }\n\n      // 处理JSON字段\n      const processedData = { ...updateData };\n      const jsonFields = ['tags', 'metadata', 'requirements', 'limits', 'pricing'];\n      for (const field of jsonFields) {\n        if (processedData[field] !== undefined) {\n          processedData[field] = processedData[field] ? JSON.stringify(processedData[field]) : null;\n        }\n      }\n\n      // 更新功能定义\n      const [updatedFeature] = await db('feature_definitions')\n        .where('feature_key', featureKey)\n        .update(processedData)\n        .returning('*');\n\n      // 更新内存缓存\n      this.featureDefinitions.set(featureKey, updatedFeature);\n\n      logger.info(`[FeatureCatalogService] Updated feature: ${featureKey}`);\n\n      return updatedFeature;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to update feature:', error);\n      throw AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n    }\n  }\n\n  /**\n   * 删除功能定义\n   * @param {string} featureKey - 功能key\n   * @returns {boolean} 是否删除成功\n   */\n  async deleteFeature(featureKey: string): Promise<boolean> {\n    try {\n      const feature = await this.getFeatureByKey(featureKey);\n      if (!feature) {\n        throw AppError.create(ERROR_CODES.TASK_NOT_FOUND, {\n          feature_key: featureKey,\n          resource: 'feature'\n        });\n      }\n\n      // 软删除：设置为不活跃\n      await db('feature_definitions').where('feature_key', featureKey).update({\n        is_active: false,\n        deprecated_at: new Date()\n      });\n\n      // 从内存缓存中移除\n      this.featureDefinitions.delete(featureKey);\n\n      logger.info(`[FeatureCatalogService] Deleted feature: ${featureKey}`);\n\n      return true;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to delete feature:', error);\n      throw AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n    }\n  }\n\n  /**\n   * 获取功能配置\n   * @param {string} featureId - 功能ID\n   * @returns {Array} 配置列表\n   */\n  async getFeatureConfigurations(featureId: string): Promise<any[]> {\n    try {\n      const cacheKey = `${this.cachePrefix}config:${featureId}`;\n\n      // 尝试从缓存获取\n      const cached = await cacheService.get(cacheKey);\n      if (Array.isArray(cached)) {\n        return cached;\n      }\n\n      const configurations = await db('feature_configurations')\n        .where('feature_id', featureId)\n        .orderBy('sort_order', 'asc')\n        .orderBy('config_key', 'asc');\n\n      // 缓存结果\n      await cacheService.set(cacheKey, configurations, this.cacheTTL);\n\n      return configurations;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to get feature configurations:', error);\n      throw AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * 设置功能配置\n   * @param {string} featureId - 功能ID\n   * @param {Array} configurations - 配置列表\n   * @returns {Array} 设置后的配置\n   */\n  async setFeatureConfigurations(\n    featureId: string,\n    configurations: Array<Record<string, any>>\n  ): Promise<any[]> {\n    try {\n      const trx = await db.transaction();\n\n      try {\n        // 删除现有配置\n        await trx('feature_configurations').where('feature_id', featureId).del();\n\n        // 插入新配置\n        const configData = configurations.map((config: Record<string, any>, index: number) => ({\n          feature_id: featureId,\n          config_key: config.config_key,\n          config_value: config.config_value,\n          data_type: config.data_type || 'string',\n          description: config.description,\n          is_required: config.is_required || false,\n          is_sensitive: config.is_sensitive || false,\n          validation_rules: config.validation_rules\n            ? JSON.stringify(config.validation_rules)\n            : null,\n          default_value: config.default_value,\n          enum_values: config.enum_values ? JSON.stringify(config.enum_values) : null,\n          sort_order: config.sort_order || index\n        }));\n\n        const insertedConfigurations = await trx('feature_configurations')\n          .insert(configData)\n          .returning('*');\n\n        await trx.commit();\n\n        // 清除缓存\n        await cacheService.delete(`${this.cachePrefix}config:${featureId}`);\n\n        logger.info(\n          `[FeatureCatalogService] Set ${insertedConfigurations.length} configurations for feature: ${featureId}`\n        );\n\n        return insertedConfigurations;\n      } catch (error) {\n        await trx.rollback();\n        throw error;\n      }\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to set feature configurations:', error);\n      throw AppError.fromError(error, ERROR_CODES.TASK_PROCESSING_FAILED);\n    }\n  }\n\n  /**\n   * 获取功能权限\n   * @param {string} featureId - 功能ID\n   * @returns {Array} 权限列表\n   */\n  async getFeaturePermissions(featureId: string): Promise<any[]> {\n    try {\n      const cacheKey = `${this.cachePrefix}permissions:${featureId}`;\n\n      // 尝试从缓存获取\n      const cached = await cacheService.get(cacheKey);\n      if (Array.isArray(cached)) {\n        return cached;\n      }\n\n      const permissions = await db('feature_permissions')\n        .where('feature_id', featureId)\n        .where('expires_at', '>', new Date())\n        .orWhere('expires_at', null)\n        .orderBy('permission_type', 'asc')\n        .orderBy('permission_value', 'asc');\n\n      // 缓存结果\n      await cacheService.set(cacheKey, permissions, this.cacheTTL);\n\n      return permissions;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to get feature permissions:', error);\n      throw AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * 检查用户是否有功能访问权限\n   * @param {string} featureKey - 功能key\n   * @param {string} userId - 用户ID\n   * @param {Object} userContext - 用户上下文信息\n   * @returns {boolean} 是否有权限\n   */\n  async checkFeatureAccess(\n    featureKey: string,\n    userId: string,\n    userContext: AccessContext = {}\n  ): Promise<boolean> {\n    try {\n      const feature = await this.getFeatureByKey(featureKey);\n      if (!feature) {\n        return false;\n      }\n\n      // 如果功能不活跃或未公开，拒绝访问\n      if (!feature.is_active || !feature.is_public) {\n        return false;\n      }\n\n      // 获取功能权限设置\n      const permissions = await this.getFeaturePermissions(feature.id);\n      if (permissions.length === 0) {\n        // 没有特定权限设置，默认允许访问公开功能\n        return feature.is_public;\n      }\n\n      // 检查用户权限\n      for (const permission of permissions) {\n        if (!permission.is_granted) {\n          continue;\n        }\n\n        const hasPermission = await this.evaluatePermission(permission, userId, userContext);\n        if (hasPermission) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to check feature access:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 评估权限\n   * @param {Object} permission - 权限对象\n   * @param {string} userId - 用户ID\n   * @param {Object} userContext - 用户上下文\n   * @returns {boolean} 是否有权限\n   */\n  async evaluatePermission(\n    permission: Record<string, any>,\n    userId: string,\n    userContext: AccessContext = {}\n  ): Promise<boolean> {\n    try {\n      switch (permission.permission_type) {\n        case 'user':\n          return permission.permission_value === userId;\n\n        case 'role':\n          return Boolean(userContext.roles?.includes(permission.permission_value));\n\n        case 'membership':\n          return userContext.membership === permission.permission_value;\n\n        case 'custom':\n          // 自定义权限条件\n          if (permission.conditions) {\n            return this.evaluateCustomConditions(permission.conditions, userContext);\n          }\n          return false;\n\n        default:\n          return false;\n      }\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to evaluate permission:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 评估自定义条件\n   * @param {Object} conditions - 条件对象\n   * @param {Object} userContext - 用户上下文\n   * @returns {boolean} 是否满足条件\n   */\n  evaluateCustomConditions(\n    conditions: Record<string, any>,\n    userContext: AccessContext = {}\n  ): boolean {\n    try {\n      const conditionsStr = JSON.stringify(conditions);\n\n      // 简单的条件评估（实际项目中可能需要更复杂的表达式解析器）\n      for (const [key, value] of Object.entries(conditions)) {\n        if (userContext[key] !== value) {\n          return false;\n        }\n      }\n\n      return true;\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to evaluate custom conditions:', error);\n      return false;\n    }\n  }\n\n  private parseUsageMetrics(raw: unknown): FeatureUsageMetrics {\n    if (!raw) return {};\n    if (typeof raw === 'string') {\n      try {\n        return JSON.parse(raw) as FeatureUsageMetrics;\n      } catch (error) {\n        logger.warn('[FeatureCatalogService] 解析 usage_metrics 失败，返回空对象', { error });\n        return {};\n      }\n    }\n    if (typeof raw === 'object') {\n      return raw as FeatureUsageMetrics;\n    }\n    return {};\n  }\n\n  /**\n   * 记录功能使用统计\n   * @param {string} featureKey - 功能key\n   * @param {string} userId - 用户ID\n   * @param {Object} usageData - 使用数据\n   */\n  async recordFeatureUsage(\n    featureKey: string,\n    userId: string,\n    usageData: FeatureUsageRecordInput = {}\n  ): Promise<void> {\n    try {\n      const feature = await this.getFeatureByKey(featureKey);\n      if (!feature) {\n        return;\n      }\n\n      const {\n        usageCount = 1,\n        metrics = {} as FeatureUsageMetrics,\n        cost = 0,\n        status = 'success' as FeatureUsageStatus,\n        errorDetails = null\n      } = usageData;\n\n      const usageDate = new Date().toISOString().split('T')[0];\n\n      // 使用事务确保数据一致性\n      await db.transaction(async (trx) => {\n        // 检查是否已有今天的统计记录\n        const existingStat = await trx('feature_usage_stats')\n          .where({\n            feature_id: feature.id,\n            user_id: userId,\n            usage_date: usageDate\n          })\n          .first();\n\n        if (existingStat) {\n          const existingMetrics = this.parseUsageMetrics(existingStat.usage_metrics);\n          // 更新现有记录\n          await trx('feature_usage_stats')\n            .where('id', existingStat.id)\n            .update({\n              usage_count: existingStat.usage_count + usageCount,\n              usage_metrics: JSON.stringify({\n                ...existingMetrics,\n                ...metrics\n              }),\n              total_cost: Number(existingStat.total_cost ?? 0) + Number(cost ?? 0),\n              status: status === 'failed' ? 'failed' : existingStat.status,\n              error_details: errorDetails\n                ? JSON.stringify(errorDetails)\n                : existingStat.error_details,\n              updated_at: new Date()\n            });\n        } else {\n          // 创建新记录\n          await trx('feature_usage_stats').insert({\n            feature_id: feature.id,\n            user_id: userId,\n            usage_date: usageDate,\n            usage_count: usageCount,\n            usage_metrics: JSON.stringify(metrics),\n            total_cost: cost,\n            status,\n            error_details: errorDetails ? JSON.stringify(errorDetails) : null\n          });\n        }\n      });\n\n      logger.debug(\n        `[FeatureCatalogService] Recorded usage for feature: ${featureKey}, user: ${userId}`\n      );\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to record feature usage:', error);\n      // 记录失败不应该影响主要功能，所以这里只记录日志\n    }\n  }\n\n  /**\n   * 获取功能使用统计\n   * @param {Object} options - 查询选项\n   * @returns {Array} 统计数据\n   */\n  async getUsageStats(options: FeatureUsageStatsOptions = {}): Promise<FeatureUsageStatSummary[]> {\n    try {\n      const { featureKey, userId, startDate, endDate, groupBy = 'day' } = options;\n\n      let query = db('feature_usage_stats as fus')\n        .select(\n          'fus.feature_id',\n          'fd.feature_key',\n          'fd.name as feature_name',\n          'fd.category',\n          'fus.usage_date',\n          db.raw('SUM(fus.usage_count) as total_usage'),\n          db.raw('SUM(fus.total_cost) as total_cost'),\n          db.raw('COUNT(*) as active_days')\n        )\n        .join('feature_definitions as fd', 'fus.feature_id', '=', 'fd.id')\n        .where('fd.is_active', true);\n\n      // 应用过滤条件\n      if (featureKey) {\n        query = query.where('fd.feature_key', featureKey);\n      }\n      if (userId) {\n        query = query.where('fus.user_id', userId);\n      }\n      if (startDate) {\n        query = query.where('fus.usage_date', '>=', startDate);\n      }\n      if (endDate) {\n        query = query.where('fus.usage_date', '<=', endDate);\n      }\n\n      // 应用分组\n      switch (groupBy) {\n        case 'feature':\n          query = query.groupBy('fus.feature_id', 'fd.feature_key', 'fd.name', 'fd.category');\n          break;\n        case 'user':\n          query = query\n            .select('fus.user_id')\n            .groupBy('fus.user_id', 'fus.feature_id', 'fd.feature_key', 'fd.name', 'fd.category');\n          break;\n        case 'day':\n        default:\n          query = query.groupBy(\n            'fus.usage_date',\n            'fus.feature_id',\n            'fd.feature_key',\n            'fd.name',\n            'fd.category'\n          );\n          break;\n      }\n\n      const stats = await query.orderBy('fus.usage_date', 'desc');\n\n      return stats.map((row) => ({\n        featureId: row.feature_id,\n        featureKey: row.feature_key,\n        featureName: row.feature_name,\n        category: row.category,\n        usageDate: row.usage_date\n          ? new Date(row.usage_date).toISOString().split('T')[0]\n          : null,\n        userId: row.user_id ?? null,\n        totalUsage: Number(row.total_usage ?? 0),\n        totalCost: Number(row.total_cost ?? 0),\n        activeDays: Number(row.active_days ?? 0)\n      }));\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Failed to get usage stats:', error);\n      throw AppError.fromError(error, ERROR_CODES.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  /**\n   * 获取服务统计信息\n   * @returns {Object} 统计信息\n   */\n  getStats() {\n    return {\n      initialized: this.initialized,\n      cachedFeatures: this.featureDefinitions.size,\n      lastCacheUpdate: this.lastCacheUpdate,\n      cacheUpdateInterval: this.cacheUpdateInterval,\n      cachePrefix: this.cachePrefix,\n      cacheTTL: this.cacheTTL\n    };\n  }\n\n  /**\n   * 关闭服务\n   */\n  async close(): Promise<void> {\n    try {\n      if (this.cacheRefreshTimer) {\n        clearInterval(this.cacheRefreshTimer);\n        this.cacheRefreshTimer = undefined;\n      }\n      this.featureDefinitions.clear();\n      this.initialized = false;\n      logger.info('[FeatureCatalogService] Feature catalog service closed');\n    } catch (error) {\n      logger.error('[FeatureCatalogService] Error closing feature catalog service:', error);\n    }\n  }\n}\n\nconst featureCatalogService = new FeatureCatalogService();\nexport default featureCatalogService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/feature.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/file-lifecycle.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎······(t)·=>·new·Date(t.at)·<=·now·&&·!t.completed⏎····` with `(t)·=>·new·Date(t.at)·<=·now·&&·!t.completed`","line":367,"column":50,"nodeType":null,"messageId":"replace","endLine":369,"endColumn":5,"fix":{"range":[10082,10138],"text":"(t) => new Date(t.at) <= now && !t.completed"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·(t.at·===·transition.at·?·transition·:·t)` with `⏎········t.at·===·transition.at·?·transition·:·t⏎······`","line":400,"column":61,"nodeType":null,"messageId":"replace","endLine":400,"endColumn":103,"fix":{"range":[10996,11038],"text":"\n        t.at === transition.at ? transition : t\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `strategy:·LifecycleStrategyConfig,·now:·Date` with `⏎····strategy:·LifecycleStrategyConfig,⏎····now:·Date⏎··`","line":674,"column":38,"nodeType":null,"messageId":"replace","endLine":674,"endColumn":82,"fix":{"range":[19122,19166],"text":"\n    strategy: LifecycleStrategyConfig,\n    now: Date\n  "}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import crypto from 'node:crypto';\nimport logger from '../utils/logger.js';\nimport cosStorageService from './cos-storage.service.js';\nimport { db } from '../config/database.js';\nimport type {\n  FileCategory,\n  FileLifecycleRecord,\n  FileLifecycleRecordRow,\n  FileLifecycleStats,\n  FileMetadata,\n  FilePriority,\n  FileStorageClass,\n  LifecycleCleanupOptions,\n  LifecycleCleanupResult,\n  LifecycleProcessResult,\n  LifecycleRegistrationInput,\n  LifecycleRegistrationResult,\n  LifecycleSchedule,\n  LifecycleStrategyConfig,\n  LifecycleTransitionExecutionResult,\n  LifecycleTransitionState\n} from '../types/file.types.js';\n\ntype LifecycleStrategyMap = Record<FileCategory, LifecycleStrategyConfig>;\n\ninterface CleanupConfig {\n  enabled: boolean;\n  interval: number;\n  batchSize: number;\n  maxExecutionTime: number;\n}\n\ninterface MonitoringConfig {\n  enabled: boolean;\n  alertThresholds: {\n    storageUsage: number;\n    costIncrease: number;\n    errorRate: number;\n  };\n}\n\ninterface FileLifecycleConfig {\n  strategies: LifecycleStrategyMap;\n  cleanup: CleanupConfig;\n  monitoring: MonitoringConfig;\n}\n\n/**\n * 文件生命周期管理服务\n *\n * 管理文件从上传到删除的完整生命周期：\n * - 自动分类和标记\n * - 按策略转移存储类别\n * - 定期清理过期文件\n * - 成本优化和监控\n * - 合规性审计\n */\nclass FileLifecycleService {\n  private config: FileLifecycleConfig;\n\n  private initialized = false;\n\n  private cleanupTimer: NodeJS.Timeout | null = null;\n\n  private stats: FileLifecycleStats;\n\n  constructor() {\n    const strategies: LifecycleStrategyMap = {\n      temp: {\n        ttl: 7 * 24 * 60 * 60 * 1000,\n        transitions: [\n          { after: 1 * 24 * 60 * 60 * 1000, storageClass: 'Standard_IA' },\n          { after: 3 * 24 * 60 * 60 * 1000, storageClass: 'Archive' }\n        ],\n        autoDelete: true\n      },\n      intermediate: {\n        ttl: 30 * 24 * 60 * 60 * 1000,\n        transitions: [\n          { after: 7 * 24 * 60 * 60 * 1000, storageClass: 'Standard_IA' },\n          { after: 15 * 24 * 60 * 60 * 1000, storageClass: 'Archive' }\n        ],\n        autoDelete: true\n      },\n      userUpload: {\n        ttl: 365 * 24 * 60 * 60 * 1000,\n        transitions: [\n          { after: 90 * 24 * 60 * 60 * 1000, storageClass: 'Standard_IA' },\n          { after: 180 * 24 * 60 * 60 * 1000, storageClass: 'Archive' }\n        ],\n        autoDelete: false\n      },\n      result: {\n        ttl: 180 * 24 * 60 * 60 * 1000,\n        transitions: [\n          { after: 30 * 24 * 60 * 60 * 1000, storageClass: 'Standard_IA' },\n          { after: 90 * 24 * 60 * 60 * 1000, storageClass: 'Archive' }\n        ],\n        autoDelete: true\n      },\n      log: {\n        ttl: 30 * 24 * 60 * 60 * 1000,\n        transitions: [{ after: 7 * 24 * 60 * 60 * 1000, storageClass: 'Standard_IA' }],\n        autoDelete: true\n      }\n    };\n\n    this.config = {\n      strategies,\n      cleanup: {\n        enabled: true,\n        interval: 6 * 60 * 60 * 1000,\n        batchSize: 1000,\n        maxExecutionTime: 30 * 60 * 1000\n      },\n      monitoring: {\n        enabled: true,\n        alertThresholds: {\n          storageUsage: 0.8,\n          costIncrease: 0.2,\n          errorRate: 0.05\n        }\n      }\n    };\n\n    this.initialized = false;\n    this.cleanupTimer = null;\n    this.stats = {\n      totalProcessed: 0,\n      totalDeleted: 0,\n      totalTransferred: 0,\n      costSaved: 0,\n      lastCleanup: null,\n      errors: 0\n    };\n  }\n\n  /**\n   * 初始化生命周期服务\n   */\n  async initialize() {\n    if (this.initialized) {\n      logger.warn('[FileLifecycle] 生命周期服务已初始化');\n      return;\n    }\n\n    try {\n      // 确保COS服务已初始化\n      await cosStorageService.initialize();\n\n      // 创建文件记录表（如果不存在）\n      await this.ensureFileRecordsTable();\n\n      // 启动定期清理任务\n      this.startPeriodicCleanup();\n\n      this.initialized = true;\n      logger.info('[FileLifecycle] 文件生命周期服务初始化成功');\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 初始化失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 注册文件\n   * @param {Object} fileInfo - 文件信息\n   * @returns {Promise<Object>} 注册结果\n   */\n  async registerFile(fileInfo: LifecycleRegistrationInput): Promise<LifecycleRegistrationResult> {\n    try {\n      const { key, category, taskId, userId, metadata = {}, size = 0 } = fileInfo;\n      const priority = this.normalizePriority(fileInfo.priority);\n\n      if (!key || typeof key !== 'string') {\n        throw new Error('文件 key 必须为字符串');\n      }\n\n      // 验证分类\n      if (!this.config.strategies[category]) {\n        throw new Error(`不支持的文件分类: ${category}`);\n      }\n\n      const strategy = this.config.strategies[category];\n      const now = new Date();\n\n      // 计算生命周期时间点\n      const lifecycleSchedule = this.calculateLifecycleSchedule(strategy, now);\n\n      const fileRecord: FileLifecycleRecordRow = {\n        id: this.generateFileId(),\n        key,\n        category,\n        task_id: taskId ?? null,\n        user_id: userId ?? null,\n        metadata: JSON.stringify(metadata),\n        storage_class: fileInfo.storageClass ?? 'Standard',\n        priority,\n        status: 'active',\n        created_at: now,\n        updated_at: now,\n        expires_at: new Date(now.getTime() + strategy.ttl),\n        next_transition_at: lifecycleSchedule.nextTransitionAt,\n        size,\n        transitions: JSON.stringify(lifecycleSchedule.transitions),\n        auto_delete: strategy.autoDelete\n      };\n\n      // 保存到数据库\n      await db('file_lifecycle_records').insert(fileRecord);\n\n      logger.info(`[FileLifecycle] 文件注册成功: ${key} (${category})`);\n\n      return {\n        success: true,\n        fileId: fileRecord.id,\n        schedule: lifecycleSchedule\n      };\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 文件注册失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 更新文件状态\n   * @param {string} fileId - 文件ID\n   * @param {Object} updates - 更新内容\n   * @returns {Promise<boolean>} 是否成功\n   */\n  async updateFileStatus(\n    fileId: string,\n    updates: Partial<FileLifecycleRecord> & {\n      metadata?: FileMetadata;\n      transitions?: LifecycleTransitionState[] | string;\n    }\n  ): Promise<boolean> {\n    try {\n      const updateData: Record<string, unknown> = {\n        ...updates,\n        updated_at: new Date()\n      };\n\n      if (updates.metadata) {\n        updateData.metadata = JSON.stringify(updates.metadata);\n      }\n\n      if (updates.transitions) {\n        updateData.transitions =\n          typeof updates.transitions === 'string'\n            ? updates.transitions\n            : JSON.stringify(updates.transitions);\n      }\n\n      const affected = await db('file_lifecycle_records').where('id', fileId).update(updateData);\n\n      return affected > 0;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[FileLifecycle] 更新文件状态失败: ${fileId}`, err);\n      return false;\n    }\n  }\n\n  /**\n   * 执行生命周期转换\n   * @returns {Promise<Object>} 执行结果\n   */\n  async executeLifecycleTransitions(): Promise<LifecycleTransitionExecutionResult> {\n    try {\n      logger.info('[FileLifecycle] 开始执行生命周期转换');\n\n      const now = new Date();\n      let processedCount = 0;\n      let transferredCount = 0;\n      let deletedCount = 0;\n      const errors = [];\n\n      // 查询需要处理的文件\n      const rawRecords = (await db('file_lifecycle_records')\n        .where('status', 'active')\n        .where('expires_at', '<=', now)\n        .orWhere('next_transition_at', '<=', now)\n        .limit(this.config.cleanup.batchSize)) as Record<string, unknown>[];\n\n      for (const record of rawRecords) {\n        try {\n          const file = this.mapLifecycleRecord(record);\n          const result = await this.processFileLifecycle(file);\n          processedCount++;\n\n          if (result.transferred) transferredCount++;\n          if (result.deleted) deletedCount++;\n\n          // 避免API限制\n          if (processedCount % 50 === 0) {\n            await this.sleep(100);\n          }\n        } catch (error) {\n          const err = error instanceof Error ? error : new Error(String(error));\n          const key = typeof record.key === 'string' ? record.key : 'unknown';\n          errors.push({\n            fileId: typeof record.id === 'string' ? record.id : undefined,\n            key: typeof record.key === 'string' ? record.key : undefined,\n            error: err.message\n          });\n          logger.error(`[FileLifecycle] 处理文件失败: ${key}`, err);\n        }\n      }\n\n      // 更新统计\n      this.stats.totalProcessed += processedCount;\n      this.stats.totalTransferred += transferredCount;\n      this.stats.totalDeleted += deletedCount;\n      this.stats.lastCleanup = now;\n\n      const result: LifecycleTransitionExecutionResult = {\n        success: true,\n        processed: processedCount,\n        transferred: transferredCount,\n        deleted: deletedCount,\n        errors: errors.length,\n        errorDetails: errors,\n        timestamp: now.toISOString()\n      };\n\n      logger.info(\n        `[FileLifecycle] 生命周期转换完成: 处理${processedCount}个, 转移${transferredCount}个, 删除${deletedCount}个`\n      );\n\n      return result;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 执行生命周期转换失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 处理单个文件的生命周期\n   * @param {Object} file - 文件记录\n   * @returns {Promise<Object>} 处理结果\n   * @private\n   */\n  private async processFileLifecycle(file: FileLifecycleRecord): Promise<LifecycleProcessResult> {\n    const now = new Date();\n    const strategy = this.config.strategies[file.category as FileCategory];\n\n    // 检查是否需要删除\n    const expiresAt = file.expires_at ?? now;\n\n    if (expiresAt <= now) {\n      const autoDelete = Boolean(file.auto_delete);\n      if (autoDelete) {\n        await this.deleteFile(file);\n        return { deleted: true, transferred: false };\n      } else {\n        // 不自动删除，标记为过期\n        await this.updateFileStatus(file.id, { status: 'expired' });\n        return { deleted: false, transferred: false, expired: true };\n      }\n    }\n\n    // 检查是否需要转移存储类别\n    const nextTransition = file.transitions.find(\n      (t) => new Date(t.at) <= now && !t.completed\n    );\n\n    if (nextTransition) {\n      await this.transferFileStorage(file, nextTransition);\n      return { deleted: false, transferred: true };\n    }\n\n    return { deleted: false, transferred: false };\n  }\n\n  /**\n   * 转移文件存储类别\n   * @param {Object} file - 文件记录\n   * @param {Object} transition - 转移配置\n   * @private\n   */\n  private async transferFileStorage(\n    file: FileLifecycleRecord,\n    transition: LifecycleTransitionState\n  ): Promise<void> {\n    try {\n      logger.info(`[FileLifecycle] 转移文件存储类别: ${file.key} -> ${transition.storageClass}`);\n\n      // 在实际项目中，这里会调用COS API修改存储类别\n      // await cosStorageService.changeStorageClass(file.key, transition.storageClass);\n\n      // 标记转换完成\n      transition.completed = true;\n      transition.completedAt = new Date().toISOString();\n\n      // 更新数据库记录\n      const updatedTransitions = file.transitions.map((t) => (t.at === transition.at ? transition : t));\n\n      await this.updateFileStatus(file.id, {\n        storage_class: transition.storageClass,\n        transitions: JSON.stringify(updatedTransitions)\n      });\n\n      // 计算成本节省\n      const costSaving = this.calculateCostSaving(file, transition);\n      this.stats.costSaved += costSaving;\n\n      logger.info(\n        `[FileLifecycle] 存储类别转移完成: ${file.key}, 预计节省: ¥${costSaving.toFixed(2)}`\n      );\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[FileLifecycle] 存储类别转移失败: ${file.key}`, err);\n      throw err;\n    }\n  }\n\n  /**\n   * 删除文件\n   * @param {Object} file - 文件记录\n   * @private\n   */\n  private async deleteFile(file: FileLifecycleRecord): Promise<void> {\n    try {\n      logger.info(`[FileLifecycle] 删除过期文件: ${file.key}`);\n\n      // 从COS删除文件\n      await cosStorageService.deleteFile(file.key);\n\n      // 更新数据库记录\n      await this.updateFileStatus(file.id, {\n        status: 'deleted',\n        deleted_at: new Date()\n      });\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[FileLifecycle] 删除文件失败: ${file.key}`, err);\n      throw err;\n    }\n  }\n\n  /**\n   * 强制清理指定分类的文件\n   * @param {Object} options - 清理选项\n   * @returns {Promise<Object>} 清理结果\n   */\n  async forceCleanup(options: LifecycleCleanupOptions = {}): Promise<LifecycleCleanupResult> {\n    const category = options.category ?? null;\n    const olderThanDays = options.olderThanDays ?? 7;\n    const dryRun = options.dryRun ?? false;\n    const batchSize = options.batchSize ?? 100;\n\n    try {\n      logger.info(\n        `[FileLifecycle] 强制清理 ${category || '所有'} 文件 ${dryRun ? '(干运行)' : ''}`\n      );\n\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);\n\n      let query = db('file_lifecycle_records').where('status', 'active');\n\n      if (category) {\n        query = query.where('category', category);\n      }\n\n      const filesToCleanup = (await query\n        .where('created_at', '<', cutoffDate)\n        .limit(batchSize)) as Record<string, unknown>[];\n      const normalizedFiles = filesToCleanup.map((record) => this.mapLifecycleRecord(record));\n\n      let deletedCount = 0;\n      let totalSize = 0;\n\n      for (const file of normalizedFiles) {\n        try {\n          if (!dryRun) {\n            await this.deleteFile(file);\n          }\n\n          deletedCount++;\n          totalSize += file.size;\n        } catch (error) {\n          const err = error instanceof Error ? error : new Error(String(error));\n          logger.error(`[FileLifecycle] 清理文件失败: ${file.key}`, err);\n        }\n      }\n\n      const result: LifecycleCleanupResult = {\n        success: true,\n        deletedCount,\n        totalSize,\n        category,\n        olderThanDays,\n        dryRun,\n        timestamp: new Date().toISOString()\n      };\n\n      logger.info(`[FileLifecycle] 强制清理完成: ${deletedCount}个文件`);\n\n      return result;\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 强制清理失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 获取生命周期统计信息\n   * @returns {Promise<Object>} 统计信息\n   */\n  async getLifecycleStats(): Promise<LifecycleStatsResponse> {\n    try {\n      // 获取各分类文件统计\n      const categoryStatsRaw = await db('file_lifecycle_records')\n        .select('category')\n        .count('* as count')\n        .sum('size as totalSize')\n        .where('status', 'active')\n        .groupBy('category');\n\n      const categoryStats = (categoryStatsRaw ?? []).map((row) => ({\n        category: row.category as FileCategory,\n        count: Number(row.count ?? 0),\n        totalSize: Number(row.totalSize ?? 0)\n      }));\n\n      // 获取存储类别分布\n      const storageClassRaw = await db('file_lifecycle_records')\n        .select('storage_class')\n        .count('* as count')\n        .where('status', 'active')\n        .groupBy('storage_class');\n\n      const storageClassStats = (storageClassRaw ?? []).map((row) => ({\n        storage_class: row.storage_class as FileStorageClass,\n        count: Number(row.count ?? 0)\n      }));\n\n      // 获取即将过期文件\n      const expiringSoon = await db('file_lifecycle_records')\n        .count('* as count')\n        .where('status', 'active')\n        .where('expires_at', '<=', new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)) // 7天内过期\n        .first();\n\n      return {\n        stats: { ...this.stats },\n        categoryStats,\n        storageClassStats,\n        expiringSoonCount: Number(expiringSoon?.count ?? 0),\n        config: {\n          cleanupInterval: this.config.cleanup.interval,\n          batchSize: this.config.cleanup.batchSize\n        },\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 获取统计信息失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 启动定期清理任务\n   * @private\n   */\n  startPeriodicCleanup() {\n    if (!this.config.cleanup.enabled) {\n      logger.info('[FileLifecycle] 定期清理任务已禁用');\n      return;\n    }\n\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n\n    this.cleanupTimer = setInterval(async () => {\n      try {\n        logger.info('[FileLifecycle] 执行定期清理任务');\n        await this.executeLifecycleTransitions();\n      } catch (error) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        logger.error('[FileLifecycle] 定期清理任务失败:', err);\n        this.stats.errors++;\n      }\n    }, this.config.cleanup.interval);\n\n    logger.info(\n      `[FileLifecycle] 定期清理任务已启动，间隔: ${this.config.cleanup.interval / 1000 / 60}分钟`\n    );\n  }\n\n  /**\n   * 停止定期清理任务\n   */\n  stopPeriodicCleanup() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n      logger.info('[FileLifecycle] 定期清理任务已停止');\n    }\n  }\n\n  // 辅助方法\n\n  /**\n   * 确保文件记录表存在\n   * @private\n   */\n  async ensureFileRecordsTable() {\n    try {\n      const hasTable = await db.schema.hasTable('file_lifecycle_records');\n      if (!hasTable) {\n        await this.createFileRecordsTable();\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[FileLifecycle] 检查文件记录表失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 创建文件记录表\n   * @private\n   */\n  async createFileRecordsTable() {\n    await db.schema.createTable('file_lifecycle_records', (table) => {\n      table.string('id', 36).primary().defaultTo(db.raw('(UUID())'));\n      table.string('key', 500).notNullable();\n      table.string('category', 50).notNullable();\n      table.string('task_id', 32).nullable();\n      table.string('user_id', 36).nullable();\n      table.json('metadata').nullable();\n      table.string('storage_class', 50).defaultTo('Standard');\n      table.enum('priority', ['low', 'normal', 'high']).defaultTo('normal');\n      table.enum('status', ['active', 'expired', 'deleted']).defaultTo('active');\n      table.bigInteger('size').defaultTo(0);\n      table.datetime('created_at').defaultTo(db.raw('CURRENT_TIMESTAMP'));\n      table\n        .datetime('updated_at')\n        .defaultTo(db.raw('CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP'));\n      table.datetime('expires_at').nullable();\n      table.datetime('next_transition_at').nullable();\n      table.json('transitions').nullable();\n      table.boolean('auto_delete').defaultTo(false);\n      table.datetime('deleted_at').nullable();\n\n      // 索引\n      table.index('category', 'idx_files_category');\n      table.index('status', 'idx_files_status');\n      table.index('expires_at', 'idx_files_expires');\n      table.index('next_transition_at', 'idx_files_transition');\n      table.index(['category', 'status'], 'idx_files_category_status');\n      table.index(['task_id', 'status'], 'idx_files_task_status');\n    });\n\n    logger.info('[FileLifecycle] 文件记录表创建成功');\n  }\n\n  /**\n   * 计算生命周期时间表\n   * @param {Object} strategy - 生命周期策略\n   * @param {Date} now - 当前时间\n   * @returns {Object} 生命周期时间表\n   * @private\n   */\n  private calculateLifecycleSchedule(strategy: LifecycleStrategyConfig, now: Date): LifecycleSchedule {\n    const transitions: LifecycleTransitionState[] = strategy.transitions.map(\n      (transition: LifecycleTransitionConfig, index: number) => ({\n        at: new Date(now.getTime() + transition.after).toISOString(),\n        storageClass: transition.storageClass,\n        completed: false,\n        order: index + 1\n      })\n    );\n\n    const nextTransitionAt = transitions.length > 0 ? new Date(transitions[0].at) : null;\n\n    return {\n      expiresAt: new Date(now.getTime() + strategy.ttl),\n      transitions,\n      nextTransitionAt\n    };\n  }\n\n  /**\n   * 计算成本节省\n   * @param {Object} file - 文件记录\n   * @param {Object} transition - 转移配置\n   * @returns {number} 预计节省金额\n   * @private\n   */\n  private calculateCostSaving(\n    file: FileLifecycleRecord,\n    transition: LifecycleTransitionState\n  ): number {\n    // 简化的成本计算（实际项目中会根据具体的存储定价计算）\n    const sizeGB = (file.size || 0) / (1024 * 1024 * 1024);\n    const daysInMonth = 30;\n\n    const standardPrice = 0.118; // 标准存储 ¥0.118/GB/月\n    let targetPrice = standardPrice;\n\n    switch (transition.storageClass) {\n      case 'Standard_IA':\n        targetPrice = 0.059; // 低频访问 ¥0.059/GB/月\n        break;\n      case 'Archive':\n        targetPrice = 0.012; // 归档存储 ¥0.012/GB/月\n        break;\n    }\n\n    const monthlySaving = sizeGB * (standardPrice - targetPrice);\n    const dailySaving = monthlySaving / daysInMonth;\n\n    return dailySaving;\n  }\n\n  private mapLifecycleRecord(record: Record<string, unknown>): FileLifecycleRecord {\n    const row = record as FileLifecycleRecordRow;\n\n    if (typeof row.id !== 'string' || typeof row.key !== 'string') {\n      throw new Error('Invalid file lifecycle row');\n    }\n\n    const metadata = this.safeParseJson<FileMetadata>(row.metadata, {});\n    const transitions = this.safeParseJson<LifecycleTransitionState[]>(row.transitions, []).map(\n      (transition, index) => ({\n        ...transition,\n        storageClass: this.normalizeStorageClass(transition.storageClass),\n        order: transition.order ?? index + 1,\n        completed: Boolean(transition.completed)\n      })\n    );\n\n    return {\n      id: row.id,\n      key: row.key,\n      category: this.ensureCategory(row.category),\n      task_id: row.task_id ?? null,\n      user_id: row.user_id ?? null,\n      metadata,\n      storage_class: this.normalizeStorageClass(row.storage_class),\n      priority: this.normalizePriority(row.priority),\n      status: this.normalizeStatus(row.status),\n      size: Number(row.size ?? 0),\n      created_at: this.toDateOrNow(row.created_at),\n      updated_at: this.toDateOrNow(row.updated_at),\n      expires_at: this.toOptionalDate(row.expires_at),\n      next_transition_at: this.toOptionalDate(row.next_transition_at),\n      transitions,\n      auto_delete: Boolean(row.auto_delete),\n      deleted_at: this.toOptionalDate(row.deleted_at)\n    };\n  }\n\n  private ensureCategory(category?: string | null): FileCategory {\n    const valid: FileCategory[] = ['temp', 'intermediate', 'userUpload', 'result', 'log'];\n    if (category && valid.includes(category as FileCategory)) {\n      return category as FileCategory;\n    }\n    logger.warn(`[FileLifecycle] 未知文件分类 ${category}, 默认归类为 temp`);\n    return 'temp';\n  }\n\n  private normalizeStorageClass(value?: string | null): FileStorageClass {\n    if (value === 'Standard_IA' || value === 'Archive') {\n      return value;\n    }\n    return 'Standard';\n  }\n\n  private normalizeStatus(value?: string | null): FileLifecycleRecord['status'] {\n    if (value === 'expired' || value === 'deleted') {\n      return value;\n    }\n    return 'active';\n  }\n\n  private toOptionalDate(value?: Date | string | null): Date | null {\n    if (!value) return null;\n    if (value instanceof Date) return value;\n    const parsed = new Date(value);\n    return Number.isNaN(parsed.getTime()) ? null : parsed;\n  }\n\n  private toDateOrNow(value?: Date | string | null): Date {\n    return this.toOptionalDate(value) ?? new Date();\n  }\n\n  private safeParseJson<T>(raw: string | null, fallback: T): T {\n    if (!raw) return fallback;\n    try {\n      return JSON.parse(raw) as T;\n    } catch (error) {\n      logger.warn('[FileLifecycle] JSON解析失败，使用默认值', { error });\n      return fallback;\n    }\n  }\n\n  private normalizePriority(priority?: string): FilePriority {\n    if (priority === 'low' || priority === 'normal' || priority === 'high') {\n      return priority;\n    }\n    return 'normal';\n  }\n\n  /**\n   * 生成文件ID\n   * @returns {string} 文件ID\n   * @private\n   */\n  private generateFileId(): string {\n    return crypto.randomBytes(16).toString('hex');\n  }\n\n  /**\n   * 延迟函数\n   * @param {number} ms - 延迟毫秒数\n   * @private\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * 健康检查\n   */\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'initializing';\n    stats: FileLifecycleStats;\n    timestamp: string;\n  }> {\n    return {\n      status: this.initialized ? 'healthy' : 'initializing',\n      stats: { ...this.stats },\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\nconst fileLifecycleService = new FileLifecycleService();\n\nexport default fileLifecycleService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/file-management.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/health.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/hunyuan.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/hunyuan.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const hunyuanService: {\n  generateShootingScript: (imageUrl: string, params?: Record<string, unknown>) => Promise<string>;\n  validateScript: (script: string) => boolean;\n};\n\nexport default hunyuanService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/hunyuan.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/i18n.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/imageProcess.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/imageProcess.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface PicOperationRule {\n  fileid: string;\n  rule: string;\n}\n\ninterface PicOperations {\n  is_pic_info: number;\n  rules: PicOperationRule[];\n}\n\ninterface ImageInfo {\n  format?: string;\n  size?: number;\n  width?: number;\n  height?: number;\n}\n\ndeclare class ImageProcessService {\n  processBasicClean(\n    taskId: string,\n    inputImageUrl: string,\n    params?: Record<string, unknown>\n  ): Promise<string[]>;\n  buildPicOperations(taskId: string, params?: Record<string, unknown>): PicOperations;\n  processCloudImage(imageUrl: string, picOperations: PicOperations): Promise<string[]>;\n  processExternalImage(\n    taskId: string,\n    imageUrl: string,\n    picOperations: PicOperations\n  ): Promise<string[]>;\n  downloadImage(url: string): Promise<Buffer>;\n  uploadImageToCos(key: string, buffer: Buffer, originalUrl: string): Promise<void>;\n  getImageInfo(imageUrl: string): Promise<ImageInfo>;\n  validateImage(imageUrl: string): Promise<boolean>;\n  retry<T>(fn: () => Promise<T>, maxRetries?: number, delay?: number): Promise<T>;\n}\n\ndeclare const imageProcessService: ImageProcessService;\nexport default imageProcessService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/imageProcess.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `taskId:·string,·inputImageUrl:·string,·params:·Record<string,·unknown>·=·{}` with `⏎····taskId:·string,⏎····inputImageUrl:·string,⏎····params:·Record<string,·unknown>·=·{}⏎··`","line":66,"column":27,"nodeType":null,"messageId":"replace","endLine":66,"endColumn":102,"fix":{"range":[1487,1562],"text":"\n    taskId: string,\n    inputImageUrl: string,\n    params: Record<string, unknown> = {}\n  "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport COS from 'cos-nodejs-sdk-v5';\nimport logger from '../utils/logger.js';\nimport taskService from './task.service.js';\nimport contentAuditService from './contentAudit.service.js';\n\ninterface PicOperations {\n  is_pic_info: number;\n  rules: Array<{\n    fileid: string;\n    rule: string;\n  }>;\n}\n\ninterface CosProcessResult {\n  ProcessResults?: {\n    Object?: unknown | unknown[];\n  };\n}\n\ninterface ProcessedObject {\n  Location?: string;\n}\n\ninterface ImageInfo {\n  format?: string;\n  size?: number;\n  width?: number;\n  height?: number;\n}\n\ninterface CosCallback {\n  (err: unknown, data: unknown): void;\n}\n\ninterface CosProcessResultObject {\n  Location?: string;\n  [key: string]: unknown;\n}\n\nclass ImageProcessService {\n  private config = {\n    bucket: process.env.COS_BUCKET,\n    region: process.env.COS_REGION,\n    secretId: process.env.TENCENT_SECRET_ID,\n    secretKey: process.env.TENCENT_SECRET_KEY\n  };\n\n  private cos: COS;\n  private useMock: boolean;\n\n  constructor() {\n    this.cos = new COS({ SecretId: this.config.secretId, SecretKey: this.config.secretKey });\n    if (!this.config.bucket || !this.config.secretId || !this.config.secretKey) {\n      logger.warn('[ImageProcessService] 腾讯云配置不完整，将使用Mock模式');\n      this.useMock = true;\n    } else {\n      this.useMock = false;\n      logger.info('[ImageProcessService] 腾讯云数据万象服务已初始化', {\n        bucket: this.config.bucket,\n        region: this.config.region\n      });\n    }\n  }\n\n  async processBasicClean(taskId: string, inputImageUrl: string, params: Record<string, unknown> = {}) {\n    try {\n      logger.info(`[ImageProcessService] 开始处理基础修图 taskId=${taskId}`, {\n        inputImageUrl,\n        useMock: this.useMock\n      });\n      await taskService.updateStatus(taskId, 'processing', {});\n      let resultUrls: string[];\n      if (this.useMock) {\n        resultUrls = await this.mockProcessBasicClean(taskId, inputImageUrl);\n      } else {\n        const picOperations = this.buildPicOperations(taskId, params);\n        if (inputImageUrl.includes(String(this.config.bucket))) {\n          resultUrls = await this.processCloudImage(inputImageUrl, picOperations);\n        } else {\n          resultUrls = await this.processExternalImage(taskId, inputImageUrl, picOperations);\n        }\n      }\n      logger.info(`[ImageProcessService] 图片处理完成,开始内容审核 taskId=${taskId}`);\n      const auditResult = await contentAuditService.auditTaskResults(taskId, resultUrls);\n      if (!auditResult.pass) {\n        logger.warn(`[ImageProcessService] 内容审核未通过 taskId=${taskId}`);\n        throw new Error('内容审核未通过');\n      }\n      await taskService.updateStatus(taskId, 'success', { resultUrls });\n      logger.info(`[ImageProcessService] 基础修图完成 taskId=${taskId} count=${resultUrls.length}`);\n      return resultUrls;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : '未知错误';\n      logger.error(`[ImageProcessService] 基础修图失败: ${message}`, { taskId, error });\n      await taskService.updateStatus(taskId, 'failed', {\n        errorMessage: message || '图片处理失败'\n      });\n      throw error;\n    }\n  }\n\n  buildPicOperations(taskId: string, _params: Record<string, unknown> = {}): PicOperations {\n    return {\n      is_pic_info: 1,\n      rules: [\n        { fileid: `output/${taskId}/matting.png`, rule: 'imageMogr2/cut-out' },\n        {\n          fileid: `output/${taskId}/white-bg.png`,\n          rule: 'imageMogr2/cut-out|imageMogr2/background/color/ffffff'\n        },\n        {\n          fileid: `output/${taskId}/enhanced.png`,\n          rule: 'imageMogr2/cut-out|imageMogr2/background/color/ffffff|imageMogr2/sharpen/1|imageMogr2/bright/10'\n        }\n      ]\n    };\n  }\n\n  async processCloudImage(imageUrl: string, picOperations: PicOperations): Promise<string[]> {\n    try {\n      const objectKey = this.extractObjectKeyFromUrl(imageUrl);\n      if (!objectKey) throw new Error('无法从URL中提取COS对象键');\n      logger.info('[ImageProcessService] 开始云上数据处理', {\n        objectKey,\n        rulesCount: picOperations.rules.length\n      });\n      const result: CosProcessResult = await new Promise((resolve, reject) => {\n        const callback: CosCallback = (err: unknown, data: unknown) => {\n          if (err) {\n            const message = err instanceof Error ? err.message : String(err);\n            logger.error('[ImageProcessService] 云上数据处理失败', err);\n            reject(new Error(`数据万象处理失败: ${message}`));\n          } else {\n            resolve(data as CosProcessResult);\n          }\n        };\n        this.cos.processObject(\n          {\n            Bucket: this.config.bucket,\n            Region: this.config.region,\n            Key: objectKey,\n            PicOperations: JSON.stringify(picOperations)\n          },\n          callback\n        );\n      });\n      const outputUrls: string[] = [];\n      const objects = result?.ProcessResults?.Object;\n      const list = Array.isArray(objects) ? objects : objects ? [objects] : [];\n      list.forEach((obj: unknown): void => {\n        const processedObj = obj as ProcessedObject;\n        if (processedObj.Location) {\n          let url: string = processedObj.Location;\n          if (url.startsWith('//')) url = 'https:' + url;\n          outputUrls.push(url);\n        }\n      });\n      if (outputUrls.length === 0) throw new Error('数据万象处理完成但未返回结果');\n      return outputUrls;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('[ImageProcessService] 云上数据处理异常', { imageUrl, error: message });\n      throw error;\n    }\n  }\n\n  async processExternalImage(\n    taskId: string,\n    imageUrl: string,\n    picOperations: PicOperations\n  ): Promise<string[]> {\n    try {\n      logger.info('[ImageProcessService] 开始处理外部图片', {\n        taskId,\n        imageUrl,\n        rulesCount: picOperations.rules.length\n      });\n      const imageBuffer = await this.downloadImage(imageUrl);\n      const originalKey = `input/${taskId}/original.jpg`;\n      await this.uploadImageToCos(originalKey, imageBuffer, imageUrl);\n      const uploadedUrl = `https://${this.config.bucket}.cos.${this.config.region}.myqcloud.com/${originalKey}`;\n      const resultUrls = await this.processCloudImage(uploadedUrl, picOperations);\n      logger.info('[ImageProcessService] 外部图片处理完成', {\n        taskId,\n        originalKey,\n        outputCount: resultUrls.length\n      });\n      return resultUrls;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('[ImageProcessService] 外部图片处理异常', {\n        taskId,\n        imageUrl,\n        error: message\n      });\n      throw error;\n    }\n  }\n\n  async downloadImage(url: string): Promise<Buffer> {\n    try {\n      logger.info('[ImageProcessService] 开始下载图片', { url });\n      const response = await axios.get(url, {\n        responseType: 'arraybuffer',\n        timeout: 30000,\n        headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }\n      });\n      const buffer = Buffer.from(response.data);\n      logger.info('[ImageProcessService] 图片下载完成', {\n        url,\n        size: buffer.length,\n        contentType: response.headers['content-type']\n      });\n      return buffer;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error(`[ImageProcessService] 下载图片失败: ${message}`, { url });\n      throw new Error(`下载图片失败: ${message}`);\n    }\n  }\n\n  async uploadImageToCos(key: string, buffer: Buffer, originalUrl: string): Promise<void> {\n    try {\n      logger.info('[ImageProcessService] 开始上传图片到COS', { key, size: buffer.length });\n      let contentType = 'image/jpeg';\n      try {\n        const head = await axios.head(originalUrl, { timeout: 5000 });\n        contentType = head.headers['content-type'] || contentType;\n      } catch {\n        logger.warn('[ImageProcessService] 无法获取原始图片Content-Type，使用默认值');\n      }\n      await new Promise<void>((resolve, reject) => {\n        const callback: CosCallback = (err: unknown, data: unknown) => {\n          if (err) {\n            const message = err instanceof Error ? err.message : String(err);\n            logger.error('[ImageProcessService] COS上传失败', err);\n            reject(new Error(`COS上传失败: ${message}`));\n          } else {\n            resolve();\n          }\n        };\n        this.cos.putObject(\n          {\n            Bucket: this.config.bucket,\n            Region: this.config.region,\n            Key: key,\n            Body: buffer,\n            ContentType: contentType\n          },\n          callback\n        );\n      });\n      logger.info('[ImageProcessService] COS上传完成', { key });\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('[ImageProcessService] COS上传异常', { key, error: message });\n      throw error;\n    }\n  }\n\n  async getImageInfo(imageUrl: string): Promise<ImageInfo> {\n    try {\n      const infoUrl = `${imageUrl}?imageInfo`;\n      const response = await axios.get(infoUrl, { timeout: 10000 });\n      return response.data as ImageInfo;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error(`[ImageProcessService] 获取图片信息失败: ${message}`, { imageUrl });\n      throw new Error('获取图片信息失败');\n    }\n  }\n\n  async validateImage(imageUrl: string): Promise<boolean> {\n    const info = await this.getImageInfo(imageUrl);\n    const format = String(info.format || '').toLowerCase();\n    if (!['jpg', 'jpeg', 'png'].includes(format)) throw new Error('不支持的图片格式,仅支持JPG/PNG');\n    const maxSize = 10 * 1024 * 1024;\n    if (info.size > maxSize) throw new Error('图片大小超过10MB限制');\n    if (info.width < 100 || info.height < 100) throw new Error('图片尺寸过小,最小100x100像素');\n    return true;\n  }\n\n  async mockProcessBasicClean(taskId: string, _inputImageUrl: string): Promise<string[]> {\n    logger.info('[ImageProcessService] Mock模式处理基础修图', { taskId });\n    await new Promise((r) => setTimeout(r, 2000));\n    return [\n      `http://localhost:3000/mock-images/${taskId}/matting.png`,\n      `http://localhost:3000/mock-images/${taskId}/white-bg.png`,\n      `http://localhost:3000/mock-images/${taskId}/enhanced.png`\n    ];\n  }\n\n  extractObjectKeyFromUrl(url: string): string | null {\n    try {\n      const urlObj = new URL(url);\n      if (!urlObj.hostname.includes('cos.') || !urlObj.hostname.includes('myqcloud.com')) {\n        logger.warn('[ImageProcessService] 非COS域名URL', { url });\n        return null;\n      }\n      let objectKey = urlObj.pathname;\n      if (objectKey.startsWith('/')) objectKey = objectKey.substring(1);\n      const queryIndex = objectKey.indexOf('?');\n      if (queryIndex > -1) objectKey = objectKey.substring(0, queryIndex);\n      return objectKey;\n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      logger.error('[ImageProcessService] 解析COS URL失败', { url, error: message });\n      return null;\n    }\n  }\n\n  async retry<T>(fn: () => Promise<T>, maxRetries = 3, delay = 1000): Promise<T> {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return await fn();\n      } catch (error: unknown) {\n        if (i === maxRetries - 1) throw error;\n        const message = error instanceof Error ? error.message : String(error);\n        logger.warn('[ImageProcessService] 操作失败，准备重试', {\n          attempt: i + 1,\n          maxRetries,\n          error: message\n        });\n        await new Promise((resolve) => setTimeout(resolve, delay * (i + 1)));\n      }\n    }\n    throw new Error('未能完成重试操作');\n  }\n}\n\nexport default new ImageProcessService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/importExport.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `options?:·ExportOptions` with `⏎··options?:·ExportOptions⏎`","line":125,"column":46,"nodeType":null,"messageId":"replace","endLine":125,"endColumn":69,"fix":{"range":[2059,2082],"text":"\n  options?: ExportOptions\n"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `ContentTextExport[]·|·AnnouncementExport[]·|·BannerExport[]·|·PlanExport[]·|·BenefitExport[]·|·string` with `⏎··|·ContentTextExport[]⏎··|·AnnouncementExport[]⏎··|·BannerExport[]⏎··|·PlanExport[]⏎··|·BenefitExport[]⏎··|·string⏎`","line":323,"column":12,"nodeType":null,"messageId":"replace","endLine":323,"endColumn":113,"fix":{"range":[6377,6478],"text":"\n  | ContentTextExport[]\n  | AnnouncementExport[]\n  | BannerExport[]\n  | PlanExport[]\n  | BenefitExport[]\n  | string\n"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\n * Import/Export Service\n * 艹，通用批量导入导出服务！\n * 支持CSV和JSON格式\n */\n\nimport * as textRepo from '../repositories/contentTexts.repo.js';\nimport * as announcementRepo from '../repositories/announcements.repo.js';\nimport * as bannerRepo from '../repositories/banners.repo.js';\nimport * as planRepo from '../repositories/membershipPlans.repo.js';\nimport * as benefitRepo from '../repositories/membershipBenefits.repo.js';\n\n/**\n * 内容文案导出对象\n */\nexport interface ContentTextExport {\n  page: string;\n  section: string;\n  key: string;\n  language: string;\n  value: string;\n  description?: string;\n  status: string;\n}\n\n/**\n * 公告导出对象\n */\ninterface AnnouncementExport {\n  title: string;\n  content: string;\n  type: string;\n  position: string;\n  priority: number;\n  status: string;\n  publish_at?: string | null;\n  expire_at?: string | null;\n  target_audience?: string;\n}\n\n/**\n * 轮播图导出对象\n */\ninterface BannerExport {\n  title: string;\n  image_url: string;\n  link_url: string;\n  description?: string;\n  sort_order: number;\n  status: string;\n  publish_at?: string | null;\n  expire_at?: string | null;\n  target_audience?: string;\n}\n\n/**\n * 套餐导出对象\n */\ninterface PlanExport {\n  name: string;\n  slug: string;\n  description?: string;\n  price: number;\n  currency: string;\n  duration_days: number;\n  quota_uploads: number;\n  quota_storage: number;\n  quota_features: number;\n  status: string;\n  sort_order: number;\n  is_default: boolean;\n  is_popular: boolean;\n}\n\n/**\n * 权益导出对象\n */\ninterface BenefitExport {\n  name: string;\n  key: string;\n  description?: string;\n  type: string;\n  value: unknown;\n  icon?: string;\n  color?: string;\n  status: string;\n}\n\n/**\n * 导入错误对象\n */\ninterface ImportError {\n  error: string;\n  [key: string]: unknown;\n}\n\n/**\n * 导入结果\n */\ninterface ImportResult {\n  created: number;\n  updated: number;\n  errors: ImportError[];\n}\n\n/**\n * 导出选项\n */\ninterface ExportOptions {\n  page?: string;\n  language?: string;\n  [key: string]: unknown;\n}\n\n/**\n * CSV行对象\n */\ninterface CSVRow {\n  [key: string]: unknown;\n}\n\n/**\n * 导出文案为JSON\n */\nexport async function exportContentTextsJSON(options?: ExportOptions): Promise<ContentTextExport[]> {\n  const texts = await textRepo.listTexts({\n    page: options?.page,\n    language: options?.language,\n    limit: 10000 // 艹，大批量导出\n  });\n\n  return texts.map((t) => ({\n    page: t.page,\n    section: t.section,\n    key: t.key,\n    language: t.language,\n    value: t.value,\n    description: t.description,\n    status: t.status\n  }));\n}\n\n/**\n * 导出文案为CSV\n */\nexport function convertToCSV(data: CSVRow[], fields: string[]): string {\n  // 艹，CSV头部\n  const header = fields.join(',');\n\n  // 艹，CSV行\n  const rows = data.map((item) =>\n    fields\n      .map((field) => {\n        const value = item[field] || '';\n        // 转义双引号和换行符\n        return `\"${String(value).replace(/\"/g, '\"\"').replace(/\\n/g, ' ')}\"`;\n      })\n      .join(',')\n  );\n\n  return [header, ...rows].join('\\n');\n}\n\n/**\n * 导出文案为CSV格式\n */\nexport async function exportContentTextsCSV(options?: {\n  page?: string;\n  language?: string;\n}): Promise<string> {\n  const data = await exportContentTextsJSON(options);\n  const fields = ['page', 'section', 'key', 'language', 'value', 'description', 'status'];\n  return convertToCSV(data, fields);\n}\n\n/**\n * 导入文案JSON\n */\nexport async function importContentTextsJSON(\n  data: ContentTextExport[],\n  updated_by?: number\n): Promise<ImportResult> {\n  const errors: ImportError[] = [];\n  let created = 0;\n  let updated = 0;\n\n  try {\n    const result = await textRepo.batchUpsertTexts(data, updated_by);\n    created = result.created;\n    updated = result.updated;\n  } catch (error: unknown) {\n    const err = error as Error;\n    errors.push({ error: err.message });\n  }\n\n  return { created, updated, errors };\n}\n\n/**\n * 解析CSV为JSON\n */\nexport function parseCSV(csvContent: string): CSVRow[] {\n  const lines = csvContent.trim().split('\\n');\n  if (lines.length < 2) return [];\n\n  // 艹，解析头部\n  const header = lines[0].split(',').map((h) => h.trim());\n\n  // 艹，解析数据行\n  const data: CSVRow[] = [];\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    if (!line.trim()) continue;\n\n    // 简单CSV解析（不处理复杂的引号转义）\n    const values = line.split(',').map((v) => v.trim().replace(/^\"(.*)\"$/, '$1'));\n\n    const obj: CSVRow = {};\n    header.forEach((key, index) => {\n      obj[key] = values[index] || null;\n    });\n\n    data.push(obj);\n  }\n\n  return data;\n}\n\n/**\n * 导出公告为JSON\n */\nexport async function exportAnnouncementsJSON(): Promise<AnnouncementExport[]> {\n  const announcements = await announcementRepo.listAnnouncements({\n    limit: 10000\n  });\n\n  return announcements.map((a) => ({\n    title: a.title,\n    content: a.content,\n    type: a.type,\n    position: a.position,\n    priority: a.priority,\n    status: a.status,\n    publish_at: a.publish_at,\n    expire_at: a.expire_at,\n    target_audience: a.target_audience\n  }));\n}\n\n/**\n * 导出轮播图为JSON\n */\nexport async function exportBannersJSON(): Promise<BannerExport[]> {\n  const banners = await bannerRepo.listBanners({\n    limit: 10000\n  });\n\n  return banners.map((b) => ({\n    title: b.title,\n    image_url: b.image_url,\n    link_url: b.link_url,\n    description: b.description,\n    sort_order: b.sort_order,\n    status: b.status,\n    publish_at: b.publish_at,\n    expire_at: b.expire_at,\n    target_audience: b.target_audience\n  }));\n}\n\n/**\n * 导出套餐为JSON\n */\nexport async function exportPlansJSON(): Promise<PlanExport[]> {\n  const plans = await planRepo.listPlans({\n    limit: 10000\n  });\n\n  return plans.map((p) => ({\n    name: p.name,\n    slug: p.slug,\n    description: p.description,\n    price: p.price,\n    currency: p.currency,\n    duration_days: p.duration_days,\n    quota_uploads: p.quota_uploads,\n    quota_storage: p.quota_storage,\n    quota_features: p.quota_features,\n    status: p.status,\n    sort_order: p.sort_order,\n    is_default: p.is_default,\n    is_popular: p.is_popular\n  }));\n}\n\n/**\n * 导出权益为JSON\n */\nexport async function exportBenefitsJSON(): Promise<BenefitExport[]> {\n  const benefits = await benefitRepo.listBenefits({\n    limit: 10000\n  });\n\n  return benefits.map((b) => ({\n    name: b.name,\n    key: b.key,\n    description: b.description,\n    type: b.type,\n    value: b.value,\n    icon: b.icon,\n    color: b.color,\n    status: b.status\n  }));\n}\n\n/**\n * 通用导出函数\n */\nexport async function exportEntity(\n  entityType: string,\n  format: 'json' | 'csv' = 'json',\n  options?: ExportOptions\n): Promise<ContentTextExport[] | AnnouncementExport[] | BannerExport[] | PlanExport[] | BenefitExport[] | string> {\n  let data: CSVRow[];\n\n  switch (entityType) {\n    case 'content_texts':\n      data = await exportContentTextsJSON(options);\n      break;\n    case 'announcements':\n      data = await exportAnnouncementsJSON();\n      break;\n    case 'banners':\n      data = await exportBannersJSON();\n      break;\n    case 'plans':\n      data = await exportPlansJSON();\n      break;\n    case 'benefits':\n      data = await exportBenefitsJSON();\n      break;\n    default:\n      throw new Error(`不支持的实体类型: ${entityType}`);\n  }\n\n  if (format === 'csv') {\n    const fields = Object.keys(data[0] || {});\n    return convertToCSV(data, fields);\n  }\n\n  return data;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/invite-code.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `options:·InviteUsageLogOptions·=·{}` with `⏎····options:·InviteUsageLogOptions·=·{}⏎··`","line":499,"column":28,"nodeType":null,"messageId":"replace","endLine":499,"endColumn":63,"fix":{"range":[14023,14058],"text":"\n    options: InviteUsageLogOptions = {}\n  "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import crypto from 'crypto';\nimport logger from '../utils/logger.js';\nimport { db } from '../config/database.js';\nimport cacheService from './cache.service.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\n\ntype InviteCodeStatus = 'active' | 'used' | 'expired' | 'disabled';\n\ntype CountRow = {\n  count?: string | number | bigint | null;\n};\n\ntype GenerateCodesOptions = {\n  count?: number;\n  type?: string;\n  maxUses?: number;\n  validDays?: number;\n  batchName?: string | null;\n  description?: string | null;\n  createdBy?: string;\n};\n\ntype InviteCode = {\n  id: string;\n  code: string;\n  type: string;\n  status: InviteCodeStatus;\n  creator_id: string | null;\n  creator_type: string;\n  max_uses: number;\n  used_count: number;\n  expires_at: Date | string;\n  batch_id: string;\n  inviter_id: string | null;\n  invitee_id: string | null;\n  created_by: string;\n  created_at: Date | string;\n  updated_at: Date | string;\n  last_used_at?: Date | string;\n};\n\ntype InviteCodeBatch = {\n  id: string;\n  batch_name: string;\n  description: string;\n  type: string;\n  count: number;\n  valid_days: number;\n  max_uses_per_code: number;\n  created_by: string;\n  generation_config: Record<string, unknown>;\n};\n\ntype UsageData = {\n  inviteeId?: string | null;\n  inviterId?: string | null;\n  inviteeEmail?: string | null;\n  inviteePhone?: string | null;\n  ipAddress?: string | null;\n  userAgent?: string | null;\n  metadata?: Record<string, unknown>;\n};\n\ntype UseInviteCodeResult = {\n  success: boolean;\n  inviteCode: {\n    id: string;\n    type: string;\n    remainingUses: number;\n  };\n};\n\ntype GetCodesOptions = {\n  status?: string;\n  type?: string;\n  creatorId?: string;\n  inviterId?: string;\n  inviteeId?: string;\n  batchId?: string;\n  page?: number;\n  limit?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n};\n\ntype UserInviteStats = {\n  user_id: string;\n  total_invites: number;\n  successful_invites: number;\n  pending_invites: number;\n  failed_invites: number;\n  total_rewards: number;\n  last_invite_date: string | null;\n  monthly_stats: Record<string, unknown>;\n  created_at?: Date | string;\n  updated_at?: Date | string;\n};\n\ntype InviteStats = {\n  total: number;\n  active: number;\n  used: number;\n  expired: number;\n  disabled: number;\n  byType: Record<string, number>;\n  initialized: boolean;\n  cachePrefix: string;\n  cacheTTL: number;\n};\n\nconst parseCount = (row?: CountRow): number => {\n  if (!row || row.count === undefined || row.count === null) {\n    return 0;\n  }\n\n  if (typeof row.count === 'number') {\n    return row.count;\n  }\n\n  if (typeof row.count === 'bigint') {\n    return Number(row.count);\n  }\n\n  const parsed = Number(row.count);\n  return Number.isFinite(parsed) ? parsed : 0;\n};\n\nclass InviteCodeService {\n  private initialized = false;\n  private readonly cachePrefix = 'invite_code:';\n  private readonly cacheTTL = 300;\n  private readonly codeLength = 8;\n  private readonly codePattern = /^[A-Z0-9]+$/;\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    logger.info('[InviteCodeService] Initializing invite code service...');\n    await db('invite_codes').select(1).first();\n    await this.cleanupExpiredCodes();\n    this.initialized = true;\n    logger.info('[InviteCodeService] Invite code service initialized successfully');\n  }\n\n  generateCode(length: number = this.codeLength): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let code = '';\n\n    for (let i = 0; i < length; i += 1) {\n      code += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n\n    return code;\n  }\n\n  async generateInviteCodes(options: GenerateCodesOptions = {}): Promise<InviteCode[]> {\n    const {\n      count = 10,\n      type = 'general',\n      maxUses = 1,\n      validDays = 30,\n      batchName = null,\n      description = null,\n      createdBy = 'system'\n    } = options;\n\n    const codes: InviteCode[] = [];\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + validDays);\n\n    const trx = await db.transaction();\n\n    try {\n      const [batch] = await trx('invite_code_batches')\n        .insert({\n          batch_name: batchName || `Batch_${Date.now()}`,\n          description: description || `批量生成${count}个${type}类型邀请码`,\n          type,\n          count,\n          valid_days: validDays,\n          max_uses_per_code: maxUses,\n          created_by: createdBy,\n          generation_config: {\n            codeLength: this.codeLength,\n            expiresAt: expiresAt.toISOString()\n          }\n        })\n        .returning('*');\n\n      for (let i = 0; i < count; i += 1) {\n        let code: string;\n        let attempts = 0;\n        const maxAttempts = 10;\n\n        do {\n          code = this.generateCode();\n          attempts += 1;\n          if (attempts > maxAttempts) {\n            throw new Error('Failed to generate unique invite code after multiple attempts');\n          }\n        } while (await this.isCodeExists(code));\n\n        const [inviteCode] = await trx('invite_codes')\n          .insert({\n            code,\n            type,\n            status: 'active',\n            creator_id: null,\n            creator_type: 'system',\n            max_uses: maxUses,\n            used_count: 0,\n            expires_at: expiresAt,\n            batch_id: batch.id,\n            created_by: createdBy,\n            created_at: new Date(),\n            updated_at: new Date()\n          })\n          .returning('*');\n\n        codes.push(inviteCode);\n      }\n\n      await trx.commit();\n      logger.info(`[InviteCodeService] Generated ${codes.length} invite codes of type ${type}`);\n      return codes;\n    } catch (error) {\n      await trx.rollback();\n      logger.error('[InviteCodeService] Failed to generate invite codes:', error);\n      throw AppError.fromError(error, ERROR_CODES.TASK_CREATION_FAILED);\n    }\n  }\n\n  async isCodeExists(code: string): Promise<boolean> {\n    const existing = await db('invite_codes').where('code', code).first();\n    return Boolean(existing);\n  }\n\n  async validateInviteCode(code: string): Promise<InviteCode> {\n    const normalizedCode = code.toUpperCase().trim();\n\n    if (!this.codePattern.test(normalizedCode)) {\n      throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        code: normalizedCode,\n        reason: 'INVALID_FORMAT'\n      });\n    }\n\n    const cacheKey = `${this.cachePrefix}validate:${normalizedCode}`;\n    const cachedData = await cacheService.get(cacheKey);\n\n    if (cachedData) {\n      logger.debug(`[InviteCodeService] Cache hit for code ${normalizedCode}`);\n      return cachedData;\n    }\n\n    const inviteCode = await db('invite_codes').where('code', normalizedCode).first();\n\n    if (!inviteCode) {\n      throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        code: normalizedCode,\n        reason: 'CODE_NOT_FOUND'\n      });\n    }\n\n    if (inviteCode.status !== 'active') {\n      throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        code: normalizedCode,\n        reason: 'CODE_NOT_ACTIVE',\n        status: inviteCode.status\n      });\n    }\n\n    if (inviteCode.expires_at && new Date(inviteCode.expires_at) < new Date()) {\n      throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        code: normalizedCode,\n        reason: 'CODE_EXPIRED'\n      });\n    }\n\n    if (inviteCode.max_uses && inviteCode.used_count >= inviteCode.max_uses) {\n      throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n        code: normalizedCode,\n        reason: 'CODE_USED_UP'\n      });\n    }\n\n    await cacheService.set(cacheKey, inviteCode, { ttl: this.cacheTTL });\n    return inviteCode;\n  }\n\n  async useInviteCode(code: string, usageData: UsageData = {}): Promise<UseInviteCodeResult> {\n    const normalizedCode = code.toUpperCase().trim();\n\n    return db.transaction(async (trx) => {\n      const inviteCode = await trx('invite_codes')\n        .where('code', normalizedCode)\n        .forUpdate()\n        .first();\n\n      if (!inviteCode) {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          code: normalizedCode,\n          reason: 'CODE_NOT_FOUND'\n        });\n      }\n\n      if (inviteCode.status !== 'active') {\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          code: normalizedCode,\n          reason: 'CODE_NOT_ACTIVE',\n          status: inviteCode.status\n        });\n      }\n\n      if (inviteCode.expires_at && new Date(inviteCode.expires_at) < new Date()) {\n        await trx('invite_codes')\n          .where('code', normalizedCode)\n          .update({ status: 'expired', updated_at: new Date() });\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          code: normalizedCode,\n          reason: 'CODE_EXPIRED'\n        });\n      }\n\n      if (inviteCode.max_uses && inviteCode.used_count >= inviteCode.max_uses) {\n        await trx('invite_codes')\n          .where('code', normalizedCode)\n          .update({ status: 'used', updated_at: new Date() });\n        throw AppError.create(ERROR_CODES.INVALID_PARAMETERS, {\n          code: normalizedCode,\n          reason: 'CODE_USED_UP'\n        });\n      }\n\n      const now = new Date();\n      const inviteeId = usageData.inviteeId || null;\n      const inviterId = usageData.inviterId || inviteCode.inviter_id || null;\n      const inviteeEmail = usageData.inviteeEmail || null;\n      const inviteePhone = usageData.inviteePhone || null;\n      const ipAddress = usageData.ipAddress || null;\n      const userAgent = usageData.userAgent || null;\n\n      await trx('invite_usage_logs').insert({\n        invite_code_id: inviteCode.id,\n        invite_code: inviteCode.code,\n        inviter_id: inviterId,\n        invitee_id: inviteeId,\n        invitee_email: inviteeEmail,\n        invitee_phone: inviteePhone,\n        status: 'pending',\n        metadata: usageData.metadata || {},\n        ip_address: ipAddress,\n        user_agent: userAgent,\n        created_at: now,\n        updated_at: now\n      });\n\n      const newUsedCount = inviteCode.used_count + 1;\n      const newStatus =\n        inviteCode.max_uses && newUsedCount >= inviteCode.max_uses ? 'used' : inviteCode.status;\n\n      await trx('invite_codes').where('code', normalizedCode).update({\n        used_count: newUsedCount,\n        status: newStatus,\n        last_used_at: now,\n        updated_at: now\n      });\n\n      if (inviterId) {\n        await this.updateUserInviteStats(inviterId, 'success');\n      }\n\n      if (inviteeId) {\n        await this.updateUserInviteStats(inviteeId, 'received');\n      }\n\n      await cacheService.delete(`${this.cachePrefix}validate:${normalizedCode}`);\n\n      logger.info(`[InviteCodeService] Invite code used: ${normalizedCode} by ${inviteeId}`);\n\n      return {\n        success: true,\n        inviteCode: {\n          id: inviteCode.id,\n          type: inviteCode.type,\n          remainingUses: inviteCode.max_uses - newUsedCount\n        }\n      };\n    });\n  }\n\n  async getInviteCodes(options: GetCodesOptions = {}): Promise<InviteCode[]> {\n    const {\n      status,\n      type,\n      creatorId,\n      inviterId,\n      inviteeId,\n      batchId,\n      page = 1,\n      limit = 20,\n      sortBy = 'created_at',\n      sortOrder = 'desc'\n    } = options;\n\n    let query = db('invite_codes')\n      .select('*')\n      .orderBy(\n        sortBy === 'updated_at' ? 'updated_at' : 'created_at',\n        sortOrder === 'asc' ? 'asc' : 'desc'\n      );\n\n    if (status) query = query.where('status', status);\n    if (type) query = query.where('type', type);\n    if (creatorId) query = query.where('creator_id', creatorId);\n    if (inviterId) query = query.where('inviter_id', inviterId);\n    if (inviteeId) query = query.where('invitee_id', inviteeId);\n    if (batchId) query = query.where('batch_id', batchId);\n\n    const offset = (page - 1) * limit;\n    query = query.limit(limit).offset(offset);\n\n    return query;\n  }\n\n  async updateUserInviteStats(\n    userId: string,\n    action: 'created' | 'success' | 'failed' | 'received'\n  ): Promise<void> {\n    const now = new Date();\n    const today = now.toISOString().split('T')[0];\n\n    await db.transaction(async (trx) => {\n      let stats = await trx('user_invite_stats').where('user_id', userId).first();\n\n      if (!stats) {\n        [stats] = await trx('user_invite_stats')\n          .insert({\n            user_id: userId,\n            total_invites: 0,\n            successful_invites: 0,\n            pending_invites: 0,\n            failed_invites: 0,\n            total_rewards: 0,\n            last_invite_date: null,\n            monthly_stats: {},\n            created_at: now,\n            updated_at: now\n          })\n          .returning('*');\n      }\n\n      const updates: Record<string, unknown> = { updated_at: now };\n\n      switch (action) {\n        case 'created':\n          updates.total_invites = Number(stats.total_invites || 0) + 1;\n          updates.pending_invites = Number(stats.pending_invites || 0) + 1;\n          break;\n        case 'success':\n          updates.successful_invites = Number(stats.successful_invites || 0) + 1;\n          updates.pending_invites = Math.max(0, Number(stats.pending_invites || 0) - 1);\n          updates.last_invite_date = today;\n          break;\n        case 'failed':\n          updates.failed_invites = Number(stats.failed_invites || 0) + 1;\n          updates.pending_invites = Math.max(0, Number(stats.pending_invites || 0) - 1);\n          break;\n        case 'received':\n          updates.last_invite_date = today;\n          break;\n        default:\n          break;\n      }\n\n      await trx('user_invite_stats').where('user_id', userId).update(updates);\n    });\n  }\n\n  async getUserInviteStats(userId: string): Promise<UserInviteStats> {\n    const stats = await db('user_invite_stats').where('user_id', userId).first();\n    return (\n      stats ?? {\n        user_id: userId,\n        total_invites: 0,\n        successful_invites: 0,\n        pending_invites: 0,\n        failed_invites: 0,\n        total_rewards: 0,\n        last_invite_date: null,\n        monthly_stats: {}\n      }\n    );\n  }\n\n  async getInviteUsageLogs(options: InviteUsageLogOptions = {}): Promise<Record<string, unknown>[]> {\n    const {\n      inviteCodeId,\n      inviterId,\n      inviteeId,\n      status,\n      page = 1,\n      limit = 20,\n      sortBy = 'created_at',\n      sortOrder = 'desc'\n    } = options;\n\n    let query = db('invite_usage_logs')\n      .select('invite_usage_logs.*')\n      .leftJoin('invite_codes', 'invite_usage_logs.invite_code_id', '=', 'invite_codes.id')\n      .select('invite_codes.code as invite_code');\n\n    if (inviteCodeId) query = query.where('invite_usage_logs.invite_code_id', inviteCodeId);\n    if (inviterId) query = query.where('invite_usage_logs.inviter_id', inviterId);\n    if (inviteeId) query = query.where('invite_usage_logs.invitee_id', inviteeId);\n    if (status) query = query.where('invite_usage_logs.status', status);\n\n    const validSortFields = ['created_at', 'updated_at'];\n    const sortField = validSortFields.includes(sortBy) ? sortBy : 'created_at';\n    query = query.orderBy(sortField, sortOrder === 'asc' ? 'asc' : 'desc');\n\n    const offset = (page - 1) * limit;\n    query = query.limit(limit).offset(offset);\n\n    return query;\n  }\n\n  async cleanupExpiredCodes(): Promise<void> {\n    try {\n      const now = new Date();\n      const result = await db('invite_codes')\n        .where('expires_at', '<', now)\n        .where('status', 'active')\n        .update({\n          status: 'expired',\n          updated_at: now\n        });\n\n      if (result > 0) {\n        logger.info(`[InviteCodeService] Cleaned up ${result} expired invite codes`);\n      }\n    } catch (error) {\n      logger.error('[InviteCodeService] Failed to cleanup expired codes:', error);\n    }\n  }\n\n  async disableInviteCode(code: string): Promise<boolean> {\n    try {\n      const normalizedCode = code.toUpperCase().trim();\n      const result = await db('invite_codes').where('code', normalizedCode).update({\n        status: 'disabled',\n        updated_at: new Date()\n      });\n\n      if (result > 0) {\n        await cacheService.delete(`${this.cachePrefix}validate:${normalizedCode}`);\n        logger.info(`[InviteCodeService] Disabled invite code: ${normalizedCode}`);\n      }\n\n      return result > 0;\n    } catch (error) {\n      logger.error('[InviteCodeService] Failed to disable invite code:', error);\n      return false;\n    }\n  }\n\n  async getStats(): Promise<InviteStats> {\n    try {\n      const [totalCodes, activeCodes, usedCodes, expiredCodes, disabledCodes] = await Promise.all([\n        db('invite_codes').count<CountRow[]>('*'),\n        db('invite_codes').where('status', 'active').count<CountRow[]>('*'),\n        db('invite_codes').where('status', 'used').count<CountRow[]>('*'),\n        db('invite_codes').where('expires_at', '<', db.fn.now()).count<CountRow[]>('*'),\n        db('invite_codes').where('status', 'disabled').count<CountRow[]>('*')\n      ]);\n\n      const statsByType = await db('invite_codes')\n        .select('type')\n        .count('* as count')\n        .groupBy('type');\n\n      return {\n        total: parseCount(totalCodes[0]),\n        active: parseCount(activeCodes[0]),\n        used: parseCount(usedCodes[0]),\n        expired: parseCount(expiredCodes[0]),\n        disabled: parseCount(disabledCodes[0]),\n        byType: statsByType.reduce<Record<string, number>>((acc, item) => {\n          acc[item.type] = Number(item.count);\n          return acc;\n        }, {}),\n        initialized: this.initialized,\n        cachePrefix: this.cachePrefix,\n        cacheTTL: this.cacheTTL\n      };\n    } catch (error) {\n      logger.error('[InviteCodeService] Failed to get stats:', error);\n      return {\n        total: 0,\n        active: 0,\n        used: 0,\n        expired: 0,\n        disabled: 0,\n        byType: {},\n        initialized: this.initialized,\n        cachePrefix: this.cachePrefix,\n        cacheTTL: this.cacheTTL\n      };\n    }\n  }\n\n  async getInviteCodeStats(): Promise<InviteStats> {\n    return this.getStats();\n  }\n\n  async close(): Promise<void> {\n    this.initialized = false;\n    logger.info('[InviteCodeService] Invite code service closed');\n  }\n}\n\ntype InviteUsageLogOptions = {\n  inviteCodeId?: string;\n  inviterId?: string;\n  inviteeId?: string;\n  status?: string;\n  page?: number;\n  limit?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n};\n\nconst inviteCodeService = new InviteCodeService();\nexport default inviteCodeService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/job-processors.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/kms.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/kms.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const kmsService: {\n  generateKey: (cfg: any) => Promise<any>;\n  encrypt: (args: any) => Promise<any>;\n  decrypt: (args: any) => Promise<any>;\n  rotateKey?: (keyName: string, options?: any) => Promise<any>;\n  getKeyInfo?: (keyNameOrId: string) => Promise<any[]>;\n  deleteKey: (keyNameOrId: string, options?: any) => Promise<boolean>;\n};\nexport default kmsService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/kms.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/kuai.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·response?:·{·data?:·unknown;·status?:·number·};·code?:·string` with `⏎········response?:·{·data?:·unknown;·status?:·number·};⏎········code?:·string;⏎·····`","line":89,"column":37,"nodeType":null,"messageId":"replace","endLine":89,"endColumn":99,"fix":{"range":[2176,2238],"text":"\n        response?: { data?: unknown; status?: number };\n        code?: string;\n     "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport logger from '../utils/logger.js';\n\ntype KuaiCreateResponse = {\n  id: string;\n  status: string;\n  enhanced_prompt?: string;\n};\n\ntype KuaiStatusResponse = {\n  id: string;\n  status: string;\n  video_url?: string;\n  error_message?: string;\n  status_update_time?: string;\n};\n\nclass KuaiService {\n  private apiKey?: string;\n\n  private baseUrl = 'https://apis.kuai.host';\n\n  private initialized = false;\n\n  private initialize() {\n    if (this.initialized) return;\n\n    this.apiKey = process.env.KUAI_API_KEY;\n    if (!this.apiKey) {\n      logger.error('[KuaiService] KUAI API密钥未配置');\n      throw new Error('KUAI API密钥未配置，请在.env文件中配置KUAI_API_KEY');\n    }\n\n    this.initialized = true;\n    logger.info('[KuaiService] KUAI服务初始化成功');\n  }\n\n  async createVideoTask(\n    script: string,\n    imageUrl: string,\n    params: Record<string, unknown> = {}\n  ): Promise<{ vendorTaskId: string; status: string; enhancedPrompt?: string }> {\n    this.initialize();\n\n    try {\n      const requestData = {\n        model: (params.model as string) || 'veo3-fast',\n        prompt: script,\n        images: [imageUrl],\n        aspect_ratio: '16:9',\n        enhance_prompt: true,\n        enable_upsample: false\n      };\n\n      logger.info('[KuaiService] 开始创建视频任务', {\n        imageUrl,\n        model: requestData.model,\n        scriptLength: script.length\n      });\n\n      const response = await axios.post<KuaiCreateResponse>(\n        `${this.baseUrl}/v1/video/create`,\n        requestData,\n        {\n          headers: {\n            Authorization: `Bearer ${this.apiKey}`,\n            'Content-Type': 'application/json',\n            Accept: 'application/json'\n          },\n          timeout: 15000\n        }\n      );\n\n      if (response.data?.id) {\n        logger.info('[KuaiService] 视频任务创建成功', {\n          vendorTaskId: response.data.id,\n          status: response.data.status\n        });\n\n        return {\n          vendorTaskId: response.data.id,\n          status: response.data.status,\n          enhancedPrompt: response.data.enhanced_prompt\n        };\n      }\n\n      throw new Error('KUAI API返回格式异常');\n    } catch (error: unknown) {\n      const err = error as Error & { response?: { data?: unknown; status?: number }; code?: string };\n      logger.error('[KuaiService] 创建视频任务失败', {\n        imageUrl,\n        error: err.message,\n        response: err.response?.data\n      });\n\n      if (err.code === 'ECONNABORTED') {\n        throw new Error('KUAI API调用超时');\n      }\n      if (err.response?.status === 401) {\n        throw new Error('KUAI API密钥无效');\n      }\n      if (err.response?.status === 429) {\n        throw new Error('KUAI API调用频率限制');\n      }\n\n      throw new Error(`视频任务创建失败: ${err.message}`);\n    }\n  }\n\n  async queryVideoStatus(vendorTaskId: string): Promise<{\n    vendorTaskId: string;\n    status: string;\n    videoUrl?: string;\n    errorMessage?: string;\n    statusUpdateTime?: string;\n  }> {\n    this.initialize();\n\n    try {\n      logger.info('[KuaiService] 查询视频任务状态', { vendorTaskId });\n\n      const response = await axios.get<KuaiStatusResponse>(`${this.baseUrl}/v1/video/query`, {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n          Accept: 'application/json'\n        },\n        params: { id: vendorTaskId },\n        timeout: 10000\n      });\n\n      const data = response.data;\n      if (data) {\n        logger.info('[KuaiService] 视频状态查询成功', {\n          vendorTaskId: data.id,\n          status: data.status,\n          hasVideo: Boolean(data.video_url),\n          hasError: Boolean(data.error_message)\n        });\n\n        return {\n          vendorTaskId: data.id,\n          status: data.status,\n          videoUrl: data.video_url,\n          errorMessage: data.error_message,\n          statusUpdateTime: data.status_update_time\n        };\n      }\n\n      throw new Error('KUAI API返回格式异常');\n    } catch (error: unknown) {\n      const err = error as Error & { response?: { data?: unknown }; code?: string };\n      logger.error('[KuaiService] 查询视频状态失败', {\n        vendorTaskId,\n        error: err.message,\n        response: err.response?.data\n      });\n\n      if (err.code === 'ECONNABORTED') {\n        throw new Error('KUAI API调用超时');\n      }\n\n      throw new Error(`视频状态查询失败: ${err.message}`);\n    }\n  }\n\n  isTimeout(createdAt: Date, timeoutHours = 2): boolean {\n    const now = new Date();\n    const timeoutMs = timeoutHours * 60 * 60 * 1000;\n    return now.getTime() - createdAt.getTime() > timeoutMs;\n  }\n\n  getErrorMessage(errorCode: string): string {\n    const errorMap: Record<string, string> = {\n      KUAI_GENERATION_FAILED: '视频生成失败，请重试',\n      CONTENT_VIOLATION: '生成内容违规，请更换图片',\n      API_RATE_LIMIT: 'API调用频率限制，请稍后重试',\n      TIMEOUT: '处理超时，请重试',\n      NETWORK_ERROR: '网络连接失败，请重试'\n    };\n\n    return errorMap[errorCode] || '视频生成失败，请重试';\n  }\n}\n\nconst kuaiService = new KuaiService();\nexport default kuaiService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/mcp-endpoints.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/mcpEndpoint.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/mcpEndpoint.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const mcpEndpointService: {\n  getEndpoints: (opts: any) => Promise<any>;\n  getEndpointById: (id: string) => Promise<any>;\n  createEndpoint: (data: any, userId?: string) => Promise<any>;\n  updateEndpoint: (id: string, data: any, userId?: string) => Promise<any>;\n  deleteEndpoint: (id: string, userId?: string) => Promise<boolean>;\n  testEndpoint: (\n    id: string\n  ) => Promise<{ success: boolean; latency?: number; toolsCount?: number }>;\n  connectEndpoint: (id: string) => Promise<any>;\n  disconnectEndpoint: (id: string) => Promise<any>;\n  discoverTools: (id: string) => Promise<any[]>;\n  executeTool: (id: string, toolName: string, args: any) => Promise<any>;\n};\nexport default mcpEndpointService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/mcpEndpoint.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/media.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/membership.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/metrics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pagination.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/pagination.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const paginationService: {\n  getTaskList: (\n    filters: any,\n    options: { page: number; limit: number }\n  ) => Promise<{ data: any[]; pageInfo: any }>;\n  searchTasks: (\n    searchTerm: string,\n    options: { page: number; limit: number; where?: any }\n  ) => Promise<{ data: any[]; pageInfo: any }>;\n  analyzeQuery: (\n    table: string,\n    where: any,\n    orderBy: Array<{ column: string; direction: 'asc' | 'desc' }>\n  ) => Promise<{ sql: string; bindings: any[]; explain: any }>;\n};\nexport default paginationService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pagination.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `results[results.length·-·1]·as·Record<string,·unknown>,·orderBy` with `⏎··········results[results.length·-·1]·as·Record<string,·unknown>,⏎··········orderBy⏎········`","line":190,"column":39,"nodeType":null,"messageId":"replace","endLine":190,"endColumn":102,"fix":{"range":[4148,4211],"text":"\n          results[results.length - 1] as Record<string, unknown>,\n          orderBy\n        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·results.length·>·0·?·this.buildCursor(results[0]·as·Record<string,·unknown>,·orderBy)` with `⏎··········results.length·>·0⏎············?·this.buildCursor(results[0]·as·Record<string,·unknown>,·orderBy)⏎···········`","line":194,"column":21,"nodeType":null,"messageId":"replace","endLine":194,"endColumn":107,"fix":{"range":[4331,4417],"text":"\n          results.length > 0\n            ? this.buildCursor(results[0] as Record<string, unknown>, orderBy)\n           "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·?·this.buildCursor(results[results.length·-·1]·as·Record<string,·unknown>,·orderBy)` with `⏎············?·this.buildCursor(results[results.length·-·1]·as·Record<string,·unknown>,·orderBy)⏎···········`","line":196,"column":29,"nodeType":null,"messageId":"replace","endLine":196,"endColumn":113,"fix":{"range":[4473,4557],"text":"\n            ? this.buildCursor(results[results.length - 1] as Record<string, unknown>, orderBy)\n           "}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { db } from '../config/database.js';\nimport logger from '../utils/logger.js';\nimport type { Knex } from 'knex';\n\n/**\n * 排序规则\n */\nexport interface OrderSpec {\n  column: string;\n  direction?: 'asc' | 'desc';\n}\n\n/**\n * JOIN规则\n */\nexport interface JoinSpec {\n  type: 'inner' | 'left';\n  table: string;\n  first: string;\n  operator: string;\n  second: string;\n}\n\n/**\n * WHERE条件类型(对象形式或函数形式)\n */\nexport type WhereCondition = Record<string, unknown> | ((this: Knex.QueryBuilder) => void);\n\n/**\n * 游标分页选项\n */\nexport interface CursorPaginateOptions {\n  table: string;\n  columns?: string[];\n  where?: WhereCondition;\n  orderBy?: OrderSpec[];\n  cursor?: string | null;\n  limit?: number;\n  joins?: JoinSpec[];\n}\n\n/**\n * OFFSET分页选项\n */\nexport interface OffsetPaginateOptions {\n  table: string;\n  columns?: string[];\n  where?: WhereCondition;\n  orderBy?: OrderSpec[];\n  page?: number;\n  limit?: number;\n  joins?: JoinSpec[];\n}\n\n/**\n * 游标分页元信息\n */\nexport interface CursorPageInfo {\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  startCursor: string | null;\n  endCursor: string | null;\n  nextCursor: string | null;\n  limit: number;\n  totalCount: number;\n}\n\n/**\n * OFFSET分页元信息\n */\nexport interface OffsetPageInfo {\n  currentPage: number;\n  totalPages: number;\n  totalItems: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n  limit: number;\n  offset: number;\n  itemCount: number;\n}\n\n/**\n * 游标分页结果\n */\nexport interface CursorPaginateResult<T = Record<string, unknown>> {\n  data: T[];\n  pageInfo: CursorPageInfo;\n  paginationType: 'cursor';\n}\n\n/**\n * OFFSET分页结果\n */\nexport interface OffsetPaginateResult<T = Record<string, unknown>> {\n  data: T[];\n  pageInfo: OffsetPageInfo;\n  paginationType: 'offset';\n}\n\n/**\n * 查询分析结果\n */\nexport interface QueryAnalysis {\n  sql: string;\n  bindings: unknown[];\n  explain: unknown[];\n}\n\n/**\n * 游标数据\n */\nexport interface CursorData {\n  [columnName: string]: unknown;\n}\n\n/**\n * 任务过滤器\n */\nexport interface TaskFilters {\n  status?: string;\n  type?: string;\n  userId?: string;\n  createdRange?: {\n    start?: string;\n    end?: string;\n  };\n  [key: string]: unknown;\n}\n\n/**\n * 配额交易过滤器\n */\nexport interface QuotaTransactionFilters {\n  phase?: string;\n}\n\nclass PaginationService {\n  private readonly defaultLimit = 20;\n  private readonly maxLimit = 100;\n  private readonly defaultOrder: 'asc' | 'desc' = 'desc';\n\n  async cursorPaginate<T = Record<string, unknown>>(\n    options: CursorPaginateOptions\n  ): Promise<CursorPaginateResult<T>> {\n    const {\n      table,\n      columns = ['*'],\n      where = {},\n      orderBy = [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ],\n      cursor,\n      limit = this.defaultLimit,\n      joins = []\n    } = options;\n    try {\n      const validatedLimit = Math.min(Math.max(limit, 1), this.maxLimit);\n      let query: Knex.QueryBuilder = db(table).select(columns);\n      joins.forEach((join) => {\n        query =\n          join.type === 'inner'\n            ? query.innerJoin(join.table, join.first, join.operator, join.second)\n            : query.leftJoin(join.table, join.first, join.operator, join.second);\n      });\n      if (typeof where === 'function') {\n        query = query.where(where);\n      } else {\n        Object.keys(where).forEach((key) => {\n          const val = (where as Record<string, unknown>)[key];\n          if (val !== null && val !== undefined) {\n            Array.isArray(val)\n              ? (query = query.whereIn(key, val))\n              : (query = query.where(key, val));\n          }\n        });\n      }\n      if (cursor) query = this.buildCursorCondition(query, orderBy, cursor);\n      orderBy.forEach((o) => {\n        query = query.orderBy(o.column, o.direction || this.defaultOrder);\n      });\n      query = query.limit(validatedLimit + 1);\n      const startTime = Date.now();\n      const results = (await query) as T[];\n      const queryTime = Date.now() - startTime;\n      const hasNextPage = results.length > validatedLimit;\n      if (hasNextPage) results.pop();\n      let nextCursor: string | null = null;\n      if (hasNextPage && results.length > 0)\n        nextCursor = this.buildCursor(results[results.length - 1] as Record<string, unknown>, orderBy);\n      const pageInfo: CursorPageInfo = {\n        hasNextPage,\n        hasPreviousPage: !!cursor,\n        startCursor: results.length > 0 ? this.buildCursor(results[0] as Record<string, unknown>, orderBy) : null,\n        endCursor:\n          results.length > 0 ? this.buildCursor(results[results.length - 1] as Record<string, unknown>, orderBy) : null,\n        nextCursor,\n        limit: validatedLimit,\n        totalCount: results.length\n      };\n      logger.debug('[PaginationService] 游标分页查询完成', {\n        table,\n        limit: validatedLimit,\n        resultCount: results.length,\n        hasNextPage,\n        queryTime: `${queryTime}ms`,\n        hasCursor: !!cursor\n      });\n      return { data: results, pageInfo, paginationType: 'cursor' };\n    } catch (error) {\n      logger.error('[PaginationService] 游标分页查询失败', {\n        table,\n        error: error instanceof Error ? error.message : String(error),\n        options\n      });\n      throw error;\n    }\n  }\n\n  async offsetPaginate<T = Record<string, unknown>>(\n    options: OffsetPaginateOptions\n  ): Promise<OffsetPaginateResult<T>> {\n    const {\n      table,\n      columns = ['*'],\n      where = {},\n      orderBy = [{ column: 'created_at', direction: 'desc' }],\n      page = 1,\n      limit = this.defaultLimit,\n      joins = []\n    } = options;\n    try {\n      const validatedPage = Math.max(page, 1);\n      const validatedLimit = Math.min(Math.max(limit, 1), this.maxLimit);\n      const offset = (validatedPage - 1) * validatedLimit;\n      let countQuery: Knex.QueryBuilder = db(table);\n      joins.forEach((join) => {\n        countQuery =\n          join.type === 'inner'\n            ? countQuery.innerJoin(join.table, join.first, join.operator, join.second)\n            : countQuery.leftJoin(join.table, join.first, join.operator, join.second);\n      });\n      if (typeof where === 'function') {\n        countQuery = countQuery.where(where);\n      } else {\n        Object.keys(where).forEach((key) => {\n          const val = (where as Record<string, unknown>)[key];\n          if (val !== null && val !== undefined) {\n            Array.isArray(val)\n              ? (countQuery = countQuery.whereIn(key, val))\n              : (countQuery = countQuery.where(key, val));\n          }\n        });\n      }\n      const totalCountRow = (await countQuery.count('* as total').first()) as { total: number };\n      let dataQuery: Knex.QueryBuilder = db(table).select(columns);\n      joins.forEach((join) => {\n        dataQuery =\n          join.type === 'inner'\n            ? dataQuery.innerJoin(join.table, join.first, join.operator, join.second)\n            : dataQuery.leftJoin(join.table, join.first, join.operator, join.second);\n      });\n      if (typeof where === 'function') {\n        dataQuery = dataQuery.where(where);\n      } else {\n        Object.keys(where).forEach((key) => {\n          const val = (where as Record<string, unknown>)[key];\n          if (val !== null && val !== undefined) {\n            Array.isArray(val)\n              ? (dataQuery = dataQuery.whereIn(key, val))\n              : (dataQuery = dataQuery.where(key, val));\n          }\n        });\n      }\n      orderBy.forEach((o) => {\n        dataQuery = dataQuery.orderBy(o.column, o.direction || this.defaultOrder);\n      });\n      dataQuery = dataQuery.limit(validatedLimit).offset(offset);\n      const startTime = Date.now();\n      const results = (await dataQuery) as T[];\n      const queryTime = Date.now() - startTime;\n      const totalItems = parseInt(String(totalCountRow?.total ?? '0')) || 0;\n      const totalPages = Math.ceil(totalItems / validatedLimit);\n      const hasNextPage = validatedPage < totalPages;\n      const hasPreviousPage = validatedPage > 1;\n      const pageInfo: OffsetPageInfo = {\n        currentPage: validatedPage,\n        totalPages,\n        totalItems,\n        hasNextPage,\n        hasPreviousPage,\n        limit: validatedLimit,\n        offset,\n        itemCount: results.length\n      };\n      logger.debug('[PaginationService] OFFSET分页查询完成', {\n        table,\n        page: validatedPage,\n        limit: validatedLimit,\n        totalItems,\n        totalPages,\n        queryTime: `${queryTime}ms`\n      });\n      return { data: results, pageInfo, paginationType: 'offset' };\n    } catch (error) {\n      logger.error('[PaginationService] OFFSET分页查询失败', {\n        table,\n        error: error instanceof Error ? error.message : String(error),\n        options\n      });\n      throw error;\n    }\n  }\n\n  private buildCursorCondition(\n    query: Knex.QueryBuilder,\n    orderBy: OrderSpec[],\n    cursor: string\n  ): Knex.QueryBuilder {\n    const cursorData = this.parseCursor(cursor);\n    if (!cursorData || orderBy.length === 0) return query;\n    const conditions: string[] = [];\n    const bindings: unknown[] = [];\n    for (let i = 0; i < orderBy.length; i++) {\n      const { column, direction } = orderBy[i];\n      const value = cursorData[column];\n      if (value === undefined) continue;\n      const operator = (direction || this.defaultOrder) === 'desc' ? '<' : '>';\n      if (i === 0) {\n        conditions.push(`${column} ${operator} ?`);\n        bindings.push(value);\n      } else {\n        let prevConditions = '';\n        const prevBindings: unknown[] = [];\n        for (let j = 0; j < i; j++) {\n          const prevColumn = orderBy[j].column;\n          const prevValue = cursorData[prevColumn];\n          if (prevValue !== undefined) {\n            prevConditions += prevConditions ? ' AND ' : '';\n            prevConditions += `${prevColumn} = ?`;\n            prevBindings.push(prevValue);\n          }\n        }\n        if (prevConditions) {\n          conditions.push(`(${prevConditions} AND ${column} ${operator} ?)`);\n          bindings.push(...prevBindings, value);\n        } else {\n          conditions.push(`${column} ${operator} ?`);\n          bindings.push(value);\n        }\n      }\n    }\n    if (conditions.length > 0) query = query.whereRaw(`(${conditions.join(' OR ')})`, bindings);\n    return query;\n  }\n\n  private buildCursor(row: Record<string, unknown>, orderBy: OrderSpec[]): string {\n    const cursorData: CursorData = {};\n    orderBy.forEach((o) => {\n      const col = o.column;\n      const v = row[col];\n      if (v !== undefined && v !== null) cursorData[col] = v;\n    });\n    return Buffer.from(JSON.stringify(cursorData)).toString('base64');\n  }\n\n  private parseCursor(cursor: string): CursorData | null {\n    try {\n      return JSON.parse(Buffer.from(cursor, 'base64').toString('utf8')) as CursorData;\n    } catch (error) {\n      logger.warn('[PaginationService] 游标解析失败', { cursor, error });\n      return null;\n    }\n  }\n\n  async getUserTasks(userId: string, options: Partial<CursorPaginateOptions> = {}) {\n    return this.cursorPaginate({\n      table: 'tasks',\n      columns: ['id', 'userId', 'type', 'status', 'created_at', 'completed_at', 'resultUrls'],\n      where: { userId },\n      orderBy: [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ],\n      ...options\n    });\n  }\n\n  async getTaskList(filters: TaskFilters = {}, options: Partial<OffsetPaginateOptions> = {}) {\n    const baseWhere: Record<string, unknown> = {};\n    if (filters.status) baseWhere.status = filters.status;\n    if (filters.type) baseWhere.type = filters.type;\n    if (filters.userId) baseWhere.userId = filters.userId;\n\n    const hasRange = Boolean(filters.createdRange?.start || filters.createdRange?.end);\n    const whereCondition = hasRange\n      ? function (this: Knex.QueryBuilder) {\n          Object.entries(baseWhere).forEach(([column, value]) => {\n            if (value !== undefined && value !== null) {\n              this.where(column, value as string);\n            }\n          });\n          const { start, end } = filters.createdRange ?? {};\n          if (start && end) {\n            this.whereBetween('created_at', [start, end]);\n          } else if (start) {\n            this.where('created_at', '>=', start);\n          } else if (end) {\n            this.where('created_at', '<=', end);\n          }\n        }\n      : baseWhere;\n    return this.offsetPaginate({\n      table: 'tasks',\n      columns: ['id', 'userId', 'type', 'status', 'created_at', 'completed_at'],\n      where: whereCondition,\n      orderBy: [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ],\n      ...options\n    });\n  }\n\n  async getQuotaTransactions(\n    userId: string | null = null,\n    filters: QuotaTransactionFilters = {},\n    options: Partial<OffsetPaginateOptions> = {}\n  ) {\n    const where: Record<string, unknown> = {};\n    if (userId) where.user_id = userId;\n    if (filters.phase) where.phase = filters.phase;\n    return this.offsetPaginate({\n      table: 'quota_transactions',\n      columns: ['id', 'task_id', 'user_id', 'amount', 'phase', 'created_at'],\n      where,\n      orderBy: [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ],\n      ...options\n    });\n  }\n\n  async searchTasks(searchTerm: string, options: Partial<OffsetPaginateOptions> = {}) {\n    if (!searchTerm || searchTerm.trim().length === 0) return this.getTaskList({}, options);\n    const whereFn = function (this: Knex.QueryBuilder) {\n      this.where('tasks.type', 'like', `%${searchTerm}%`)\n        .orWhere('tasks.status', 'like', `%${searchTerm}%`)\n        .orWhere('tasks.errorReason', 'like', `%${searchTerm}%`);\n    };\n    return this.offsetPaginate({\n      table: 'tasks',\n      columns: ['id', 'userId', 'type', 'status', 'created_at', 'errorReason'],\n      where: whereFn,\n      orderBy: [\n        { column: 'created_at', direction: 'desc' },\n        { column: 'id', direction: 'desc' }\n      ],\n      ...options\n    });\n  }\n\n  async getIndexUsageStats(): Promise<unknown[]> {\n    try {\n      const stats = await (db as Knex).raw('SELECT * FROM v_index_usage');\n      return (stats?.[0] as unknown[]) || [];\n    } catch (error) {\n      logger.error('[PaginationService] 获取索引统计失败', error);\n      return [];\n    }\n  }\n\n  async analyzeQuery(\n    table: string,\n    where: Record<string, unknown> = {},\n    orderBy: OrderSpec[] = []\n  ): Promise<QueryAnalysis> {\n    try {\n      let query: Knex.QueryBuilder = db(table).select('*');\n      Object.keys(where).forEach((k) => {\n        const v = where[k];\n        if (v !== null && v !== undefined) {\n          query = query.where(k, v);\n        }\n      });\n      orderBy.forEach((o) => {\n        query = query.orderBy(o.column, o.direction || 'desc');\n      });\n      const sql = query.toSQL();\n      const explainSql = `EXPLAIN ${sql.sql}`;\n      const explainResult = await (db as Knex).raw(explainSql, sql.bindings);\n      logger.debug('[PaginationService] 查询分析完成', {\n        table,\n        where,\n        orderBy,\n        explainPlan: explainResult?.[0]\n      });\n      return {\n        sql: sql.sql,\n        bindings: sql.bindings as unknown[],\n        explain: (explainResult?.[0] as unknown[]) || []\n      };\n    } catch (error) {\n      logger.error('[PaginationService] 查询分析失败', {\n        table,\n        where,\n        orderBy,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n}\n\nconst paginationService = new PaginationService();\nexport default paginationService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/payment.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/permission.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipeline-testrunner.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `node:·PipelineNode,·context:·Record<string,·unknown>` with `⏎····node:·PipelineNode,⏎····context:·Record<string,·unknown>⏎··`","line":364,"column":33,"nodeType":null,"messageId":"replace","endLine":364,"endColumn":85,"fix":{"range":[9233,9285],"text":"\n    node: PipelineNode,\n    context: Record<string, unknown>\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `node:·PipelineNode,·context:·Record<string,·unknown>` with `⏎····node:·PipelineNode,⏎····context:·Record<string,·unknown>⏎··`","line":415,"column":41,"nodeType":null,"messageId":"replace","endLine":415,"endColumn":93,"fix":{"range":[10497,10549],"text":"\n    node: PipelineNode,\n    context: Record<string, unknown>\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `node:·PipelineNode,·context:·Record<string,·unknown>` with `⏎····node:·PipelineNode,⏎····context:·Record<string,·unknown>⏎··`","line":434,"column":39,"nodeType":null,"messageId":"replace","endLine":434,"endColumn":91,"fix":{"range":[10989,11041],"text":"\n    node: PipelineNode,\n    context: Record<string, unknown>\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `node:·PipelineNode,·context:·Record<string,·unknown>` with `⏎····node:·PipelineNode,⏎····context:·Record<string,·unknown>⏎··`","line":452,"column":42,"nodeType":null,"messageId":"replace","endLine":452,"endColumn":94,"fix":{"range":[11473,11525],"text":"\n    node: PipelineNode,\n    context: Record<string, unknown>\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `node:·PipelineNode,·context:·Record<string,·unknown>` with `⏎····node:·PipelineNode,⏎····context:·Record<string,·unknown>⏎··`","line":467,"column":36,"nodeType":null,"messageId":"replace","endLine":467,"endColumn":88,"fix":{"range":[11885,11937],"text":"\n    node: PipelineNode,\n    context: Record<string, unknown>\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `executionId:·string,·eventType:·string,·data:·Record<string,·unknown>` with `⏎····executionId:·string,⏎····eventType:·string,⏎····data:·Record<string,·unknown>⏎··`","line":548,"column":30,"nodeType":null,"messageId":"replace","endLine":548,"endColumn":99,"fix":{"range":[13712,13781],"text":"\n    executionId: string,\n    eventType: string,\n    data: Record<string, unknown>\n  "}}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":6,"fixableWarningCount":0,"source":"/**\n * Pipeline试跑器服务\n *\n * 支持Mock和真实模式，通过SSE输出执行日志\n */\n\nconst { EventEmitter } = require('events');\nconst logger = require('../utils/logger');\nconst { v4: uuidv4 } = require('uuid');\nconst pipelineValidatorService = require('./pipeline-validator.service');\nconst websocketService = require('./websocket.service');\n\ninterface TestExecution {\n  id: string;\n  pipelineId: string;\n  mode: 'mock' | 'real';\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  startTime: Date;\n  endTime?: Date;\n  currentNode?: string;\n  context: Record<string, unknown>;\n  results: Array<{\n    nodeId: string;\n    stepName: string;\n    status: 'pending' | 'running' | 'completed' | 'failed';\n    startTime: Date;\n    endTime?: Date;\n    input?: unknown;\n    output?: unknown;\n    error?: string;\n    logs: string[];\n    metrics: {\n      duration: number;\n      memoryUsed?: number;\n    };\n  }>;\n  summary: {\n    totalSteps: number;\n    completedSteps: number;\n    failedSteps: number;\n    totalDuration: number;\n    success: boolean;\n  };\n}\n\ninterface MockNodeResult {\n  output: unknown;\n  duration: number;\n  logs: string[];\n  error?: string;\n}\n\ninterface PipelineNode {\n  id: string;\n  type: string;\n  name: string;\n  inputs?: string[];\n  outputs?: string[];\n  [key: string]: unknown;\n}\n\ninterface MockPipeline {\n  id: string;\n  nodes: PipelineNode[];\n  edges: Array<{\n    id: string;\n    source: string;\n    target: string;\n    condition?: string;\n  }>;\n}\n\nclass PipelineTestRunnerService extends EventEmitter {\n  private activeExecutions = new Map<string, TestExecution>();\n  private mockData = new Map<string, MockNodeResult>();\n\n  constructor() {\n    super();\n    this.initializeMockData();\n  }\n\n  /**\n   * 初始化Mock数据\n   */\n  private initializeMockData(): void {\n    // 为不同类型的节点预定义Mock结果\n    this.mockData.set('START', {\n      output: { timestamp: new Date().toISOString(), executionId: uuidv4() },\n      duration: 10,\n      logs: ['🟢 开始执行Pipeline', '初始化执行环境']\n    });\n\n    this.mockData.set('TRANSFORM', {\n      output: {\n        transformed: true,\n        recordCount: Math.floor(Math.random() * 100) + 10,\n        processingTime: Math.random() * 500 + 100\n      },\n      duration: Math.random() * 1000 + 200,\n      logs: ['🔄 正在转换数据', '应用转换规则', '数据转换完成']\n    });\n\n    this.mockData.set('FILTER', {\n      output: {\n        filtered: true,\n        recordCount: Math.floor(Math.random() * 80) + 5,\n        filterCriteria: 'default'\n      },\n      duration: Math.random() * 500 + 100,\n      logs: ['🔍 正在过滤数据', '应用过滤条件', '过滤完成']\n    });\n\n    this.mockData.set('MERGE', {\n      output: {\n        merged: true,\n        recordCount: Math.floor(Math.random() * 150) + 20,\n        sourceCount: 2\n      },\n      duration: Math.random() * 800 + 200,\n      logs: ['🔗 正在合并数据', '合并多个数据源', '数据合并完成']\n    });\n\n    this.mockData.set('CONDITION', {\n      output: {\n        condition: true,\n        branch: 'true',\n        evaluationTime: Math.random() * 100 + 50\n      },\n      duration: Math.random() * 300 + 50,\n      logs: ['🤔 正在评估条件', '条件表达式: true', '选择分支: true']\n    });\n\n    this.mockData.set('END', {\n      output: {\n        executionId: uuidv4(),\n        completedAt: new Date().toISOString(),\n        summary: 'Pipeline执行完成'\n      },\n      duration: 50,\n      logs: ['✅ Pipeline执行完成', '生成执行报告', '清理执行环境']\n    });\n  }\n\n  /**\n   * 开始试跑Pipeline\n   */\n  async startTest(pipelineId: string, mode: 'mock' | 'real' = 'mock'): Promise<string> {\n    const executionId = this.generateExecutionId();\n\n    const execution: TestExecution = {\n      id: executionId,\n      pipelineId,\n      mode,\n      status: 'pending',\n      startTime: new Date(),\n      context: {},\n      results: [],\n      summary: {\n        totalSteps: 0,\n        completedSteps: 0,\n        failedSteps: 0,\n        totalDuration: 0,\n        success: false\n      }\n    };\n\n    this.activeExecutions.set(executionId, execution);\n\n    logger.info('Pipeline试跑已开始', {\n      executionId,\n      pipelineId,\n      mode\n    });\n\n    // 异步执行Pipeline\n    this.executePipeline(executionId).catch((error) => {\n      logger.error('Pipeline试跑失败', { executionId, error: error.message });\n    });\n\n    return executionId;\n  }\n\n  /**\n   * 执行Pipeline\n   */\n  private async executePipeline(executionId: string): Promise<void> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) return;\n\n    try {\n      execution.status = 'running';\n\n      // 发送开始事件\n      this.emitExecutionEvent(executionId, 'started', {\n        message: 'Pipeline试跑开始',\n        mode: execution.mode,\n        timestamp: new Date()\n      });\n\n      // 这里应该从数据库获取Pipeline配置\n      // 为了演示，我们使用模拟数据\n      const mockPipeline = this.getMockPipeline(execution.pipelineId);\n\n      execution.summary.totalSteps = mockPipeline.nodes.length;\n\n      // 按顺序执行每个节点\n      for (const node of mockPipeline.nodes) {\n        if (execution.status === 'cancelled') {\n          break;\n        }\n\n        await this.executeNode(executionId, node);\n      }\n\n      // 完成执行\n      if (execution.status !== 'cancelled') {\n        execution.status = execution.summary.failedSteps === 0 ? 'completed' : 'failed';\n        execution.endTime = new Date();\n        execution.summary.totalDuration =\n          execution.endTime.getTime() - execution.startTime.getTime();\n        execution.summary.success = execution.summary.failedSteps === 0;\n      }\n\n      // 发送完成事件\n      this.emitExecutionEvent(\n        executionId,\n        execution.status === 'completed' ? 'completed' : 'failed',\n        {\n          message: `Pipeline试跑${execution.status === 'completed' ? '完成' : '失败'}`,\n          summary: execution.summary,\n          timestamp: new Date()\n        }\n      );\n    } catch (error) {\n      const err = error as Error;\n      execution.status = 'failed';\n      execution.endTime = new Date();\n      execution.summary.totalDuration = execution.endTime.getTime() - execution.startTime.getTime();\n\n      this.emitExecutionEvent(executionId, 'error', {\n        message: 'Pipeline试跑过程中发生错误',\n        error: err.message,\n        timestamp: new Date()\n      });\n    }\n  }\n\n  /**\n   * 执行单个节点\n   */\n  private async executeNode(executionId: string, node: PipelineNode): Promise<void> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution || execution.status === 'cancelled') return;\n\n    const stepResult: TestExecution['results'][0] = {\n      nodeId: node.id,\n      stepName: node.name,\n      status: 'pending',\n      startTime: new Date(),\n      logs: [] as string[],\n      metrics: {\n        duration: 0\n      }\n    };\n\n    execution.results.push(stepResult);\n    execution.currentNode = node.id;\n\n    try {\n      // 发送节点开始事件\n      this.emitExecutionEvent(executionId, 'node_started', {\n        nodeId: node.id,\n        nodeName: node.name,\n        nodeType: node.type,\n        timestamp: new Date()\n      });\n\n      stepResult.status = 'running';\n\n      // 根据模式执行节点\n      let nodeResult: MockNodeResult;\n\n      if (execution.mode === 'mock') {\n        nodeResult = await this.executeMockNode(node);\n      } else {\n        nodeResult = await this.executeRealNode(node, execution.context);\n      }\n\n      // 处理节点结果\n      stepResult.status = nodeResult.error ? 'failed' : 'completed';\n      stepResult.endTime = new Date();\n      stepResult.output = nodeResult.output;\n      stepResult.error = nodeResult.error;\n      stepResult.logs = nodeResult.logs;\n      stepResult.metrics.duration = nodeResult.duration;\n\n      // 更新执行上下文\n      if (nodeResult.output) {\n        execution.context[node.id] = nodeResult.output;\n      }\n\n      // 更新统计\n      if (stepResult.status === 'completed') {\n        execution.summary.completedSteps++;\n      } else {\n        execution.summary.failedSteps++;\n      }\n\n      // 发送节点完成事件\n      this.emitExecutionEvent(\n        executionId,\n        stepResult.status === 'completed' ? 'node_completed' : 'node_failed',\n        {\n          nodeId: node.id,\n          nodeName: node.name,\n          status: stepResult.status,\n          duration: stepResult.metrics.duration,\n          logs: stepResult.logs,\n          timestamp: new Date()\n        }\n      );\n    } catch (error) {\n      const err = error as Error;\n      stepResult.status = 'failed';\n      stepResult.endTime = new Date();\n      stepResult.error = err.message;\n      stepResult.logs.push(`❌ 节点执行失败: ${err.message}`);\n      stepResult.metrics.duration = Date.now() - stepResult.startTime.getTime();\n\n      execution.summary.failedSteps++;\n\n      this.emitExecutionEvent(executionId, 'node_failed', {\n        nodeId: node.id,\n        nodeName: node.name,\n        error: err.message,\n        timestamp: new Date()\n      });\n    }\n  }\n\n  /**\n   * 执行Mock节点\n   */\n  private async executeMockNode(node: PipelineNode): Promise<MockNodeResult> {\n    const mockResult = this.mockData.get(node.type) || this.mockData.get('TRANSFORM');\n    if (!mockResult) {\n      throw new Error(`未找到节点类型 ${node.type} 的Mock数据`);\n    }\n\n    // 模拟执行延迟\n    await this.delay(mockResult.duration);\n\n    return {\n      output: mockResult.output,\n      duration: mockResult.duration,\n      logs: mockResult.logs.map((log) => `[${node.name}] ${log}`),\n      error: mockResult.error\n    };\n  }\n\n  /**\n   * 执行真实节点\n   */\n  private async executeRealNode(node: PipelineNode, context: Record<string, unknown>): Promise<MockNodeResult> {\n    const startTime = Date.now();\n    const logs: string[] = [];\n\n    try {\n      logs.push(`[真实模式] 开始执行节点: ${node.name}`);\n\n      // 这里应该根据节点类型调用相应的服务\n      // 例如：图片处理、AI分析、数据转换等\n\n      let output: unknown;\n\n      switch (node.type) {\n        case 'IMAGE_PROCESS':\n          output = await this.executeImageProcessNode(node, context);\n          break;\n        case 'AI_ANALYSIS':\n          output = await this.executeAIAnalysisNode(node, context);\n          break;\n        case 'DATA_TRANSFORM':\n          output = await this.executeDataTransformNode(node, context);\n          break;\n        default:\n          output = await this.executeGenericNode(node, context);\n      }\n\n      const duration = Date.now() - startTime;\n      logs.push(`[真实模式] 节点执行完成，耗时: ${duration}ms`);\n\n      return {\n        output,\n        duration,\n        logs\n      };\n    } catch (error) {\n      const err = error as Error;\n      const duration = Date.now() - startTime;\n      logs.push(`[真实模式] 节点执行失败: ${err.message}`);\n\n      return {\n        output: null,\n        duration,\n        logs,\n        error: err.message\n      };\n    }\n  }\n\n  /**\n   * 执行图片处理节点\n   */\n  private async executeImageProcessNode(node: PipelineNode, context: Record<string, unknown>): Promise<unknown> {\n    // 模拟图片处理逻辑\n    await this.delay(Math.random() * 2000 + 1000);\n\n    return {\n      processed: true,\n      imageUrl: `https://example.com/processed/${Date.now()}.jpg`,\n      size: Math.floor(Math.random() * 1024 * 1024) + 100 * 1024, // 100KB-1MB\n      metadata: {\n        width: 1920,\n        height: 1080,\n        format: 'jpeg'\n      }\n    };\n  }\n\n  /**\n   * 执行AI分析节点\n   */\n  private async executeAIAnalysisNode(node: PipelineNode, context: Record<string, unknown>): Promise<unknown> {\n    // 模拟AI分析逻辑\n    await this.delay(Math.random() * 3000 + 2000);\n\n    return {\n      analysis: {\n        score: Math.random() * 100,\n        confidence: Math.random() * 0.3 + 0.7,\n        tags: ['tag1', 'tag2', 'tag3'],\n        insights: ['图片质量良好', '色彩饱和度适中', '主体清晰可见']\n      },\n      processingTime: Math.random() * 2000 + 1000\n    };\n  }\n\n  /**\n   * 执行数据转换节点\n   */\n  private async executeDataTransformNode(node: PipelineNode, context: Record<string, unknown>): Promise<unknown> {\n    // 模拟数据转换逻辑\n    await this.delay(Math.random() * 500 + 200);\n\n    return {\n      transformed: true,\n      recordCount: Math.floor(Math.random() * 1000) + 100,\n      fields: ['field1', 'field2', 'field3'],\n      transformations: ['lowercase', 'trim', 'normalize']\n    };\n  }\n\n  /**\n   * 执行通用节点\n   */\n  private async executeGenericNode(node: PipelineNode, context: Record<string, unknown>): Promise<unknown> {\n    // 通用节点处理逻辑\n    await this.delay(Math.random() * 1000 + 500);\n\n    return {\n      executed: true,\n      nodeType: node.type,\n      contextKeys: Object.keys(context),\n      output: `Generated output for ${node.type} node`\n    };\n  }\n\n  /**\n   * 取消试跑\n   */\n  async cancelTest(executionId: string): Promise<boolean> {\n    const execution = this.activeExecutions.get(executionId);\n    if (!execution) {\n      return false;\n    }\n\n    if (execution.status === 'completed' || execution.status === 'failed') {\n      return false;\n    }\n\n    execution.status = 'cancelled';\n    execution.endTime = new Date();\n\n    this.emitExecutionEvent(executionId, 'cancelled', {\n      message: 'Pipeline试跑已取消',\n      timestamp: new Date()\n    });\n\n    logger.info('Pipeline试跑已取消', { executionId });\n    return true;\n  }\n\n  /**\n   * 获取试跑状态\n   */\n  getTestStatus(executionId: string): TestExecution | null {\n    return this.activeExecutions.get(executionId) || null;\n  }\n\n  /**\n   * 获取所有活跃的试跑\n   */\n  getActiveTests(): TestExecution[] {\n    return Array.from(this.activeExecutions.values());\n  }\n\n  /**\n   * 清理已完成的试跑\n   */\n  async cleanupCompletedTests(): Promise<number> {\n    const completedIds: string[] = [];\n\n    for (const [executionId, execution] of this.activeExecutions) {\n      if (\n        execution.status === 'completed' ||\n        execution.status === 'failed' ||\n        execution.status === 'cancelled'\n      ) {\n        completedIds.push(executionId);\n      }\n    }\n\n    for (const id of completedIds) {\n      this.activeExecutions.delete(id);\n    }\n\n    if (completedIds.length > 0) {\n      logger.info('清理已完成的Pipeline试跑', { count: completedIds.length });\n    }\n\n    return completedIds.length;\n  }\n\n  /**\n   * 发送执行事件\n   */\n  private emitExecutionEvent(executionId: string, eventType: string, data: Record<string, unknown>): void {\n    // 通过WebSocket发送事件\n    websocketService.sendTaskEvent(executionId, {\n      event: eventType,\n      data,\n      executionId,\n      timestamp: new Date().toISOString()\n    });\n\n    // 发送到本地事件监听器\n    this.emit('execution_event', {\n      executionId,\n      eventType,\n      data,\n      timestamp: new Date()\n    });\n  }\n\n  /**\n   * 获取模拟Pipeline配置\n   */\n  private getMockPipeline(pipelineId: string): MockPipeline {\n    // 返回模拟的Pipeline配置\n    return {\n      id: pipelineId,\n      nodes: [\n        { id: 'start', type: 'START', name: '开始', inputs: [], outputs: ['input_data'] },\n        {\n          id: 'transform1',\n          type: 'TRANSFORM',\n          name: '数据转换1',\n          inputs: ['input_data'],\n          outputs: ['transformed_data1']\n        },\n        {\n          id: 'filter1',\n          type: 'FILTER',\n          name: '数据过滤',\n          inputs: ['transformed_data1'],\n          outputs: ['filtered_data']\n        },\n        {\n          id: 'condition1',\n          type: 'CONDITION',\n          name: '条件判断',\n          inputs: ['filtered_data'],\n          outputs: ['branch_true', 'branch_false']\n        },\n        {\n          id: 'merge1',\n          type: 'MERGE',\n          name: '数据合并',\n          inputs: ['branch_true', 'branch_false'],\n          outputs: ['final_data']\n        },\n        { id: 'end', type: 'END', name: '结束', inputs: ['final_data'], outputs: [] }\n      ],\n      edges: [\n        { id: 'e1', source: 'start', target: 'transform1' },\n        { id: 'e2', source: 'transform1', target: 'filter1' },\n        { id: 'e3', source: 'filter1', target: 'condition1' },\n        { id: 'e4', source: 'condition1', target: 'merge1', condition: 'true' },\n        { id: 'e5', source: 'condition1', target: 'merge1', condition: 'false' },\n        { id: 'e6', source: 'merge1', target: 'end' }\n      ]\n    };\n  }\n\n  /**\n   * 延迟函数\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * 生成执行ID\n   */\n  private generateExecutionId(): string {\n    return `test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * 获取统计信息\n   */\n  getStats() {\n    const executions = Array.from(this.activeExecutions.values());\n\n    return {\n      active: executions.length,\n      byStatus: {\n        pending: executions.filter((e) => e.status === 'pending').length,\n        running: executions.filter((e) => e.status === 'running').length,\n        completed: executions.filter((e) => e.status === 'completed').length,\n        failed: executions.filter((e) => e.status === 'failed').length,\n        cancelled: executions.filter((e) => e.status === 'cancelled').length\n      },\n      byMode: {\n        mock: executions.filter((e) => e.mode === 'mock').length,\n        real: executions.filter((e) => e.mode === 'real').length\n      }\n    };\n  }\n}\n\n// 单例实例\nconst pipelineTestRunnerService = new PipelineTestRunnerService();\n\n// 定期清理已完成的试跑\nsetInterval(\n  () => {\n    pipelineTestRunnerService.cleanupCompletedTests().catch((error) => {\n      logger.error('清理Pipeline试跑失败:', error);\n    });\n  },\n  5 * 60 * 1000\n); // 每5分钟清理一次\n\nmodule.exports = pipelineTestRunnerService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipeline-validator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipelineEngine.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/pipelineEngine.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const pipelineEngine: {\n  executePipeline: (taskId: string, featureId: string, inputData: any) => Promise<any>;\n};\nexport default pipelineEngine;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipelineEngine.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipelineExecution.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·input_config?:·{·mapping?:·Record<string,·string>·}` with `⏎······input_config?:·{·mapping?:·Record<string,·string>·};⏎···`","line":247,"column":54,"nodeType":null,"messageId":"replace","endLine":247,"endColumn":106,"fix":{"range":[7584,7636],"text":"\n      input_config?: { mapping?: Record<string, string> };\n   "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `execution,·node,·branch,·previousResults,·index` with `⏎··········execution,⏎··········node,⏎··········branch,⏎··········previousResults,⏎··········index⏎········`","line":332,"column":57,"nodeType":null,"messageId":"replace","endLine":332,"endColumn":104,"fix":{"range":[10903,10950],"text":"\n          execution,\n          node,\n          branch,\n          previousResults,\n          index\n        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····executionId:·string,⏎····outputData:·Record<string,·unknown>⏎··` with `executionId:·string,·outputData:·Record<string,·unknown>`","line":413,"column":27,"nodeType":null,"messageId":"replace","endLine":416,"endColumn":3,"fix":{"range":[13533,13601],"text":"executionId: string, outputData: Record<string, unknown>"}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎····`","line":497,"column":17,"nodeType":null,"messageId":"insert","endLine":497,"endColumn":17,"fix":{"range":[16546,16546],"text":"\n    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":498,"column":1,"nodeType":null,"messageId":"insert","endLine":498,"endColumn":1,"fix":{"range":[16557,16557],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":499,"column":5,"nodeType":null,"messageId":"insert","endLine":499,"endColumn":5,"fix":{"range":[16585,16585],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":500,"column":1,"nodeType":null,"messageId":"insert","endLine":500,"endColumn":1,"fix":{"range":[16611,16611],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":501,"column":5,"nodeType":null,"messageId":"insert","endLine":501,"endColumn":5,"fix":{"range":[16641,16641],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····` with `······`","line":502,"column":1,"nodeType":null,"messageId":"replace","endLine":502,"endColumn":5,"fix":{"range":[16657,16661],"text":"      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}·=·{}` with `··}·=·{}⏎··`","line":503,"column":3,"nodeType":null,"messageId":"replace","endLine":503,"endColumn":9,"fix":{"range":[16680,16686],"text":"  } = {}\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····executionId:·string,⏎····eventType:·string,⏎····data:·Record<string,·unknown>⏎··` with `executionId:·string,·eventType:·string,·data:·Record<string,·unknown>`","line":590,"column":22,"nodeType":null,"messageId":"replace","endLine":594,"endColumn":3,"fix":{"range":[19609,19694],"text":"executionId: string, eventType: string, data: Record<string, unknown>"}}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":11,"fixableWarningCount":0,"source":"import logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport { EventEmitter } from 'events';\nimport pipelineSchemaService from './pipelineSchema.service.js';\nimport type {\n  ExecutionStatus,\n  NodeStatus,\n  ExecutionMode,\n  PipelineExecution,\n  ExecutionStep,\n  PipelineSchema,\n  PipelineNodeDefinition,\n  NodeExecutionResult,\n  ExecutionContext,\n  ErrorDetails,\n  ConditionExpression,\n  TransformResult,\n  ConditionResult,\n  LoopResult,\n  ParallelResult,\n  ParallelBranchResult\n} from '../engine/pipeline-types.js';\n\nclass PipelineExecutionService extends EventEmitter {\n  public readonly EXECUTION_MODES = { MOCK: 'mock', REAL: 'real' } as const;\n  public readonly EXECUTION_STATUS = {\n    PENDING: 'pending',\n    RUNNING: 'running',\n    COMPLETED: 'completed',\n    FAILED: 'failed',\n    CANCELLED: 'cancelled'\n  } as const;\n  public readonly NODE_STATUS = {\n    PENDING: 'pending',\n    RUNNING: 'running',\n    COMPLETED: 'completed',\n    FAILED: 'failed',\n    SKIPPED: 'skipped'\n  } as const;\n\n  private executions: Map<string, PipelineExecution> = new Map();\n  private executionSteps: Map<string, ExecutionStep[]> = new Map();\n\n  getActiveExecutionCount(): number {\n    return this.executions.size;\n  }\n\n  async createExecution(\n    schemaId: string,\n    inputData: Record<string, unknown>,\n    mode: ExecutionMode = this.EXECUTION_MODES.MOCK,\n    userId: string | null = null\n  ): Promise<PipelineExecution> {\n    try {\n      const executionId = this.generateId();\n      const execution: PipelineExecution = {\n        id: executionId,\n        schema_id: schemaId,\n        execution_mode: mode,\n        status: this.EXECUTION_STATUS.PENDING as ExecutionStatus,\n        input_data: inputData,\n        output_data: null,\n        execution_context: this.createExecutionContext(inputData, mode),\n        execution_metadata: {\n          created_at: new Date().toISOString(),\n          created_by: userId,\n          node_count: 0,\n          step_count: 0\n        },\n        started_at: null,\n        completed_at: null,\n        duration_ms: null,\n        error_message: null,\n        error_details: null\n      };\n\n      this.executions.set(executionId, execution);\n\n      const schema = await pipelineSchemaService.getSchemaById(schemaId);\n      execution.schema = schema as PipelineSchema;\n\n      await this.createExecutionSteps(executionId, schema.node_definitions);\n\n      logger.info(`[PipelineExecutionService] Created execution: ${executionId}`, {\n        schemaId,\n        mode,\n        userId\n      });\n\n      return execution;\n    } catch (error) {\n      logger.error('[PipelineExecutionService] Create execution failed:', error);\n      throw AppError.custom(ERROR_CODES.INTERNAL_SERVER_ERROR, '创建执行任务失败');\n    }\n  }\n\n  async startExecution(executionId: string) {\n    try {\n      const execution = this.executions.get(executionId);\n      if (!execution) {\n        throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '执行任务不存在');\n      }\n      if (execution.status !== this.EXECUTION_STATUS.PENDING) {\n        throw AppError.custom(ERROR_CODES.INVALID_REQUEST, '执行任务已开始或完成');\n      }\n      execution.status = this.EXECUTION_STATUS.RUNNING;\n      execution.started_at = new Date().toISOString();\n\n      this.emitExecutionEvent(executionId, 'execution:started', {\n        execution_id: executionId,\n        status: execution.status,\n        started_at: execution.started_at\n      });\n\n      await this.executePipeline(executionId);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : '未知错误';\n      logger.error('[PipelineExecutionService] Start execution failed:', error);\n      await this.failExecution(executionId, errorMessage);\n      throw error;\n    }\n  }\n\n  async executePipeline(executionId: string): Promise<void> {\n    const execution = this.executions.get(executionId);\n    const steps = this.executionSteps.get(executionId) || [];\n\n    const results: Record<string, NodeExecutionResult> = {};\n\n    const adjacency = new Map<string, string[]>();\n    for (const step of steps) {\n      adjacency.set(step.node_id, []);\n    }\n    // 构造执行顺序（简单按 steps 顺序执行，若有依赖，可在 node.config.dependencies 中声明）\n    const getDependencies = (node: ExecutionStep): string[] =>\n      (node?.config?.dependencies ?? []) as string[];\n\n    const executeNode = async (nodeId: string) => {\n      const step = steps.find((s) => s.node_id === nodeId);\n      if (!step) return;\n\n      // 先跑依赖\n      for (const depId of getDependencies(step)) {\n        if (!results[depId]) {\n          await executeNode(depId);\n        }\n      }\n\n      await this.updateStepStatus(executionId, nodeId, this.NODE_STATUS.RUNNING);\n      const nodeResult = await this.executeNode(executionId, step, results);\n      results[nodeId] = nodeResult;\n      await this.updateStepStatus(\n        executionId,\n        nodeId,\n        this.NODE_STATUS.COMPLETED,\n        null,\n        nodeResult.output\n      );\n    };\n\n    for (const step of steps) {\n      await executeNode(step.node_id);\n    }\n\n    // 结束\n    const outputData = this.mergeResults(results, execution?.schema?.output_schema);\n    await this.completeExecution(executionId, outputData);\n  }\n\n  async executeNode(\n    executionId: string,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<NodeExecutionResult> {\n    const execution = this.executions.get(executionId);\n    if (!execution) throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '执行任务不存在');\n\n    const startTime = Date.now();\n    try {\n      let output: Record<string, unknown> | null = null;\n\n      switch (node.node_type) {\n        case 'input':\n          output = this.executeInputNode(execution, node);\n          break;\n        case 'output':\n          output = this.executeOutputNode(execution, node, previousResults);\n          break;\n        case 'transform':\n          output = (await this.executeTransformNode(\n            execution,\n            node,\n            previousResults\n          )) as unknown as Record<string, unknown>;\n          break;\n        case 'condition':\n          output = (await this.executeConditionNode(\n            execution,\n            node,\n            previousResults\n          )) as unknown as Record<string, unknown>;\n          break;\n        case 'loop':\n          output = (await this.executeLoopNode(\n            execution,\n            node,\n            previousResults\n          )) as unknown as Record<string, unknown>;\n          break;\n        case 'parallel':\n          output = (await this.executeParallelNode(\n            execution,\n            node,\n            previousResults\n          )) as unknown as Record<string, unknown>;\n          break;\n        case 'merge':\n          output = await this.executeMergeNode(execution, node, previousResults);\n          break;\n        default:\n          throw new Error(`未知的节点类型: ${node.node_type}`);\n      }\n\n      return {\n        node_id: node.node_id,\n        success: true,\n        output,\n        duration_ms: Date.now() - startTime\n      };\n    } catch (error) {\n      return {\n        node_id: node.node_id,\n        success: false,\n        output: null,\n        error: {\n          message: error instanceof Error ? error.message : '节点执行失败',\n          code: 'NODE_EXECUTION_ERROR'\n        },\n        duration_ms: Date.now() - startTime\n      };\n    }\n  }\n\n  executeInputNode(execution: PipelineExecution, node: ExecutionStep): Record<string, unknown> {\n    const { input_data } = execution;\n    const { input_config } = (node.config || {}) as { input_config?: { mapping?: Record<string, string> } };\n    let result = input_data;\n    if (input_config && input_config.mapping) {\n      result = this.mapInputData(input_data, input_config.mapping);\n    }\n    return result;\n  }\n\n  executeOutputNode(\n    _execution: PipelineExecution,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Record<string, unknown> {\n    const config = node.config as { output_config?: { ports?: Record<string, { name?: string }> } };\n    const { output_config } = config || {};\n    const result: Record<string, unknown> = {};\n    for (const [sourceNodeId, portConfig] of Object.entries(output_config?.ports || {})) {\n      const nodeResult = previousResults[sourceNodeId];\n      if (nodeResult && nodeResult.output) {\n        result[portConfig.name || sourceNodeId] = nodeResult.output;\n      }\n    }\n    return result;\n  }\n\n  async executeTransformNode(\n    execution: PipelineExecution,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<TransformResult> {\n    const mode = execution.execution_mode as ExecutionMode;\n    const config = node.config as { transform_config?: Record<string, unknown> };\n    const { transform_config } = config || {};\n    if (mode === this.EXECUTION_MODES.MOCK) {\n      return this.generateMockTransformResult(node, previousResults);\n    }\n    return await this.executeRealTransform(node, previousResults, transform_config);\n  }\n\n  async executeConditionNode(\n    _execution: PipelineExecution,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<ConditionResult> {\n    const config = node.config as { condition_config?: { condition?: ConditionExpression } };\n    const { condition_config } = config || {};\n    const { condition } = condition_config || {};\n    const conditionResult = this.evaluateCondition(condition, previousResults);\n    return {\n      condition_result: conditionResult,\n      selected_branch: conditionResult ? 'true' : 'false'\n    };\n  }\n\n  async executeLoopNode(\n    execution: PipelineExecution,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<LoopResult> {\n    const config = node.config as { loop_config?: { iterations?: number } };\n    const { loop_config } = config || {};\n    const { iterations = 3 } = loop_config || {};\n    const results: unknown[] = [];\n    for (let i = 0; i < iterations; i++) {\n      const iterationResult = await this.executeLoopIteration(execution, node, previousResults, i);\n      results.push(iterationResult);\n      this.emitExecutionEvent(execution.id, 'loop:iteration', {\n        node_id: node.node_id,\n        iteration: i,\n        result: iterationResult\n      });\n    }\n    return { iterations: results, total_iterations: iterations };\n  }\n\n  async executeParallelNode(\n    execution: PipelineExecution,\n    node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<ParallelResult> {\n    const config = node.config as { parallel_config?: { branches?: unknown[] } };\n    const { parallel_config } = config || {};\n    const { branches = [] } = parallel_config || {};\n    const promises = branches.map(async (branch, index) => {\n      try {\n        const result = await this.executeParallelBranch(execution, node, branch, previousResults, index);\n        return { ...result, success: true };\n      } catch (error) {\n        return {\n          error: error instanceof Error ? error.message : '分支执行失败',\n          branch_index: index,\n          success: false\n        };\n      }\n    });\n    const results = await Promise.all(promises);\n    return {\n      branches: results as ParallelBranchResult[],\n      successful_branches: results.filter((r) => r.success).length\n    };\n  }\n\n  async executeMergeNode(\n    _execution: PipelineExecution,\n    _node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>\n  ): Promise<Record<string, unknown>> {\n    const outputs = Object.values(previousResults)\n      .map((r) => r.output)\n      .filter((o): o is Record<string, unknown> => o !== null);\n    return this.combineResults(outputs);\n  }\n\n  generateMockTransformResult(\n    node: ExecutionStep,\n    _previousResults: Record<string, NodeExecutionResult>\n  ): TransformResult {\n    const config = node.config as { mock?: { type?: string } };\n    const mockData: TransformResult = {\n      node_id: node.node_id,\n      processed_at: new Date().toISOString()\n    };\n    switch (config?.mock?.type) {\n      case 'text_summary':\n        return { ...mockData, summary: 'This is a mock summary.' };\n      case 'image_process':\n        return { ...mockData, width: 512, height: 512, format: 'png' };\n      default:\n        return {\n          ...mockData,\n          output_format: 'generic_output',\n          data_size: Math.floor(Math.random() * 10000)\n        };\n    }\n  }\n\n  async executeRealTransform(\n    _node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>,\n    transformConfig?: Record<string, unknown>\n  ): Promise<TransformResult> {\n    await new Promise((r) => setTimeout(r, 1000 + Math.random() * 2000));\n    return {\n      node_id: _node.node_id,\n      processed_data: previousResults,\n      transformation_applied: (transformConfig?.type as string) || 'default',\n      processed_at: new Date().toISOString()\n    };\n  }\n\n  evaluateCondition(\n    condition: ConditionExpression | undefined,\n    previousResults: Record<string, NodeExecutionResult>\n  ): boolean {\n    if (!condition) return true;\n    if (condition.type === 'exists') {\n      const { variable } = condition;\n      return variable ? Object.prototype.hasOwnProperty.call(previousResults, variable) : false;\n    }\n    if (condition.type === 'equals') {\n      const { variable, value } = condition;\n      return variable ? previousResults[variable]?.output === value : false;\n    }\n    return true;\n  }\n\n  async completeExecution(\n    executionId: string,\n    outputData: Record<string, unknown>\n  ): Promise<void> {\n    const execution = this.executions.get(executionId);\n    if (!execution) return;\n    execution.status = this.EXECUTION_STATUS.COMPLETED;\n    execution.completed_at = new Date().toISOString();\n    execution.duration_ms = execution.started_at\n      ? Date.now() - new Date(execution.started_at).getTime()\n      : null;\n    execution.output_data = outputData;\n    this.emitExecutionEvent(executionId, 'execution:completed', {\n      execution_id: executionId,\n      status: execution.status,\n      completed_at: execution.completed_at,\n      duration_ms: execution.duration_ms,\n      output_data: outputData\n    });\n    logger.info(`[PipelineExecutionService] Execution completed: ${executionId}`, {\n      duration: execution.duration_ms,\n      status: execution.status\n    });\n  }\n\n  async failExecution(\n    executionId: string,\n    errorMessage: string,\n    errorDetails: Error | null = null\n  ): Promise<void> {\n    const execution = this.executions.get(executionId);\n    if (!execution) return;\n    execution.status = this.EXECUTION_STATUS.FAILED;\n    execution.completed_at = new Date().toISOString();\n    execution.duration_ms = execution.started_at\n      ? Date.now() - new Date(execution.started_at).getTime()\n      : null;\n    execution.error_message = errorMessage;\n    execution.error_details = errorDetails\n      ? { message: errorDetails.message, stack: errorDetails.stack }\n      : null;\n    this.emitExecutionEvent(executionId, 'execution:failed', {\n      execution_id: executionId,\n      status: execution.status,\n      error_message: errorMessage,\n      error_details: execution.error_details\n    });\n    logger.error(`[PipelineExecutionService] Execution failed: ${executionId}`, {\n      error: errorMessage\n    });\n  }\n\n  async cancelExecution(executionId: string, reason: string = '用户取消'): Promise<boolean> {\n    const execution = this.executions.get(executionId);\n    if (!execution) {\n      throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '执行任务不存在');\n    }\n    if (\n      execution.status === this.EXECUTION_STATUS.COMPLETED ||\n      execution.status === this.EXECUTION_STATUS.FAILED ||\n      execution.status === this.EXECUTION_STATUS.CANCELLED\n    ) {\n      throw AppError.custom(ERROR_CODES.INVALID_REQUEST, '执行任务已完成，无法取消');\n    }\n    execution.status = this.EXECUTION_STATUS.CANCELLED;\n    execution.completed_at = new Date().toISOString();\n    execution.duration_ms = execution.started_at\n      ? Date.now() - new Date(execution.started_at).getTime()\n      : null;\n    execution.error_message = reason;\n    this.emitExecutionEvent(executionId, 'execution:cancelled', {\n      execution_id: executionId,\n      status: execution.status,\n      reason\n    });\n    return true;\n  }\n\n  getExecution(id: string): PipelineExecution {\n    const execution = this.executions.get(id);\n    if (!execution) throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '执行任务不存在');\n    return execution;\n  }\n\n  getExecutions(options: {\n    schema_id?: string;\n    status?: ExecutionStatus;\n    mode?: ExecutionMode;\n    limit?: number;\n    offset?: number;\n  } = {}) {\n    const { schema_id, status, mode, limit = 20, offset = 0 } = options;\n    let executions: PipelineExecution[] = Array.from(this.executions.values());\n    if (schema_id) executions = executions.filter((e) => e.schema_id === schema_id);\n    if (status) executions = executions.filter((e) => e.status === status);\n    if (mode) executions = executions.filter((e) => e.execution_mode === mode);\n    executions.sort(\n      (a, b) =>\n        new Date(b.execution_metadata.created_at || 0).getTime() -\n        new Date(a.execution_metadata.created_at || 0).getTime()\n    );\n    const total = executions.length;\n    const paginatedExecutions = executions.slice(offset, offset + limit);\n    return {\n      executions: paginatedExecutions,\n      pagination: { total, limit, offset, pages: Math.ceil(total / limit) }\n    };\n  }\n\n  createExecutionContext(\n    inputData: Record<string, unknown>,\n    mode: ExecutionMode\n  ): ExecutionContext {\n    return {\n      mode,\n      variables: {},\n      state: inputData,\n      trace_id: this.generateId()\n    };\n  }\n\n  async createExecutionSteps(\n    executionId: string,\n    nodeDefinitions: PipelineNodeDefinition[]\n  ): Promise<ExecutionStep[]> {\n    const steps: ExecutionStep[] = [];\n    for (const node of nodeDefinitions || []) {\n      steps.push({\n        id: this.generateId(),\n        execution_id: executionId,\n        node_id: node.node_id,\n        node_type: node.node_type,\n        status: this.NODE_STATUS.PENDING as NodeStatus,\n        input_data: null,\n        output_data: null,\n        error_message: null,\n        started_at: null,\n        completed_at: null,\n        duration_ms: null,\n        retry_count: 0,\n        metadata: { node_name: node.node_name, created_at: new Date().toISOString() }\n      });\n    }\n    this.executionSteps.set(executionId, steps);\n    return steps;\n  }\n\n  async updateStepStatus(\n    executionId: string,\n    nodeId: string,\n    status: NodeStatus,\n    errorMessage: string | null = null,\n    outputData: Record<string, unknown> | null = null\n  ): Promise<void> {\n    const steps = this.executionSteps.get(executionId) || [];\n    const step = steps.find((s) => s.node_id === nodeId);\n    if (step) {\n      step.status = status;\n      if (status === this.NODE_STATUS.RUNNING) {\n        step.started_at = new Date().toISOString();\n      } else if (status === this.NODE_STATUS.COMPLETED || status === this.NODE_STATUS.FAILED) {\n        step.completed_at = new Date().toISOString();\n        step.duration_ms = step.started_at\n          ? Date.now() - new Date(step.started_at).getTime()\n          : null;\n      }\n      if (errorMessage) step.error_message = errorMessage;\n      if (outputData) step.output_data = outputData;\n      this.emitExecutionEvent(executionId, 'step:updated', {\n        node_id: nodeId,\n        status,\n        error_message: errorMessage,\n        output_data: outputData\n      });\n    }\n  }\n\n  emitExecutionEvent(\n    executionId: string,\n    eventType: string,\n    data: Record<string, unknown>\n  ): void {\n    const event = {\n      type: eventType,\n      execution_id: executionId,\n      timestamp: new Date().toISOString(),\n      ...data\n    };\n    this.emit('execution:event', event);\n  }\n\n  generateId(): string {\n    return 'exec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  cleanupExpiredExecutions(maxAge: number = 24 * 60 * 60 * 1000): number {\n    const now = Date.now();\n    const expiredIds: string[] = [];\n    for (const [executionId, execution] of this.executions.entries()) {\n      const createdTime = new Date(execution.execution_metadata.created_at || 0).getTime();\n      if (now - createdTime > maxAge) expiredIds.push(executionId);\n    }\n    for (const id of expiredIds) {\n      this.executions.delete(id);\n      this.executionSteps.delete(id);\n    }\n    if (expiredIds.length > 0) {\n      logger.info(`[PipelineExecutionService] Cleaned up ${expiredIds.length} expired executions`);\n    }\n    return expiredIds.length;\n  }\n\n  mapInputData(\n    inputData: Record<string, unknown>,\n    mapping: Record<string, string>\n  ): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n    for (const [targetKey, sourcePath] of Object.entries(mapping)) {\n      result[targetKey] = this.getNestedValue(inputData, sourcePath);\n    }\n    return result;\n  }\n\n  getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n    return path.split('.').reduce((current: unknown, key: string) => {\n      if (current && typeof current === 'object' && key in current) {\n        return (current as Record<string, unknown>)[key];\n      }\n      return undefined;\n    }, obj);\n  }\n\n  combineResults(results: Record<string, unknown>[]): Record<string, unknown> {\n    return results.reduce(\n      (combined, result) => ({ ...combined, ...(result || {}) }),\n      {} as Record<string, unknown>\n    );\n  }\n\n  mergeResultsArray(results: unknown[]): { merged_results: unknown[]; total_count: number } {\n    return { merged_results: results, total_count: results.length };\n  }\n\n  flattenResults(results: unknown[][]): unknown[] {\n    return results.flat();\n  }\n\n  executeLoopIteration(\n    _execution: PipelineExecution,\n    _node: ExecutionStep,\n    previousResults: Record<string, NodeExecutionResult>,\n    iteration: number\n  ): Record<string, unknown> {\n    return {\n      iteration,\n      input_data: previousResults,\n      result: `Loop iteration ${iteration} result`\n    };\n  }\n\n  executeParallelBranch(\n    _execution: PipelineExecution,\n    _node: ExecutionStep,\n    branch: unknown,\n    previousResults: Record<string, NodeExecutionResult>,\n    index: number\n  ): ParallelBranchResult {\n    const branchConfig = branch as { name?: string };\n    return {\n      branch_index: index,\n      branch_id: branchConfig?.name || `branch_${index}`,\n      success: true,\n      result: `Parallel branch ${index} result`,\n      duration_ms: 0\n    };\n  }\n\n  mergeResults(\n    results: Record<string, NodeExecutionResult>,\n    _outputSchema: unknown\n  ): Record<string, unknown> {\n    const merged: Record<string, unknown> = {};\n    for (const result of Object.values(results)) {\n      if (result.output && typeof result.output === 'object') {\n        Object.assign(merged, result.output);\n      }\n    }\n    return merged;\n  }\n}\n\nexport default new PipelineExecutionService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipelineSchema.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/pipelineValidator.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/prompt-template.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/prompt.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/promptTemplate.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `'system',·'user',·'assistant',·'function'` with `⏎····'system',⏎····'user',⏎····'assistant',⏎····'function'⏎··`","line":39,"column":60,"nodeType":null,"messageId":"replace","endLine":39,"endColumn":101,"fix":{"range":[1111,1152],"text":"\n    'system',\n    'user',\n    'assistant',\n    'function'\n  "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { db } from '../config/database.js';\nimport logger from '../utils/logger.js';\nimport AppError from '../utils/AppError.js';\nimport { ERROR_CODES } from '../config/error-codes.js';\nimport cmsCacheService from './cmsCache.service.js';\nimport type {\n  PromptTemplate,\n  TemplateQueryOptions,\n  TemplateListResponse,\n  VersionQueryOptions,\n  VersionListResponse,\n  PreviewResult,\n  ValidationResult,\n  TemplateStats,\n  BatchPreviewItem,\n  Variables,\n  TemplateMetadata,\n  TemplateStatus,\n  TemplateCategory\n} from '../types/prompt-template.types.js';\n\n// 艹！PromptTemplate Service - 已消除所有any类型\ninterface CmsCache {\n  generateVersion(scope: string, key: string): Promise<number>;\n  createSnapshot(\n    scope: string,\n    key: string,\n    data: unknown,\n    action: string,\n    description: string,\n    userId: string\n  ): Promise<void>;\n  invalidate(scope: string, key: string): Promise<void>;\n}\n\nclass PromptTemplateService {\n  private readonly CACHE_SCOPE = 'prompt_templates';\n  private readonly VARIABLE_PATTERN = /\\{\\{(\\w+)\\}\\}/g; // {{variable}}\n  private readonly VALID_CATEGORIES: TemplateCategory[] = ['system', 'user', 'assistant', 'function'];\n  private readonly VALID_STATUSES: TemplateStatus[] = ['draft', 'published', 'archived'];\n\n  async getTemplates(options: TemplateQueryOptions = {}): Promise<TemplateListResponse> {\n    const {\n      page = 1,\n      limit = 20,\n      category,\n      status = 'published',\n      search,\n      sortBy = 'updated_at',\n      sortOrder = 'desc',\n      created_by\n    } = options;\n    const offset = (parseInt(String(page)) - 1) * parseInt(String(limit));\n\n    let query = db('prompt_templates')\n      .select([\n        'prompt_templates.*',\n        'creator.username as created_by_username',\n        'updater.username as updated_by_username'\n      ])\n      .leftJoin('users as creator', 'prompt_templates.created_by', 'creator.id')\n      .leftJoin('users as updater', 'prompt_templates.updated_by', 'updater.id');\n\n    if (category) query = query.where('prompt_templates.category', category);\n    if (status) {\n      if (Array.isArray(status)) query = query.whereIn('prompt_templates.status', status);\n      else query = query.where('prompt_templates.status', status);\n    }\n    if (created_by) query = query.where('prompt_templates.created_by', created_by);\n    if (search) {\n      query = query.where(function () {\n        this.where('prompt_templates.name', 'like', `%${search}%`)\n          .orWhere('prompt_templates.description', 'like', `%${search}%`)\n          .orWhere('prompt_templates.content', 'like', `%${search}%`);\n      });\n    }\n\n    const validSortFields = ['name', 'category', 'status', 'version', 'created_at', 'updated_at'];\n    const sortField = validSortFields.includes(sortBy) ? sortBy : 'updated_at';\n    const sortDirection = String(sortOrder).toLowerCase() === 'asc' ? 'asc' : 'desc';\n    query = query.orderBy(`prompt_templates.${sortField}`, sortDirection);\n\n    const rawTemplates = await query.limit(parseInt(String(limit))).offset(offset);\n\n    let countQuery = db('prompt_templates');\n    if (category) countQuery = countQuery.where('category', category);\n    if (status) {\n      if (Array.isArray(status)) countQuery = countQuery.whereIn('status', status);\n      else countQuery = countQuery.where('status', status);\n    }\n    if (created_by) countQuery = countQuery.where('created_by', created_by);\n    if (search) {\n      countQuery = countQuery.where(function () {\n        this.where('name', 'like', `%${search}%`)\n          .orWhere('description', 'like', `%${search}%`)\n          .orWhere('content', 'like', `%${search}%`);\n      });\n    }\n\n    const totalResult = (await countQuery.count('* as count').first()) as { count: number };\n\n    return {\n      templates: rawTemplates.map((t) => this.parseTemplate(t)),\n      pagination: {\n        page: parseInt(String(page)),\n        limit: parseInt(String(limit)),\n        total: totalResult.count,\n        totalPages: Math.ceil(totalResult.count / parseInt(String(limit)))\n      }\n    };\n  }\n\n  async getTemplateById(id: string): Promise<PromptTemplate> {\n    const template = await db('prompt_templates')\n      .select([\n        'prompt_templates.*',\n        'creator.username as created_by_username',\n        'updater.username as updated_by_username'\n      ])\n      .leftJoin('users as creator', 'prompt_templates.created_by', 'creator.id')\n      .leftJoin('users as updater', 'prompt_templates.updated_by', 'updater.id')\n      .where('prompt_templates.id', id)\n      .first();\n    if (!template) throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '模板不存在');\n    return this.parseTemplate(template);\n  }\n\n  async getTemplateByKey(key: string, version: number | null = null): Promise<PromptTemplate> {\n    let query = db('prompt_templates').where('key', key);\n    if (version !== null && version !== undefined) {\n      query = query.where('version', version);\n    } else {\n      query = query.where('status', 'published').orderBy('version', 'desc');\n    }\n    const template = await query.first();\n    if (!template) throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '模板不存在');\n    return this.parseTemplate(template);\n  }\n\n  async createTemplate(\n    templateData: Partial<PromptTemplate> & {\n      key: string;\n      name: string;\n      content: string;\n      category: TemplateCategory;\n    },\n    userId: string\n  ): Promise<PromptTemplate> {\n    const {\n      key,\n      name,\n      description,\n      content,\n      category,\n      variables = {},\n      metadata = {},\n      status = 'draft'\n    } = templateData;\n\n    if (!this.VALID_CATEGORIES.includes(category)) {\n      throw AppError.custom(ERROR_CODES.INVALID_PARAMETERS, '无效的模板分类');\n    }\n    if (!this.VALID_STATUSES.includes(status as TemplateStatus)) {\n      throw AppError.custom(ERROR_CODES.INVALID_PARAMETERS, '无效的模板状态');\n    }\n\n    const version = await (cmsCacheService as unknown as CmsCache).generateVersion(\n      this.CACHE_SCOPE,\n      key\n    );\n    const [template] = await db('prompt_templates')\n      .insert({\n        key,\n        name,\n        description,\n        content,\n        category,\n        variables: variables ? JSON.stringify(variables) : null,\n        metadata: metadata ? JSON.stringify(metadata) : null,\n        status,\n        version,\n        created_by: userId,\n        updated_by: userId,\n        created_at: new Date(),\n        updated_at: new Date()\n      })\n      .returning('*');\n\n    await (cmsCacheService as unknown as CmsCache).createSnapshot(\n      this.CACHE_SCOPE,\n      key,\n      template,\n      'create',\n      '创建模板',\n      userId\n    );\n    await (cmsCacheService as unknown as CmsCache).invalidate(this.CACHE_SCOPE, key);\n    logger.info('[PromptTemplateService] Template created', { key, userId });\n\n    return this.parseTemplate(template);\n  }\n\n  async updateTemplate(\n    id: string,\n    updateData: Partial<PromptTemplate>,\n    userId: string\n  ): Promise<PromptTemplate> {\n    const existing = await db('prompt_templates').where('id', id).first();\n    if (!existing) throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '模板不存在');\n\n    const payload: Record<string, unknown> = {\n      ...updateData,\n      updated_by: userId,\n      updated_at: new Date()\n    };\n    if (updateData.variables !== undefined) {\n      payload.variables = JSON.stringify(updateData.variables);\n    }\n    if (updateData.metadata !== undefined) {\n      payload.metadata = JSON.stringify(updateData.metadata);\n    }\n\n    const [updated] = await db('prompt_templates').where('id', id).update(payload).returning('*');\n\n    await (cmsCacheService as unknown as CmsCache).createSnapshot(\n      this.CACHE_SCOPE,\n      existing.key as string,\n      updated,\n      'update',\n      '更新模板',\n      userId\n    );\n    await (cmsCacheService as unknown as CmsCache).invalidate(\n      this.CACHE_SCOPE,\n      existing.key as string\n    );\n\n    return this.parseTemplate(updated);\n  }\n\n  async deleteTemplate(id: string, userId: string): Promise<void> {\n    const template = await this.getTemplateById(id);\n    await db('prompt_templates').where('id', id).del();\n\n    await (cmsCacheService as unknown as CmsCache).createSnapshot(\n      this.CACHE_SCOPE,\n      template.key,\n      template,\n      'delete',\n      '删除模板',\n      userId\n    );\n    await (cmsCacheService as unknown as CmsCache).invalidate(this.CACHE_SCOPE, template.key);\n  }\n\n  async publishTemplate(id: string, userId: string): Promise<PromptTemplate> {\n    const template = await this.getTemplateById(id);\n    if (template.status === 'published') {\n      throw AppError.custom(ERROR_CODES.INVALID_REQUEST, '模板已发布');\n    }\n\n    const [published] = await db('prompt_templates')\n      .where('id', id)\n      .update({ status: 'published', updated_by: userId, updated_at: new Date() })\n      .returning('*');\n\n    await (cmsCacheService as unknown as CmsCache).createSnapshot(\n      this.CACHE_SCOPE,\n      template.key,\n      published,\n      'publish',\n      '发布模板',\n      userId\n    );\n    await (cmsCacheService as unknown as CmsCache).invalidate(this.CACHE_SCOPE, template.key);\n\n    return this.parseTemplate(published);\n  }\n\n  async archiveTemplate(id: string, userId: string): Promise<PromptTemplate> {\n    const template = await this.getTemplateById(id);\n    const [archived] = await db('prompt_templates')\n      .where('id', id)\n      .update({ status: 'archived', updated_by: userId, updated_at: new Date() })\n      .returning('*');\n\n    await (cmsCacheService as unknown as CmsCache).createSnapshot(\n      this.CACHE_SCOPE,\n      template.key,\n      archived,\n      'archive',\n      '归档模板',\n      userId\n    );\n    await (cmsCacheService as unknown as CmsCache).invalidate(this.CACHE_SCOPE, template.key);\n\n    return this.parseTemplate(archived);\n  }\n\n  async getTemplateVersions(\n    templateId: string,\n    options: VersionQueryOptions = {}\n  ): Promise<VersionListResponse> {\n    const { page = 1, limit = 20 } = options;\n    const template = await this.getTemplateById(templateId);\n    const offset = (page - 1) * limit;\n\n    const totalResult = (await db('prompt_template_versions')\n      .where({ template_id: templateId })\n      .count('* as count')\n      .first()) as { count: number };\n\n    const versions = await db('prompt_template_versions')\n      .where({ template_id: templateId })\n      .select(['version', 'status', 'change_log', 'created_by', 'created_at'])\n      .orderBy('version', 'desc')\n      .limit(limit)\n      .offset(offset);\n\n    return {\n      template: { id: templateId, key: template.key, name: template.name },\n      versions: versions.map((v) => ({\n        version: v.version as number,\n        status: v.status as TemplateStatus,\n        change_log: v.change_log as string | null,\n        created_by: v.created_by as string | number,\n        created_at: v.created_at as string\n      })),\n      pagination: {\n        current: page,\n        pageSize: limit,\n        total: totalResult.count,\n        totalPages: Math.ceil(totalResult.count / limit)\n      }\n    };\n  }\n\n  async rollbackToVersion(\n    templateId: string,\n    version: number,\n    userId: string\n  ): Promise<PromptTemplate> {\n    const template = await this.getTemplateById(templateId);\n    const latest = await db('prompt_templates').where('id', templateId).first();\n    const versionRecord = await db('prompt_template_versions')\n      .where({ template_id: templateId, version })\n      .orderBy('created_at', 'desc')\n      .first();\n\n    if (!versionRecord) {\n      throw AppError.custom(ERROR_CODES.TASK_NOT_FOUND, '目标版本不存在');\n    }\n\n    const newVersion = ((latest?.version as number) || 0) + 1;\n    const [rolledBackTemplate] = await db('prompt_templates')\n      .where('id', templateId)\n      .update({\n        content: versionRecord.content,\n        variables: versionRecord.variables,\n        metadata: versionRecord.metadata,\n        version: newVersion,\n        updated_by: userId,\n        updated_at: new Date()\n      })\n      .returning('*');\n\n    logger.info('[PromptTemplateService] Template rolled back:', {\n      templateId,\n      fromVersion: template.version,\n      toVersion: version,\n      newVersion\n    });\n\n    return this.parseTemplate(rolledBackTemplate);\n  }\n\n  async previewTemplate(\n    templateId: string,\n    variables: Record<string, unknown> = {}\n  ): Promise<PreviewResult> {\n    const template = await this.getTemplateById(templateId);\n    const requiredVariables = this.extractVariables(template.content);\n    const missingVariables = requiredVariables.filter(\n      (name) => !Object.prototype.hasOwnProperty.call(variables, name) || variables[name] === ''\n    );\n\n    if (missingVariables.length > 0) {\n      throw AppError.custom(\n        ERROR_CODES.MISSING_PARAMETERS,\n        `缺少必需的变量: ${missingVariables.join(', ')}`\n      );\n    }\n\n    const previewContent = this.replaceVariables(template.content, variables);\n    return {\n      templateId: template.id,\n      templateKey: template.key,\n      templateName: template.name,\n      variables: { provided: variables, required: requiredVariables, missing: missingVariables },\n      content: previewContent\n    };\n  }\n\n  async validateTemplate(templateId: string): Promise<ValidationResult> {\n    const template = await this.getTemplateById(templateId);\n    const extractedVariables = this.extractVariables(template.content);\n    const definedVariables = template.variables || {};\n    const issues: string[] = [];\n    const warnings: string[] = [];\n\n    extractedVariables.forEach((varName) => {\n      if (!Object.prototype.hasOwnProperty.call(definedVariables, varName)) {\n        warnings.push(`变量 {{${varName}}} 未在模板定义中声明`);\n      }\n    });\n\n    Object.keys(definedVariables).forEach((varName) => {\n      if (!extractedVariables.includes(varName)) {\n        warnings.push(`定义的变量 ${varName} 在模板中未使用`);\n      }\n    });\n\n    Object.entries(definedVariables).forEach(([varName, varDef]) => {\n      if (!varDef.type) warnings.push(`变量 ${varName} 缺少类型定义`);\n      if (varDef.required && !varDef.default && !extractedVariables.includes(varName)) {\n        warnings.push(`必需变量 ${varName} 有默认值但未在模板中使用`);\n      }\n    });\n\n    return {\n      valid: issues.length === 0,\n      issues,\n      warnings,\n      variables: {\n        extracted: extractedVariables,\n        defined: definedVariables,\n        count: extractedVariables.length\n      }\n    };\n  }\n\n  async getTemplateStats(): Promise<TemplateStats> {\n    const stats = (await db('prompt_templates')\n      .select(\n        db.raw('COUNT(*) as total'),\n        db.raw('COUNT(CASE WHEN status = \"published\" THEN 1 END) as published'),\n        db.raw('COUNT(CASE WHEN status = \"draft\" THEN 1 END) as draft'),\n        db.raw('COUNT(CASE WHEN status = \"archived\" THEN 1 END) as archived'),\n        db.raw('COUNT(CASE WHEN category = \"system\" THEN 1 END) as system'),\n        db.raw('COUNT(CASE WHEN category = \"user\" THEN 1 END) as user'),\n        db.raw('COUNT(CASE WHEN category = \"assistant\" THEN 1 END) as assistant'),\n        db.raw('COUNT(CASE WHEN category = \"function\" THEN 1 END) as function')\n      )\n      .first()) as TemplateStats;\n\n    return stats;\n  }\n\n  async getTemplateCategories(): Promise<TemplateCategory[]> {\n    return this.VALID_CATEGORIES;\n  }\n\n  async getTemplateExamples(): Promise<PromptTemplate[]> {\n    const examples = await db('prompt_templates')\n      .where('status', 'published')\n      .limit(5)\n      .orderBy('created_at', 'desc');\n    return examples.map((t) => this.parseTemplate(t));\n  }\n\n  async batchPreviewTemplates(\n    templates: BatchPreviewItem[]\n  ): Promise<Array<PreviewResult | { error: string }>> {\n    const results: Array<PreviewResult | { error: string }> = [];\n\n    for (const item of templates) {\n      try {\n        const result = await this.previewTemplate(item.id, item.variables || {});\n        results.push(result);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : '预览失败';\n        results.push({ error: errorMessage });\n      }\n    }\n\n    return results;\n  }\n\n  async createVersionRecord(\n    templateId: string,\n    version: number,\n    content: string,\n    variables: Variables | null,\n    metadata: TemplateMetadata | null,\n    changeLog: string,\n    status: TemplateStatus,\n    userId: string\n  ): Promise<void> {\n    await db('prompt_template_versions').insert({\n      template_id: templateId,\n      version,\n      content,\n      variables: variables ? JSON.stringify(variables) : null,\n      metadata: metadata ? JSON.stringify(metadata) : null,\n      change_log: changeLog,\n      status,\n      created_by: userId\n    });\n  }\n\n  extractVariables(content: string): string[] {\n    const matches = content.match(this.VARIABLE_PATTERN);\n    if (!matches) return [];\n    return matches\n      .map((m) => m.slice(2, -2))\n      .filter((varName, index, self) => self.indexOf(varName) === index);\n  }\n\n  validateVariables(definedVariables: Variables | null, extractedVariables: string[]): Variables {\n    if (!definedVariables) return {};\n    const validated: Variables = { ...definedVariables };\n    extractedVariables.forEach((varName) => {\n      if (!Object.prototype.hasOwnProperty.call(validated, varName)) {\n        validated[varName] = { type: 'string', description: `变量 ${varName}`, required: true };\n      }\n    });\n    return validated;\n  }\n\n  replaceVariables(content: string, variables: Record<string, unknown>): string {\n    return content.replace(this.VARIABLE_PATTERN, (match, varName: string) => {\n      if (Object.prototype.hasOwnProperty.call(variables, varName)) {\n        return String(variables[varName]);\n      }\n      return match;\n    });\n  }\n\n  private parseTemplate(raw: Record<string, unknown>): PromptTemplate {\n    return {\n      ...raw,\n      variables: raw.variables ? JSON.parse(raw.variables as string) : null,\n      metadata: raw.metadata ? JSON.parse(raw.metadata as string) : null\n    } as PromptTemplate;\n  }\n}\n\nexport default new PromptTemplateService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/provider-management.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/provider-registry.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/provider-registry.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const providerRegistryService: {\n  getRegisteredProviders: () => any[];\n  getAllProviderStates: () => any;\n  isProviderRegistered: (name: string) => boolean;\n  execute: (providerName: string, methodName: string, args?: any[], options?: any) => Promise<any>;\n  healthCheck: () => Promise<{ status: string } & Record<string, any>>;\n};\n\nexport default providerRegistryService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/provider-registry.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··type·HealthCheckResponse⏎` with `·type·HealthCheckResponse·`","line":2,"column":33,"nodeType":null,"messageId":"replace","endLine":4,"endColumn":1,"fix":{"range":[73,101],"text":" type HealthCheckResponse "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎······'imageProcess',⏎······imageProcessService·as·ProviderInstance,⏎·····` with `'imageProcess',·imageProcessService·as·ProviderInstance,`","line":32,"column":27,"nodeType":null,"messageId":"replace","endLine":35,"endColumn":6,"fix":{"range":[1050,1125],"text":"'imageProcess', imageProcessService as ProviderInstance,"}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":36,"column":1,"nodeType":null,"messageId":"delete","endLine":36,"endColumn":3,"fix":{"range":[1128,1130],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":37,"column":1,"nodeType":null,"messageId":"delete","endLine":37,"endColumn":3,"fix":{"range":[1154,1156],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":38,"column":9,"nodeType":null,"messageId":"delete","endLine":38,"endColumn":11,"fix":{"range":[1193,1195],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":39,"column":1,"nodeType":null,"messageId":"delete","endLine":39,"endColumn":3,"fix":{"range":[1216,1218],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":40,"column":1,"nodeType":null,"messageId":"delete","endLine":40,"endColumn":3,"fix":{"range":[1251,1253],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":41,"column":9,"nodeType":null,"messageId":"delete","endLine":41,"endColumn":11,"fix":{"range":[1290,1292],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":42,"column":7,"nodeType":null,"messageId":"delete","endLine":42,"endColumn":9,"fix":{"range":[1318,1320],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":43,"column":1,"nodeType":null,"messageId":"delete","endLine":43,"endColumn":3,"fix":{"range":[1323,1325],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":44,"column":7,"nodeType":null,"messageId":"delete","endLine":44,"endColumn":9,"fix":{"range":[1421,1423],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":45,"column":1,"nodeType":null,"messageId":"delete","endLine":45,"endColumn":3,"fix":{"range":[1439,1441],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··}⏎····` with `}`","line":46,"column":5,"nodeType":null,"messageId":"replace","endLine":47,"endColumn":5,"fix":{"range":[1486,1494],"text":"}"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎······'aiModel',⏎······aiModelService·as·ProviderInstance,⏎·····` with `'aiModel',·aiModelService·as·ProviderInstance,`","line":48,"column":27,"nodeType":null,"messageId":"replace","endLine":51,"endColumn":6,"fix":{"range":[1523,1588],"text":"'aiModel', aiModelService as ProviderInstance,"}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":52,"column":1,"nodeType":null,"messageId":"delete","endLine":52,"endColumn":3,"fix":{"range":[1591,1593],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":53,"column":1,"nodeType":null,"messageId":"delete","endLine":53,"endColumn":3,"fix":{"range":[1617,1619],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":54,"column":9,"nodeType":null,"messageId":"delete","endLine":54,"endColumn":11,"fix":{"range":[1656,1658],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":55,"column":1,"nodeType":null,"messageId":"delete","endLine":55,"endColumn":3,"fix":{"range":[1679,1681],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":56,"column":1,"nodeType":null,"messageId":"delete","endLine":56,"endColumn":3,"fix":{"range":[1714,1716],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":57,"column":9,"nodeType":null,"messageId":"delete","endLine":57,"endColumn":11,"fix":{"range":[1753,1755],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":58,"column":7,"nodeType":null,"messageId":"delete","endLine":58,"endColumn":9,"fix":{"range":[1781,1783],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":59,"column":1,"nodeType":null,"messageId":"delete","endLine":59,"endColumn":3,"fix":{"range":[1786,1788],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":60,"column":7,"nodeType":null,"messageId":"delete","endLine":60,"endColumn":9,"fix":{"range":[1879,1881],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `··`","line":61,"column":1,"nodeType":null,"messageId":"delete","endLine":61,"endColumn":3,"fix":{"range":[1898,1900],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··}⏎····` with `}`","line":62,"column":5,"nodeType":null,"messageId":"replace","endLine":63,"endColumn":5,"fix":{"range":[1945,1953],"text":"}"}}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":25,"fixableWarningCount":0,"source":"import logger from '../utils/logger.js';\nimport providerWrapperService, {\n  type HealthCheckResponse\n} from './provider-wrapper.service.js';\nimport imageProcessService from './imageProcess.service.js';\nimport aiModelService from './aiModel.service.js';\n\ntype ProviderConfig = Parameters<typeof providerWrapperService.registerProvider>[2];\n\ninterface ProviderInstance {\n  [key: string]: unknown;\n}\n\nclass ProviderRegistryService {\n  private registeredProviders = new Map<string, ProviderInstance>();\n  private providerConfigs = new Map<string, ProviderConfig>();\n  private initialized = false;\n\n  async initialize() {\n    if (this.initialized) {\n      logger.warn('[ProviderRegistry] 已初始化，跳过');\n      return;\n    }\n    logger.info('[ProviderRegistry] 开始注册Provider...');\n    await this.registerBuiltinProviders();\n    await this.registerExternalProviders();\n    this.initialized = true;\n    logger.info(`[ProviderRegistry] Provider注册完成，共 ${this.registeredProviders.size} 个`);\n  }\n\n  private async registerBuiltinProviders() {\n    this.registerProvider(\n      'imageProcess',\n      imageProcessService as ProviderInstance,\n      {\n        circuitBreaker: {\n          failureThreshold: 3,\n          resetTimeout: 30000,\n          monitoringPeriod: 10000,\n          halfOpenMaxCalls: 2,\n          successThreshold: 2\n        },\n        retry: { maxAttempts: 2, baseDelay: 1000, maxDelay: 8000, backoff: 'exponential' },\n        timeout: 60000,\n        cache: { ttl: 300, enabled: true }\n      }\n    );\n    this.registerProvider(\n      'aiModel',\n      aiModelService as ProviderInstance,\n      {\n        circuitBreaker: {\n          failureThreshold: 2,\n          resetTimeout: 60000,\n          monitoringPeriod: 15000,\n          halfOpenMaxCalls: 1,\n          successThreshold: 1\n        },\n        retry: { maxAttempts: 1, baseDelay: 2000, maxDelay: 5000, backoff: 'linear' },\n        timeout: 120000,\n        cache: { ttl: 600, enabled: true }\n      }\n    );\n  }\n\n  private async registerExternalProviders() {\n    // 预留：可以在此读取数据库/配置注册更多 Provider\n  }\n\n  registerProvider(name: string, provider: ProviderInstance, config: ProviderConfig = {}) {\n    providerWrapperService.registerProvider(name, provider, config);\n    this.registeredProviders.set(name, provider);\n    this.providerConfigs.set(name, config);\n  }\n\n  getRegisteredProviders() {\n    return Array.from(this.registeredProviders.keys());\n  }\n\n  isProviderRegistered(name: string): boolean {\n    return this.registeredProviders.has(name);\n  }\n\n  getAllProviderStates() {\n    return providerWrapperService.getAllProviderStates();\n  }\n\n  async execute(\n    providerName: string,\n    methodName: string,\n    args: unknown[] = [],\n    options: Record<string, unknown> = {}\n  ) {\n    return await providerWrapperService.execute(providerName, methodName, args, options);\n  }\n\n  async healthCheck(): Promise<HealthCheckResponse> {\n    const wrapperHealth = await providerWrapperService.healthCheck();\n    return wrapperHealth;\n  }\n}\n\nconst providerRegistryService = new ProviderRegistryService();\nexport default providerRegistryService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/provider-wrapper.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/provider-wrapper.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const providerWrapperService: {\n  getAllProviderStates: () => any;\n  getProviderStats: (name: string) => any;\n  resetProviderStats: (name: string) => boolean;\n  healthCheck: () => Promise<{ status: string } & Record<string, any>>;\n};\n\nexport default providerWrapperService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/provider-wrapper.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·providers:·Record<string,·unknown>` with `⏎····providers:·Record<string,·unknown>;⏎·`","line":200,"column":76,"nodeType":null,"messageId":"replace","endLine":200,"endColumn":111,"fix":{"range":[5632,5667],"text":"\n    providers: Record<string, unknown>;\n "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import logger from '../utils/logger.js';\nimport circuitBreakerService from './circuit-breaker.service.js';\nimport cacheService from './cache.service.js';\n\ntype Provider = Record<string, unknown>;\n\ninterface ProviderConfig {\n  circuitBreaker: {\n    failureThreshold: number;\n    resetTimeout: number;\n    monitoringPeriod: number;\n    halfOpenMaxCalls: number;\n    successThreshold: number;\n  };\n  retry: {\n    maxAttempts: number;\n    baseDelay: number;\n    maxDelay: number;\n    backoff: 'exponential' | 'fixed' | 'linear';\n  };\n  timeout: number;\n  cache: {\n    ttl: number;\n    enabled: boolean;\n  };\n}\n\ninterface CircuitBreakerState {\n  getState?: () => string;\n}\n\ninterface ProviderExecuteOptions {\n  [key: string]: unknown;\n}\n\ninterface ProviderStats {\n  totalRequests: number;\n  totalSuccesses: number;\n  totalFailures: number;\n  totalTimeouts: number;\n  totalCaches: number;\n  averageResponseTime: number;\n  totalResponseTime: number;\n  lastRequestTime: null | number;\n  lastSuccessTime: null | number;\n  lastFailureTime: null | number;\n  circuitBreaker?: unknown;\n}\n\nexport interface HealthCheckResponse {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  providers?: Record<string, unknown>;\n  totalProviders?: number;\n  activeProviders?: number;\n  timestamp: string;\n  error?: string;\n}\n\nclass ProviderWrapper {\n  constructor(\n    public readonly name: string,\n    public readonly provider: Provider,\n    public readonly config: ProviderConfig,\n    public readonly circuitBreaker: CircuitBreakerState\n  ) {}\n\n  private stats = {\n    totalRequests: 0,\n    totalSuccesses: 0,\n    totalFailures: 0,\n    totalTimeouts: 0,\n    totalCaches: 0,\n    averageResponseTime: 0,\n    totalResponseTime: 0,\n    lastRequestTime: null as null | number,\n    lastSuccessTime: null as null | number,\n    lastFailureTime: null as null | number\n  };\n\n  getStats() {\n    return { ...this.stats, circuitBreaker: this.circuitBreaker.getState?.() };\n  }\n\n  resetStats() {\n    this.stats = {\n      ...this.stats,\n      totalRequests: 0,\n      totalSuccesses: 0,\n      totalFailures: 0,\n      totalTimeouts: 0,\n      totalCaches: 0,\n      averageResponseTime: 0,\n      totalResponseTime: 0\n    };\n  }\n\n  getState() {\n    return { circuitBreaker: this.circuitBreaker, stats: this.getStats() };\n  }\n\n  async execute(\n    methodName: string,\n    args: unknown[] = [],\n    _options: ProviderExecuteOptions = {}\n  ): Promise<unknown> {\n    const opName = `provider:${this.name}:${methodName}`;\n    const doCall = async () => {\n      const start = Date.now();\n      this.stats.totalRequests++;\n      this.stats.lastRequestTime = start;\n      try {\n        const fn = this.provider?.[methodName];\n        if (typeof fn !== 'function')\n          throw new Error(`Provider方法不存在: ${this.name}.${methodName}`);\n        const result = await fn.apply(this.provider, args);\n        const dur = Date.now() - start;\n        this.stats.totalSuccesses++;\n        this.stats.totalResponseTime += dur;\n        this.stats.averageResponseTime =\n          this.stats.totalResponseTime / Math.max(1, this.stats.totalRequests);\n        this.stats.lastSuccessTime = Date.now();\n        return result;\n      } catch (err: unknown) {\n        this.stats.totalFailures++;\n        this.stats.lastFailureTime = Date.now();\n        throw err;\n      }\n    };\n\n    const fallback = async (error: unknown) => {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.warn(`[ProviderWrapper] 执行降级: ${opName}`, { error: err.message });\n      throw error; // 先不提供真正的降级实现\n    };\n\n    return await circuitBreakerService.execute(\n      opName,\n      doCall,\n      fallback,\n      this.config.circuitBreaker\n    );\n  }\n}\n\nclass ProviderWrapperService {\n  private providers = new Map<string, Provider>();\n  private wrappers = new Map<string, ProviderWrapper>();\n\n  private readonly defaultConfig: ProviderConfig = {\n    circuitBreaker: {\n      failureThreshold: 3,\n      resetTimeout: 30000,\n      monitoringPeriod: 10000,\n      halfOpenMaxCalls: 2,\n      successThreshold: 2\n    },\n    retry: { maxAttempts: 2, baseDelay: 1000, maxDelay: 10000, backoff: 'exponential' },\n    timeout: 30000,\n    cache: { ttl: 300, enabled: true }\n  };\n\n  registerProvider(name: string, provider: Provider, config: Partial<ProviderConfig> = {}) {\n    const fullConfig: ProviderConfig = {\n      ...this.defaultConfig,\n      ...config,\n      circuitBreaker: { ...this.defaultConfig.circuitBreaker, ...(config.circuitBreaker || {}) },\n      retry: { ...this.defaultConfig.retry, ...(config.retry || {}) },\n      cache: { ...this.defaultConfig.cache, ...(config.cache || {}) }\n    } as ProviderConfig;\n\n    const circuitBreaker = circuitBreakerService.getCircuitBreaker(\n      `provider_${name}`,\n      fullConfig.circuitBreaker\n    );\n    const wrapper = new ProviderWrapper(name, provider, fullConfig, circuitBreaker);\n    this.providers.set(name, provider);\n    this.wrappers.set(name, wrapper);\n    logger.info(`[ProviderWrapper] Provider注册成功: ${name}`);\n  }\n\n  getWrapper(name: string): ProviderWrapper | null {\n    return this.wrappers.get(name) || null;\n  }\n\n  getProvider(name: string): Provider | null {\n    return this.providers.get(name) || null;\n  }\n\n  async execute(\n    providerName: string,\n    methodName: string,\n    args: unknown[] = [],\n    options: ProviderExecuteOptions = {}\n  ): Promise<unknown> {\n    const wrapper = this.getWrapper(providerName);\n    if (!wrapper) throw new Error(`Provider不存在: ${providerName}`);\n    return await wrapper.execute(methodName, args, options);\n  }\n\n  getAllProviderStates(): Omit<HealthCheckResponse, 'status' | 'error'> & { providers: Record<string, unknown> } {\n    const states: Record<string, unknown> = {};\n    for (const [name, wrapper] of this.wrappers) {\n      states[name] = wrapper.getState();\n    }\n    return {\n      providers: states,\n      totalProviders: this.wrappers.size,\n      activeProviders: Array.from(this.wrappers.values()).filter(\n        (w) => w.circuitBreaker?.getState?.() !== 'open'\n      ).length,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  getProviderStats(providerName: string) {\n    return this.getWrapper(providerName)?.getStats() ?? null;\n  }\n\n  resetProviderStats(providerName: string) {\n    const wrapper = this.getWrapper(providerName);\n    if (!wrapper) return false;\n    wrapper.resetStats();\n    logger.info(`[ProviderWrapper] Provider统计已重置: ${providerName}`);\n    return true;\n  }\n\n  async healthCheck(): Promise<HealthCheckResponse> {\n    try {\n      const states = this.getAllProviderStates();\n      return {\n        status: states.activeProviders > 0 ? 'healthy' : 'degraded',\n        ...states\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[ProviderWrapper] 健康检查失败', err);\n      return { status: 'unhealthy', error: err.message, timestamp: new Date().toISOString() };\n    }\n  }\n}\n\nconst providerWrapperService = new ProviderWrapperService();\nexport default providerWrapperService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/providerHealth.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·?·0·:·(existing.consecutive_failures·as·number` with `⏎············?·0⏎············:·((existing.consecutive_failures·as·number)`","line":279,"column":42,"nodeType":null,"messageId":"replace","endLine":279,"endColumn":89,"fix":{"range":[7357,7404],"text":"\n            ? 0\n            : ((existing.consecutive_failures as number)"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * ProviderHealth Service - Provider健康监控服务 - TypeScript版本\n * 负责定期检查各Provider的健康状态并更新数据库\n */\n\nimport { db } from '../config/database.js';\nimport logger from '../utils/logger.js';\n\n/**\n * Provider配置\n */\nexport interface ProviderConfig {\n  provider_id: string;\n  provider_name: string;\n  type: string;\n  config: Record<string, unknown>;\n  is_enabled: boolean;\n  deleted_at: Date | null;\n}\n\n/**\n * Provider健康检查配置\n */\nexport interface ProviderHealthCheckConfig {\n  [key: string]: unknown;\n}\n\n/**\n * 更新健康记录数据\n */\nexport interface UpdateHealthRecordData {\n  is_healthy: boolean;\n  last_check_at: Date;\n  response_time_ms: number;\n  error_message: string | null;\n  consecutive_failures: number;\n  updated_at: Date;\n  last_recovery_at?: Date;\n}\n\n/**\n * 健康检查结果\n */\nexport interface HealthCheckResult {\n  isHealthy: boolean;\n  responseTime: number;\n}\n\n/**\n * 健康检查摘要\n */\nexport interface HealthSummary {\n  total: number;\n  success: number;\n  fail: number;\n}\n\n/**\n * 健康记录\n */\nexport interface HealthRecord {\n  provider_id: string;\n  provider_name: string;\n  type: string;\n  is_healthy: boolean;\n  last_check_at: Date;\n  response_time_ms: number;\n  consecutive_failures: number;\n  error_message: string | null;\n}\n\n/**\n * Provider健康服务类\n * 艹,这个service管理Provider的健康检查!\n */\nexport class ProviderHealthService {\n  /**\n   * 执行所有Provider的健康检查\n   * 艹,并发检查所有启用的Provider!\n   * @returns 健康检查摘要\n   */\n  async checkAllProviders(): Promise<HealthSummary | undefined> {\n    try {\n      logger.info('[ProviderHealthService] 开始健康检查');\n\n      // 1. 获取所有需要监控的Provider配置\n      const providers: ProviderConfig[] = await db('provider_configs')\n        .where('is_enabled', true)\n        .whereNull('deleted_at')\n        .select('*');\n\n      if (providers.length === 0) {\n        logger.info('[ProviderHealthService] 没有需要检查的Provider');\n        return;\n      }\n\n      logger.info(`[ProviderHealthService] 检查${providers.length}个Provider`);\n\n      // 2. 并发执行健康检查\n      const checkPromises = providers.map((provider) =>\n        this.checkProviderHealth(provider).catch((err: unknown) => {\n          const error = err instanceof Error ? err : new Error(String(err));\n          logger.error(\n            `[ProviderHealthService] Provider健康检查异常 ` +\n              `providerId=${provider.provider_id} error=${error.message}`\n          );\n          return null;\n        })\n      );\n\n      const results = await Promise.all(checkPromises);\n\n      // 3. 统计结果\n      const successCount = results.filter((r) => r && r.isHealthy).length;\n      const failCount = results.filter((r) => r && !r.isHealthy).length;\n\n      logger.info(\n        `[ProviderHealthService] 健康检查完成 ` +\n          `total=${providers.length} success=${successCount} fail=${failCount}`\n      );\n\n      return {\n        total: providers.length,\n        success: successCount,\n        fail: failCount\n      };\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] 健康检查失败: ${err.message}`, err);\n      throw err;\n    }\n  }\n\n  /**\n   * 检查单个Provider的健康状态\n   * 艹,根据type调用不同的健康检查逻辑!\n   * @param provider - Provider配置\n   * @returns 健康检查结果\n   */\n  async checkProviderHealth(provider: ProviderConfig): Promise<HealthCheckResult> {\n    const { provider_id, type, config } = provider;\n    const startTime = Date.now();\n\n    try {\n      let isHealthy = false;\n      let errorMessage: string | null = null;\n\n      // 根据type执行不同的健康检查\n      switch (type) {\n        case 'SYNC_IMAGE_PROCESS':\n          isHealthy = await this.checkSyncImageProcessHealth(config);\n          break;\n\n        case 'RUNNINGHUB_WORKFLOW':\n          isHealthy = await this.checkRunninghubHealth(config);\n          break;\n\n        case 'SCF_POST_PROCESS':\n          isHealthy = await this.checkScfHealth(config);\n          break;\n\n        default:\n          logger.warn(`[ProviderHealthService] 未知的Provider类型: ${type}`);\n          isHealthy = true; // 未知类型默认健康\n      }\n\n      const responseTime = Date.now() - startTime;\n\n      // 更新健康检查记录\n      await this.updateHealthRecord(provider_id, isHealthy, responseTime, errorMessage);\n\n      logger.info(\n        `[ProviderHealthService] Provider检查完成 ` +\n          `providerId=${provider_id} healthy=${isHealthy} responseTime=${responseTime}ms`\n      );\n\n      return { isHealthy, responseTime };\n    } catch (error: unknown) {\n      const responseTime = Date.now() - startTime;\n      const err = error instanceof Error ? error : new Error(String(error));\n\n      logger.error(\n        `[ProviderHealthService] Provider检查失败 ` +\n          `providerId=${provider_id} error=${err.message}`\n      );\n\n      // 更新为不健康状态\n      await this.updateHealthRecord(provider_id, false, responseTime, err.message);\n\n      return { isHealthy: false, responseTime };\n    }\n  }\n\n  /**\n   * 检查同步图片处理Provider健康状态\n   * 艹,TODO实现实际的健康检查逻辑!\n   * @param config - Provider配置\n   * @returns 是否健康\n   */\n  async checkSyncImageProcessHealth(config: ProviderHealthCheckConfig): Promise<boolean> {\n    try {\n      // TODO: 实现实际的健康检查逻辑\n      // 例如: ping腾讯云数据万象API\n      // 暂时返回true\n      logger.debug('[ProviderHealthService] 检查同步图片处理Provider (暂时返回健康)');\n      return true;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] 同步图片处理健康检查失败: ${err.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * 检查RunningHub工作流Provider健康状态\n   * 艹,TODO调用RunningHub的health endpoint!\n   * @param config - Provider配置\n   * @returns 是否健康\n   */\n  async checkRunninghubHealth(config: ProviderHealthCheckConfig): Promise<boolean> {\n    try {\n      // TODO: 实现实际的健康检查逻辑\n      // 例如: 调用RunningHub的health endpoint\n      logger.debug('[ProviderHealthService] 检查RunningHub Provider (暂时返回健康)');\n      return true;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] RunningHub健康检查失败: ${err.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * 检查SCF云函数Provider健康状态\n   * 艹,TODO调用云函数的health check接口!\n   * @param config - Provider配置\n   * @returns 是否健康\n   */\n  async checkScfHealth(config: ProviderHealthCheckConfig): Promise<boolean> {\n    try {\n      // TODO: 实现实际的健康检查逻辑\n      // 例如: 调用云函数的health check接口\n      logger.debug('[ProviderHealthService] 检查SCF Provider (暂时返回健康)');\n      return true;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] SCF健康检查失败: ${err.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * 更新Provider健康检查记录\n   * 艹,更新或插入健康检查记录到数据库!\n   * @param providerId - Provider ID\n   * @param isHealthy - 是否健康\n   * @param responseTime - 响应时间(ms)\n   * @param errorMessage - 错误信息\n   */\n  async updateHealthRecord(\n    providerId: string,\n    isHealthy: boolean,\n    responseTime: number,\n    errorMessage: string | null = null\n  ): Promise<void> {\n    try {\n      const now = new Date();\n\n      // 查询是否已存在记录\n      const existing = await db('provider_health_checks').where('provider_id', providerId).first();\n\n      if (existing) {\n        // 更新现有记录\n        const updateData: UpdateHealthRecordData = {\n          is_healthy: isHealthy,\n          last_check_at: now,\n          response_time_ms: responseTime,\n          error_message: errorMessage,\n          consecutive_failures: isHealthy ? 0 : (existing.consecutive_failures as number || 0) + 1,\n          updated_at: now\n        };\n\n        // 如果从不健康恢复为健康,记录恢复时间\n        if (isHealthy && !existing.is_healthy) {\n          updateData.last_recovery_at = now;\n        }\n\n        await db('provider_health_checks').where('provider_id', providerId).update(updateData);\n      } else {\n        // 创建新记录\n        await db('provider_health_checks').insert({\n          provider_id: providerId,\n          is_healthy: isHealthy,\n          last_check_at: now,\n          response_time_ms: responseTime,\n          error_message: errorMessage,\n          consecutive_failures: isHealthy ? 0 : 1,\n          created_at: now,\n          updated_at: now\n        });\n      }\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] 更新健康记录失败 providerId=${providerId}`, err);\n    }\n  }\n\n  /**\n   * 获取所有Provider的健康状态摘要\n   * 艹,查询所有Provider的健康状态!\n   * @returns 健康记录列表\n   */\n  async getHealthSummary(): Promise<HealthRecord[]> {\n    try {\n      const healthRecords = await db('provider_health_checks as phc')\n        .join('provider_configs as pc', 'phc.provider_id', 'pc.provider_id')\n        .where('pc.is_enabled', true)\n        .whereNull('pc.deleted_at')\n        .select(\n          'phc.provider_id',\n          'pc.provider_name',\n          'pc.type',\n          'phc.is_healthy',\n          'phc.last_check_at',\n          'phc.response_time_ms',\n          'phc.consecutive_failures',\n          'phc.error_message'\n        )\n        .orderBy('phc.last_check_at', 'desc');\n\n      return healthRecords;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] 获取健康摘要失败: ${err.message}`, err);\n      throw err;\n    }\n  }\n\n  /**\n   * 获取不健康的Provider列表\n   * 艹,找出所有挂掉的Provider!\n   * @returns 不健康Provider列表\n   */\n  async getUnhealthyProviders(): Promise<Partial<HealthRecord>[]> {\n    try {\n      const unhealthyProviders = await db('provider_health_checks as phc')\n        .join('provider_configs as pc', 'phc.provider_id', 'pc.provider_id')\n        .where('pc.is_enabled', true)\n        .whereNull('pc.deleted_at')\n        .where('phc.is_healthy', false)\n        .select(\n          'phc.provider_id',\n          'pc.provider_name',\n          'pc.type',\n          'phc.consecutive_failures',\n          'phc.last_check_at',\n          'phc.error_message'\n        )\n        .orderBy('phc.consecutive_failures', 'desc');\n\n      return unhealthyProviders;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`[ProviderHealthService] 获取不健康Provider失败: ${err.message}`, err);\n      throw err;\n    }\n  }\n}\n\n// 艹,单例导出!\nconst providerHealthService = new ProviderHealthService();\n\nexport default providerHealthService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/providers/runninghubWorkflow.provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/providers/scfPostProcess.provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/providers/syncImageProcess.provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/queue.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/quota.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/rbac.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/redis-lock.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/referral-validation.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/referral-validation.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const referralValidationService: {\n  validateReferrerQualification: (referrerId: string, qualificationType?: string) => Promise<any>;\n  validateReferralRelationship: (\n    referrerId: string,\n    refereeId: string,\n    referralData?: any\n  ) => Promise<any>;\n  createReferral: (data: any) => Promise<any>;\n};\nexport default referralValidationService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/referral-validation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/saga.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/security.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/swagger.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/swagger.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const swaggerService: {\n  getSpec: () => any;\n  getEndpoints: () => any[];\n  getEndpointsByTag: () => Record<string, any[]>;\n  getSchemas: () => any[];\n  validateDocs: () => any;\n  regenerateDocs: () => Promise<{ stats?: Record<string, any> }>;\n  getStats: () => Record<string, any>;\n  setAutoUpdate: (enabled: boolean) => void;\n};\n\nexport default swaggerService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/swagger.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎······`","line":180,"column":83,"nodeType":null,"messageId":"insert","endLine":180,"endColumn":83,"fix":{"range":[5163,5163],"text":"\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":181,"column":1,"nodeType":null,"messageId":"insert","endLine":181,"endColumn":1,"fix":{"range":[5185,5185],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":182,"column":7,"nodeType":null,"messageId":"insert","endLine":182,"endColumn":7,"fix":{"range":[5253,5253],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":183,"column":9,"nodeType":null,"messageId":"insert","endLine":183,"endColumn":9,"fix":{"range":[5270,5270],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":184,"column":1,"nodeType":null,"messageId":"replace","endLine":184,"endColumn":9,"fix":{"range":[5276,5284],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":185,"column":1,"nodeType":null,"messageId":"insert","endLine":185,"endColumn":1,"fix":{"range":[5292,5292],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":186,"column":1,"nodeType":null,"messageId":"insert","endLine":186,"endColumn":1,"fix":{"range":[5354,5354],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":187,"column":1,"nodeType":null,"messageId":"insert","endLine":187,"endColumn":1,"fix":{"range":[5433,5433],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `}` with `··}⏎····`","line":188,"column":5,"nodeType":null,"messageId":"replace","endLine":188,"endColumn":6,"fix":{"range":[5446,5447],"text":"  }\n    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Delete `⏎·······`","line":200,"column":53,"nodeType":null,"messageId":"delete","endLine":201,"endColumn":8,"fix":{"range":[5934,5942],"text":""}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":279,"column":29,"nodeType":null,"messageId":"insert","endLine":279,"endColumn":29,"fix":{"range":[9895,9895],"text":"\n     "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `componentSchemas·as·Record<string,·unknown>` with `⏎······componentSchemas·as·Record<string,·unknown>⏎····`","line":280,"column":543,"nodeType":null,"messageId":"replace","endLine":280,"endColumn":586,"fix":{"range":[10511,10554],"text":"\n      componentSchemas as Record<string, unknown>\n    "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·········`","line":293,"column":43,"nodeType":null,"messageId":"insert","endLine":293,"endColumn":43,"fix":{"range":[11074,11074],"text":"\n         "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":311,"column":1,"nodeType":null,"messageId":"insert","endLine":311,"endColumn":1,"fix":{"range":[11697,11697],"text":"  "}}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":14,"fixableWarningCount":0,"source":"import swaggerJsdoc from 'swagger-jsdoc';\nimport path from 'path';\nimport fs from 'fs';\nimport logger from '../utils/logger.js';\n\ntype AnyObject = Record<string, unknown>;\n\ninterface SwaggerConfig extends Record<string, unknown> {\n  definition: { info: { title: string; version: string } };\n  apis: string[];\n  outputFormats: string[];\n  generateDocs: boolean;\n  autoGenerate: boolean;\n  watchMode: boolean;\n  updateInterval: number;\n  lastUpdate: number;\n  updateTimer?: NodeJS.Timeout | null;\n}\n\ninterface SwaggerStats {\n  totalEndpoints: number;\n  totalSchemas: number;\n  generatedAt: Date | null;\n  lastUpdate: number | null;\n  updateCount: number;\n}\n\ninterface GenerateDocsResult {\n  success: boolean;\n  spec: AnyObject;\n  stats: SwaggerStats | Record<string, unknown>;\n  outputPath: string;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  spec?: AnyObject;\n}\n\ninterface SwaggerEndpoint {\n  path: string;\n  method: string;\n  operationId?: unknown;\n  summary?: unknown;\n  description?: unknown;\n  tags: unknown[];\n  parameters: unknown[];\n  responses: Record<string, unknown>;\n}\n\ninterface SchemaEntry {\n  name: string;\n  schema: unknown;\n  required: unknown[];\n  properties: Record<string, unknown>;\n}\n\nclass SwaggerService {\n  private initialized = false;\n  private swaggerConfig: AnyObject | null = null;\n  private generatedSpec: AnyObject | null = null;\n  private outputDir = path.join(\n    path.dirname(new URL(import.meta.url).pathname),\n    '../../docs/swagger'\n  );\n  private outputFile = path.join(this.outputDir, 'swagger.json');\n  private htmlFile = path.join(this.outputDir, 'index.html');\n\n  private config: SwaggerConfig = {\n    definition: {\n      info: { title: 'API文档', version: '1.0.0' }\n    },\n    apis: [\n      './src/routes/*.js',\n      './src/controllers/*.js',\n      './src/middlewares/*.js',\n      './src/services/*.js'\n    ],\n    outputFormats: ['json', 'html', 'yaml'],\n    generateDocs: true,\n    autoGenerate: process.env.NODE_ENV !== 'production',\n    watchMode: process.env.NODE_ENV === 'development',\n    updateInterval: 30000,\n    lastUpdate: 0\n  };\n\n  private stats: SwaggerStats = {\n    totalEndpoints: 0,\n    totalSchemas: 0,\n    generatedAt: null,\n    lastUpdate: null,\n    updateCount: 0\n  };\n\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      logger.warn('[Swagger] Swagger服务已初始化');\n      return;\n    }\n    try {\n      // 动态引入 TS 配置（.js 扩展保持 NodeNext 约束）\n\n      this.swaggerConfig = (await import('../config/swagger.config.js')).default ?? null;\n      await this.ensureOutputDirectory();\n      if (this.config.autoGenerate) await this.generateDocs();\n      if (this.config.watchMode) this.startAutoUpdate();\n      this.initialized = true;\n      logger.info('[Swagger] Swagger文档服务初始化成功');\n    } catch (error) {\n      logger.error('[Swagger] Swagger服务初始化失败:', error);\n      throw error;\n    }\n  }\n\n  async generateDocs(): Promise<GenerateDocsResult> {\n    try {\n      logger.info('[Swagger] 开始生成API文档...');\n      this.generatedSpec = swaggerJsdoc(this.config as Record<string, unknown>) as AnyObject;\n      this.updateStats();\n      if (this.config.generateDocs) await this.writeDocs();\n      this.stats.generatedAt = new Date();\n      this.stats.lastUpdate = Date.now();\n      this.stats.updateCount++;\n      logger.info(\n        `[Swagger] API文档生成完成: ${this.stats.totalEndpoints}个端点, ${this.stats.totalSchemas}个模型`\n      );\n      return {\n        success: true,\n        spec: this.generatedSpec,\n        stats: this.stats,\n        outputPath: this.outputDir\n      };\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[Swagger] 生成API文档失败:', error);\n      throw error;\n    }\n  }\n\n  getSpec(): AnyObject | null {\n    return this.generatedSpec || null;\n  }\n\n  getEndpoints(): SwaggerEndpoint[] {\n    if (!this.generatedSpec || !this.generatedSpec.paths) return [];\n    const endpoints: SwaggerEndpoint[] = [];\n    for (const [p, methods] of Object.entries(this.generatedSpec.paths)) {\n      for (const [method, spec] of Object.entries(methods as Record<string, unknown>)) {\n        const specRecord = spec as Record<string, unknown>;\n        endpoints.push({\n          path: p,\n          method: method.toUpperCase(),\n          operationId: specRecord.operationId,\n          summary: specRecord.summary,\n          description: specRecord.description,\n          tags: (specRecord.tags || []) as unknown[],\n          parameters: (specRecord.parameters || []) as unknown[],\n          responses: (specRecord.responses || {}) as Record<string, unknown>\n        });\n      }\n    }\n    return endpoints;\n  }\n\n  getEndpointsByTag(): Record<string, SwaggerEndpoint[]> {\n    const grouped: Record<string, SwaggerEndpoint[]> = {};\n    this.getEndpoints().forEach((e) => {\n      (e.tags as unknown[]).forEach((tag) => {\n        const tagStr = String(tag);\n        (grouped[tagStr] ||= []).push(e);\n      });\n    });\n    return grouped;\n  }\n\n  getSchemas(): SchemaEntry[] {\n    const spec = this.generatedSpec as Record<string, unknown>;\n    if (!spec?.components?.schemas) return [];\n    return Object.entries(spec.components.schemas as Record<string, unknown>).map(([name, schema]) => {\n      const schemaRecord = schema as Record<string, unknown>;\n      return {\n        name,\n        schema,\n        required: (schemaRecord.required || []) as unknown[],\n        properties: (schemaRecord.properties || {}) as Record<string, unknown>\n      };\n    });\n  }\n\n  validateDocs(): ValidationResult {\n    try {\n      const spec = this.getSpec();\n      if (!spec) return { valid: false, errors: ['未找到API规范'] };\n      const errors: string[] = [];\n      const specRecord = spec as Record<string, unknown>;\n      if (!specRecord.openapi) errors.push('缺少OpenAPI版本');\n      if (!specRecord.info) errors.push('缺少API信息');\n      const paths = specRecord.paths as Record<string, unknown> | undefined;\n      if (!paths || Object.keys(paths).length === 0)\n        errors.push('未定义API路径');\n      for (const [p, methods] of Object.entries(paths || {})) {\n        for (const [method, mSpec] of Object.entries(methods as Record<string, unknown>)) {\n          const mSpecRecord = mSpec as Record<string, unknown>;\n          if (!mSpecRecord.summary) errors.push(`${method.toUpperCase()} ${p} 缺少摘要`);\n          if (!mSpecRecord.responses) errors.push(`${method.toUpperCase()} ${p} 缺少响应定义`);\n        }\n      }\n      return { valid: errors.length === 0, errors, spec };\n    } catch (error) {\n      const err = error as Error;\n      logger.error('[Swagger] 验证API文档失败:', error);\n      return { valid: false, errors: [`验证过程出错: ${err.message}`] };\n    }\n  }\n\n  getStats(): Record<string, unknown> {\n    return {\n      ...this.stats,\n      outputDir: this.outputDir,\n      outputFile: this.outputFile,\n      htmlFile: this.htmlFile,\n      autoGenerate: this.config.autoGenerate,\n      watchMode: this.config.watchMode,\n      lastChecked: new Date().toISOString()\n    };\n  }\n\n  async regenerateDocs(): Promise<GenerateDocsResult> {\n    logger.info('[Swagger] 手动重新生成API文档');\n    return await this.generateDocs();\n  }\n\n  setAutoUpdate(enabled: boolean): void {\n    this.config.watchMode = enabled;\n    if (enabled && !this.config.updateTimer) this.startAutoUpdate();\n    else if (!enabled && this.config.updateTimer) {\n      clearInterval(this.config.updateTimer);\n      this.config.updateTimer = null;\n    }\n    logger.info(`[Swagger] 自动更新已${enabled ? '启用' : '禁用'}`);\n  }\n\n  private async ensureOutputDirectory(): Promise<void> {\n    if (!fs.existsSync(this.outputDir)) {\n      fs.mkdirSync(this.outputDir, { recursive: true });\n      logger.info(`[Swagger] 创建输出目录: ${this.outputDir}`);\n    }\n  }\n\n  private async writeDocs(): Promise<void> {\n    fs.writeFileSync(this.outputFile, JSON.stringify(this.generatedSpec, null, 2));\n    if (this.config.outputFormats.includes('html')) await this.generateHtmlDoc();\n    if (this.config.outputFormats.includes('yaml')) await this.generateYamlDoc();\n    logger.debug(`[Swagger] 文档写入完成: ${this.outputDir}`);\n  }\n\n  private async generateHtmlDoc(): Promise<void> {\n    const spec = this.generatedSpec as Record<string, unknown>;\n    const specInfo = spec.info as Record<string, unknown>;\n    const generatedAtDate = this.stats.generatedAt || new Date();\n    const htmlTemplate = `<!DOCTYPE html><html lang=\"zh-CN\"><head><meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><title>${specInfo.title} - API文档</title><link rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css\"></head><body><div class=\"header\"><h1>${specInfo.title}</h1><p>${specInfo.description ?? ''}</p><div class=\"stats\"><strong>文档统计:</strong> 端点数量: ${this.stats.totalEndpoints} | 模型数量: ${this.stats.totalSchemas} | 生成时间: ${new Date(generatedAtDate).toLocaleString()}</div></div><div id=\"swagger-ui\"></div><div class=\"footer\"><p>API文档生成时间: ${new Date().toLocaleString()}</p><p> powered by Swagger</p></div><script src=\"https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js\"></script><script src=\"https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js\"></script><script>window.onload=function(){SwaggerUIBundle({url:'./swagger.json',dom_id:'#swagger-ui',deepLinking:true,presets:[SwaggerUIBundle.presets.apis,SwaggerUIStandalonePreset],plugins:[SwaggerUIBundle.plugins.DownloadUrl]});}</script></body></html>`;\n    fs.writeFileSync(this.htmlFile, htmlTemplate);\n  }\n\n  private async generateYamlDoc(): Promise<void> {\n    const spec = this.generatedSpec as Record<string, unknown>;\n    interface ServerEntry {\n      url: string;\n      description: string;\n    }\n    interface TagEntry {\n      name: string;\n      description: string;\n    }\n    const servers = (spec.servers || []) as ServerEntry[];\n    const tags = (spec.tags || []) as TagEntry[];\n    const specInfo = spec.info as Record<string, unknown>;\n    const componentSchemas = (spec.components as Record<string, unknown> | undefined)?.schemas ?? {};\n    const yamlContent = `openapi: 3.0.0\\ninfo:\\n  title: ${specInfo.title}\\n  version: ${specInfo.version}\\n  description: ${specInfo.description}\\nservers:\\n${servers.map((s) => `  - url: ${s.url}\\n    description: ${s.description}`).join('\\n')}\\n\\ntags:\\n${tags.map((t) => `  - name: ${t.name}\\n    description: ${t.description}`).join('\\n')}\\n\\npaths:\\n${JSON.stringify(spec.paths, null, 2)}\\n\\ncomponents:\\n  securitySchemes:\\n    bearerAuth:\\n      type: http\\n      scheme: bearer\\n      bearerFormat: JWT\\n  schemas:\\n${Object.entries(componentSchemas as Record<string, unknown>)\n      .map(([name, schema]) => `    ${name}:\\n${JSON.stringify(schema, null, 4)}`)\n      .join('\\n')}\\n`;\n    const yamlFile = this.outputFile.replace('.json', '.yaml');\n    fs.writeFileSync(yamlFile, yamlContent);\n  }\n\n  private updateStats(): void {\n    const spec = this.generatedSpec as Record<string, unknown>;\n    let endpointCount = 0;\n    if (spec?.paths) {\n      const paths = spec.paths as Record<string, unknown>;\n      endpointCount = Object.values(paths).reduce(\n        (acc: number, methods: unknown) => acc + Object.keys(methods as Record<string, unknown>).length,\n        0\n      );\n    }\n    this.stats.totalEndpoints = endpointCount;\n    const components = spec?.components as Record<string, unknown> | undefined;\n    const schemas = components?.schemas as Record<string, unknown> | undefined;\n    this.stats.totalSchemas = schemas ? Object.keys(schemas).length : 0;\n  }\n\n  private startAutoUpdate(): void {\n    if (this.config.updateTimer) {\n      clearInterval(this.config.updateTimer);\n    }\n    this.config.updateTimer = setInterval(async () => {\n      try {\n        await this.generateDocs();\n      } catch (error) {\n      const err = error as Error;\n        logger.error('[Swagger] 自动更新文档失败:', error);\n      }\n    }, this.config.updateInterval);\n    logger.info(`[Swagger] 自动更新已启动，间隔: ${this.config.updateInterval}ms`);\n  }\n\n  private stopAutoUpdate(): void {\n    if (this.config.updateTimer) {\n      clearInterval(this.config.updateTimer);\n      this.config.updateTimer = null;\n      logger.info('[Swagger] 自动更新已停止');\n    }\n  }\n\n  async close(): Promise<void> {\n    this.stopAutoUpdate();\n    this.initialized = false;\n    logger.info('[Swagger] Swagger服务已关闭');\n  }\n}\n\nexport default new SwaggerService();\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/systemConfig.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/task-progress.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/task.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/task.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const taskService: {\n  createByFeature: (userId: string, featureId: string, inputData: any) => Promise<any>;\n  create: (userId: string, type: string, inputImageUrl: string, params?: any) => Promise<any>;\n  get: (taskId: string) => Promise<any>;\n  list: (userId: string, query: any) => Promise<any>;\n  updateStatus: (taskId: string, status: string, payload: any) => Promise<void>;\n};\nexport default taskService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/task.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13212,13215],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13212,13215],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/token.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/ui-schema.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·type:·'string',·title:·'分类',·enum:·['image',·'video',·'text']` with `⏎············type:·'string',⏎············title:·'分类',⏎············enum:·['image',·'video',·'text']⏎·········`","line":428,"column":22,"nodeType":null,"messageId":"replace","endLine":428,"endColumn":84,"fix":{"range":[11184,11246],"text":"\n            type: 'string',\n            title: '分类',\n            enum: ['image', 'video', 'text']\n         "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"const configCacheService = require('../cache/config-cache');\nimport { db as knex } from '../db/index.js';\nconst logger = require('../utils/logger');\nconst { hasPermission, getRolePermissions } = require('../utils/rbac');\n\ninterface MenuConfig {\n  id: string;\n  key: string;\n  title: string;\n  icon?: string;\n  path?: string;\n  children?: MenuConfig[];\n  permissions?: string[];\n  visible?: boolean;\n  order?: number;\n  badge?: {\n    count: number;\n    color: string;\n  };\n}\n\ninterface PropertySchema {\n  type: string;\n  title: string;\n  [key: string]: unknown;\n}\n\ninterface FormSchema {\n  type: string;\n  title: string;\n  properties: Record<string, PropertySchema>;\n  required?: string[];\n  uiSchema?: Record<string, unknown>;\n}\n\ninterface FilterOption {\n  text: string;\n  value: string | number | boolean;\n}\n\ninterface TableColumn {\n  key: string;\n  title: string;\n  dataIndex: string;\n  width?: number;\n  fixed?: 'left' | 'right';\n  sorter?: boolean;\n  filters?: FilterOption[];\n  render?: string; // 渲染函数名\n}\n\ninterface TableAction {\n  key: string;\n  title: string;\n  icon?: string;\n  permission?: string;\n  danger?: boolean;\n}\n\ninterface TableSchema {\n  columns: TableColumn[];\n  actions?: TableAction[];\n}\n\ninterface UISchema {\n  menus: MenuConfig[];\n  forms: Record<string, FormSchema>;\n  tables: Record<string, TableSchema>;\n  permissions: Record<string, string[]>;\n  version: string;\n  timestamp: number;\n}\n\n/**\n * UI Schema服务 - 后端驱动前端界面\n *\n * 提供动态菜单、表单模板、页面配置等UI元素\n * 支持按角色权限过滤，发布后实时生效\n */\nclass UISchemaService {\n  private readonly CACHE_SCOPE = 'ui_schema';\n  private readonly DEFAULT_VERSION = '1.0.0';\n\n  /**\n   * 获取用户菜单配置\n   */\n  async getMenus(userRole: string = 'viewer'): Promise<MenuConfig[]> {\n    try {\n      const cacheKey = `menus:${userRole}`;\n\n      const menus = await configCacheService.getOrSet(\n        {\n          scope: this.CACHE_SCOPE,\n          key: cacheKey,\n          version: this.DEFAULT_VERSION\n        },\n        () => this.generateMenusFromDB(userRole)\n      );\n\n      return this.filterMenusByPermission(menus, userRole);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('获取菜单配置失败:', err);\n      return this.getDefaultMenus(userRole);\n    }\n  }\n\n  /**\n   * 获取UI Schema配置\n   */\n  async getUISchema(userRole: string = 'viewer'): Promise<UISchema> {\n    try {\n      const cacheKey = `ui_schema:${userRole}`;\n\n      const schema = await configCacheService.getOrSet(\n        {\n          scope: this.CACHE_SCOPE,\n          key: cacheKey,\n          version: this.DEFAULT_VERSION\n        },\n        () => this.generateUISchemaFromDB(userRole)\n      );\n\n      return this.filterSchemaByPermission(schema, userRole);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('获取UI Schema失败:', err);\n      return this.getDefaultUISchema(userRole);\n    }\n  }\n\n  /**\n   * 获取表单Schema\n   */\n  async getFormSchema(formKey: string, userRole: string = 'viewer'): Promise<FormSchema | null> {\n    try {\n      const cacheKey = `form:${formKey}:${userRole}`;\n\n      return await configCacheService.getOrSet(\n        {\n          scope: this.CACHE_SCOPE,\n          key: cacheKey,\n          version: this.DEFAULT_VERSION\n        },\n        () => this.generateFormSchemaFromDB(formKey, userRole)\n      );\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`获取表单Schema失败: ${formKey}`, err);\n      return null;\n    }\n  }\n\n  /**\n   * 获取表格Schema\n   */\n  async getTableSchema(tableKey: string, userRole: string = 'viewer'): Promise<TableSchema | null> {\n    try {\n      const cacheKey = `table:${tableKey}:${userRole}`;\n\n      return await configCacheService.getOrSet(\n        {\n          scope: this.CACHE_SCOPE,\n          key: cacheKey,\n          version: this.DEFAULT_VERSION\n        },\n        () => this.generateTableSchemaFromDB(tableKey, userRole)\n      );\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`获取表格Schema失败: ${tableKey}`, err);\n      return null;\n    }\n  }\n\n  /**\n   * 获取单个功能的完整UI配置\n   */\n  async getFeatureUiConfig(\n    featureKey: string,\n    userRole: string = 'viewer'\n  ): Promise<{\n    form: FormSchema | null;\n    table: TableSchema | null;\n    permissions: string[];\n  }> {\n    const schema = await this.getUISchema(userRole);\n    return {\n      form: schema.forms?.[featureKey] ?? null,\n      table: schema.tables?.[featureKey] ?? null,\n      permissions: schema.permissions?.[featureKey] ?? []\n    };\n  }\n\n  /**\n   * 更新菜单配置\n   */\n  async updateMenus(menus: MenuConfig[], updatedBy: string): Promise<void> {\n    try {\n      const menusJson = JSON.stringify(menus);\n\n      await knex('ui_configs')\n        .insert({\n          config_key: 'menus',\n          config_value: menusJson,\n          version: this.DEFAULT_VERSION,\n          updated_by: updatedBy\n        })\n        .onConflict('config_key')\n        .merge({\n          config_value: menusJson,\n          version: this.DEFAULT_VERSION,\n          updated_by: updatedBy,\n          updated_at: new Date()\n        });\n\n      // 失效缓存\n      await this.invalidateCache('menus');\n\n      logger.info('菜单配置已更新', { updatedBy });\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('更新菜单配置失败:', err);\n      throw err;\n    }\n  }\n\n  /**\n   * 更新表单Schema\n   */\n  async updateFormSchema(formKey: string, schema: FormSchema, updatedBy: string): Promise<void> {\n    try {\n      const schemaJson = JSON.stringify(schema);\n\n      await knex('ui_configs')\n        .insert({\n          config_key: `form:${formKey}`,\n          config_value: schemaJson,\n          version: this.DEFAULT_VERSION,\n          updated_by: updatedBy\n        })\n        .onConflict('config_key')\n        .merge({\n          config_value: schemaJson,\n          version: this.DEFAULT_VERSION,\n          updated_by: updatedBy,\n          updated_at: new Date()\n        });\n\n      // 失效缓存\n      await this.invalidateCache(`form:${formKey}`);\n\n      logger.info(`表单Schema已更新: ${formKey}`, { updatedBy });\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`更新表单Schema失败: ${formKey}`, err);\n      throw err;\n    }\n  }\n\n  async invalidateAllCaches(): Promise<void> {\n    await configCacheService.invalidate(this.CACHE_SCOPE);\n  }\n\n  /**\n   * 从数据库生成菜单配置\n   */\n  private async generateMenusFromDB(userRole: string): Promise<MenuConfig[]> {\n    // 从features表生成功能菜单\n    const features = await knex('features')\n      .where('enabled', true)\n      .where('status', 'published')\n      .orderBy('menu_path', 'asc');\n\n    const menuMap = new Map<string, MenuConfig>();\n\n    features.forEach((feature) => {\n      const menuPath = feature.menu_path || `/admin/${feature.key}`;\n      const pathParts = menuPath.split('/').filter((p: string) => p);\n\n      let currentPath = '';\n      let parentMenu: MenuConfig | null = null;\n\n      pathParts.forEach((part: string, index: number) => {\n        currentPath += `/${part}`;\n\n        if (!menuMap.has(currentPath)) {\n          const isFeature = index === pathParts.length - 1;\n\n          const menu: MenuConfig = {\n            id: isFeature ? feature.id : `menu_${currentPath}`,\n            key: isFeature ? feature.key : part,\n            title: isFeature ? feature.name : this.formatMenuTitle(part),\n            icon: isFeature ? feature.icon : this.getDefaultIcon(part),\n            path: isFeature ? currentPath : undefined,\n            children: isFeature ? undefined : [],\n            permissions: isFeature ? [`${feature.key}:read`] : [`${part}:read`],\n            visible: true,\n            order: index\n          };\n\n          menuMap.set(currentPath, menu);\n\n          if (parentMenu && parentMenu.children) {\n            parentMenu.children.push(menu);\n          }\n        }\n\n        parentMenu = menuMap.get(currentPath)!;\n      });\n    });\n\n    return Array.from(menuMap.values()).filter((menu) => !menu.path);\n  }\n\n  /**\n   * 从数据库生成完整UI Schema\n   */\n  private async generateUISchemaFromDB(userRole: string): Promise<UISchema> {\n    const [menus, forms, tables] = await Promise.all([\n      this.generateMenusFromDB(userRole),\n      this.generateAllFormSchemas(userRole),\n      this.generateAllTableSchemas(userRole)\n    ]);\n\n    return {\n      menus,\n      forms,\n      tables,\n      permissions: this.getAllPermissions(userRole),\n      version: this.DEFAULT_VERSION,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * 从数据库生成表单Schema\n   */\n  private async generateFormSchemaFromDB(\n    formKey: string,\n    userRole: string\n  ): Promise<FormSchema | null> {\n    try {\n      const config = await knex('ui_configs').where('config_key', `form:${formKey}`).first();\n\n      if (config) {\n        return JSON.parse(config.config_value);\n      }\n\n      // 如果没有配置，根据功能生成默认表单\n      return this.generateDefaultFormSchema(formKey, userRole);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`生成表单Schema失败: ${formKey}`, err);\n      return null;\n    }\n  }\n\n  /**\n   * 从数据库生成表格Schema\n   */\n  private async generateTableSchemaFromDB(\n    tableKey: string,\n    userRole: string\n  ): Promise<TableSchema | null> {\n    try {\n      const config = await knex('ui_configs').where('config_key', `table:${tableKey}`).first();\n\n      if (config) {\n        return JSON.parse(config.config_value);\n      }\n\n      // 如果没有配置，生成默认表格配置\n      return this.generateDefaultTableSchema(tableKey, userRole);\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error(`生成表格Schema失败: ${tableKey}`, err);\n      return null;\n    }\n  }\n\n  /**\n   * 生成所有表单Schema\n   */\n  private async generateAllFormSchemas(userRole: string): Promise<Record<string, FormSchema>> {\n    const forms: Record<string, FormSchema> = {};\n\n    // 为每个启用的功能生成表单Schema\n    const features = await knex('features').where('enabled', true).where('status', 'published');\n\n    for (const feature of features) {\n      const formSchema = await this.generateDefaultFormSchema(feature.key, userRole);\n      if (formSchema) {\n        forms[feature.key] = formSchema;\n      }\n    }\n\n    return forms;\n  }\n\n  /**\n   * 生成所有表格Schema\n   */\n  private async generateAllTableSchemas(userRole: string): Promise<Record<string, TableSchema>> {\n    const tables: Record<string, TableSchema> = {};\n\n    // 生成各类管理表格Schema\n    const tableTypes = ['features', 'providers', 'mcp', 'pipelines', 'prompts'];\n\n    for (const type of tableTypes) {\n      tables[type] = this.generateDefaultTableSchema(type, userRole);\n    }\n\n    return tables;\n  }\n\n  /**\n   * 生成默认表单Schema\n   */\n  private generateDefaultFormSchema(featureKey: string, userRole: string): FormSchema | null {\n    const schemaMap: Record<string, FormSchema> = {\n      features: {\n        type: 'object',\n        title: '功能配置',\n        properties: {\n          name: { type: 'string', title: '功能名称' } as PropertySchema,\n          description: { type: 'string', title: '描述' } as PropertySchema,\n          category: { type: 'string', title: '分类', enum: ['image', 'video', 'text'] } as PropertySchema,\n          quota_cost: { type: 'number', title: '配额消耗' } as PropertySchema,\n          enabled: { type: 'boolean', title: '启用' } as PropertySchema\n        },\n        required: ['name', 'category']\n      },\n      providers: {\n        type: 'object',\n        title: '供应商配置',\n        properties: {\n          name: { type: 'string', title: '供应商名称' } as PropertySchema,\n          type: { type: 'string', title: '类型' } as PropertySchema,\n          base_url: { type: 'string', title: '基础URL', format: 'uri' } as PropertySchema,\n          timeout_ms: { type: 'number', title: '超时时间' } as PropertySchema,\n          enabled: { type: 'boolean', title: '启用' } as PropertySchema\n        },\n        required: ['name', 'type', 'base_url']\n      }\n    };\n\n    return schemaMap[featureKey] || null;\n  }\n\n  /**\n   * 生成默认表格Schema\n   */\n  private generateDefaultTableSchema(tableKey: string, userRole: string): TableSchema {\n    const schemaMap: Record<string, TableSchema> = {\n      features: {\n        columns: [\n          { key: 'id', title: 'ID', dataIndex: 'id', width: 80 },\n          { key: 'name', title: '功能名称', dataIndex: 'name', sorter: true },\n          {\n            key: 'category',\n            title: '分类',\n            dataIndex: 'category',\n            filters: [\n              { text: '图像处理', value: 'image' },\n              { text: '视频处理', value: 'video' },\n              { text: '文本处理', value: 'text' }\n            ]\n          },\n          { key: 'quota_cost', title: '配额消耗', dataIndex: 'quota_cost', width: 100 },\n          { key: 'enabled', title: '状态', dataIndex: 'enabled', width: 80, render: 'statusBadge' },\n          { key: 'actions', title: '操作', dataIndex: 'actions', width: 200, fixed: 'right' }\n        ],\n        actions: [\n          { key: 'edit', title: '编辑', icon: 'edit', permission: 'features:update' },\n          {\n            key: 'delete',\n            title: '删除',\n            icon: 'delete',\n            permission: 'features:delete',\n            danger: true\n          }\n        ]\n      },\n      providers: {\n        columns: [\n          { key: 'id', title: 'ID', dataIndex: 'id', width: 80 },\n          { key: 'name', title: '供应商名称', dataIndex: 'name', sorter: true },\n          { key: 'type', title: '类型', dataIndex: 'type' },\n          { key: 'base_url', title: '基础URL', dataIndex: 'base_url' },\n          {\n            key: 'healthy',\n            title: '健康状态',\n            dataIndex: 'healthy',\n            width: 100,\n            render: 'healthBadge'\n          },\n          { key: 'actions', title: '操作', dataIndex: 'actions', width: 200, fixed: 'right' }\n        ],\n        actions: [\n          { key: 'test', title: '测试', icon: 'api', permission: 'providers:test' },\n          { key: 'edit', title: '编辑', icon: 'edit', permission: 'providers:update' }\n        ]\n      }\n    };\n\n    return (\n      schemaMap[tableKey] || {\n        columns: [\n          { key: 'id', title: 'ID', dataIndex: 'id', width: 80 },\n          { key: 'name', title: '名称', dataIndex: 'name', sorter: true },\n          { key: 'actions', title: '操作', dataIndex: 'actions', width: 150, fixed: 'right' }\n        ]\n      }\n    );\n  }\n\n  /**\n   * 按权限过滤菜单\n   */\n  filterMenusByPermission(menus: MenuConfig[], userRole: string): MenuConfig[] {\n    return menus\n      .filter((menu) => this.hasMenuPermission(menu, userRole))\n      .map((menu) => ({\n        ...menu,\n        children: menu.children ? this.filterMenusByPermission(menu.children, userRole) : undefined\n      }))\n      .filter(\n        (menu) =>\n          menu.children?.length || !menu.permissions || this.hasMenuPermission(menu, userRole)\n      );\n  }\n\n  /**\n   * 按权限过滤Schema\n   */\n  private filterSchemaByPermission(schema: UISchema, userRole: string): UISchema {\n    return {\n      ...schema,\n      menus: this.filterMenusByPermission(schema.menus, userRole)\n    };\n  }\n\n  /**\n   * 检查菜单权限\n   */\n  private hasMenuPermission(menu: MenuConfig, userRole: string): boolean {\n    if (!menu.permissions || menu.permissions.length === 0) {\n      return true;\n    }\n\n    return menu.permissions.some((permission) => {\n      const [resource, action] = permission.split(':');\n      return hasPermission(userRole, resource, action);\n    });\n  }\n\n  /**\n   * 获取所有权限\n   */\n  private getAllPermissions(userRole: string): Record<string, string[]> {\n    return getRolePermissions(userRole);\n  }\n\n  /**\n   * 格式化菜单标题\n   */\n  private formatMenuTitle(part: string): string {\n    return part.charAt(0).toUpperCase() + part.slice(1).replace(/[-_]/g, ' ');\n  }\n\n  /**\n   * 获取默认图标\n   */\n  private getDefaultIcon(part: string): string {\n    const iconMap: Record<string, string> = {\n      admin: 'setting',\n      features: 'appstore',\n      providers: 'cloud',\n      mcp: 'api',\n      pipelines: 'share-alt',\n      prompts: 'edit',\n      system: 'monitor'\n    };\n\n    return iconMap[part] || 'folder';\n  }\n\n  /**\n   * 获取默认菜单\n   */\n  private getDefaultMenus(userRole: string): MenuConfig[] {\n    const baseMenus: MenuConfig[] = [\n      {\n        id: 'dashboard',\n        key: 'dashboard',\n        title: '仪表盘',\n        icon: 'dashboard',\n        path: '/admin/dashboard',\n        permissions: ['system:read']\n      }\n    ];\n\n    if (userRole === 'admin') {\n      baseMenus.push({\n        id: 'system',\n        key: 'system',\n        title: '系统管理',\n        icon: 'setting',\n        children: [\n          {\n            id: 'features',\n            key: 'features',\n            title: '功能管理',\n            path: '/admin/features',\n            permissions: ['features:read']\n          },\n          {\n            id: 'providers',\n            key: 'providers',\n            title: '供应商管理',\n            path: '/admin/providers',\n            permissions: ['providers:read']\n          }\n        ]\n      });\n    }\n\n    return baseMenus;\n  }\n\n  /**\n   * 获取默认UI Schema\n   */\n  private getDefaultUISchema(userRole: string): UISchema {\n    return {\n      menus: this.getDefaultMenus(userRole),\n      forms: {},\n      tables: {},\n      permissions: this.getAllPermissions(userRole),\n      version: this.DEFAULT_VERSION,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * 失效缓存\n   */\n  private async invalidateCache(key: string): Promise<void> {\n    await configCacheService.invalidate(this.CACHE_SCOPE, key);\n  }\n}\n\nconst uiSchemaService = new UISchemaService();\n\n// 导出类实例的所有public方法\nexport const getMenus = uiSchemaService.getMenus.bind(uiSchemaService);\nexport const getUISchema = uiSchemaService.getUISchema.bind(uiSchemaService);\nexport const getFormSchema = uiSchemaService.getFormSchema.bind(uiSchemaService);\nexport const getTableSchema = uiSchemaService.getTableSchema.bind(uiSchemaService);\nexport const getFeatureUiConfig = uiSchemaService.getFeatureUiConfig.bind(uiSchemaService);\nexport const updateMenus = uiSchemaService.updateMenus.bind(uiSchemaService);\nexport const updateFormSchema = uiSchemaService.updateFormSchema.bind(uiSchemaService);\nexport const filterMenusByPermission =\n  uiSchemaService.filterMenusByPermission.bind(uiSchemaService);\nexport const invalidateAllCaches = uiSchemaService.invalidateAllCaches.bind(uiSchemaService);\n\nexport default uiSchemaService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/unified-login.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/user-profile.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/user-profile.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const userProfileService: Record<string, any>;\nexport default userProfileService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/user-profile.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/videoGenerate.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/videoGenerate.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const videoGenerateService: {\n  processVideoTask: (\n    taskId: string,\n    imageUrl: string,\n    params?: any\n  ) => Promise<{ vendorTaskId: string; status: string }>;\n  pollVideoStatus: (vendorTaskId: string) => Promise<{\n    status: 'success' | 'failed' | 'pending' | 'processing';\n    videoUrl?: string;\n    errorMessage?: string;\n  }>;\n  isTimeout: (createdAt: Date) => boolean;\n  getErrorMessage: (errorType: string) => string;\n};\nexport default videoGenerateService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/videoGenerate.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/videoPolling.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/websocket.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/wechat-login.service.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/services/wechat-login.service.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type WechatOAuthUrlResult = {\n  authUrl: string;\n  state: string;\n};\n\nexport type WechatLoginResult = Record<string, unknown>;\n\ndeclare const wechatLoginService: {\n  generateOfficialOAuthUrl(\n    redirectUri: string,\n    scope?: string,\n    state?: string | null\n  ): WechatOAuthUrlResult;\n  handleOfficialOAuthCallback(code: string, state: string): Promise<WechatLoginResult>;\n  handleMiniProgramLogin(\n    code: string,\n    userInfo?: Record<string, unknown>\n  ): Promise<WechatLoginResult>;\n  generateOpenPlatformOAuthUrl(redirectUri: string, state?: string | null): WechatOAuthUrlResult;\n  handleOpenPlatformCallback(code: string, state: string): Promise<WechatLoginResult>;\n  getUserWechatBindings(userId: string): Promise<Record<string, unknown>>;\n  unbindWechat(userId: string): Promise<boolean>;\n  getStats(): Record<string, unknown>;\n};\n\nexport default wechatLoginService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/services/wechat-login.service.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎····redirectUri:·string,⏎····state:·string·|·null·=·null⏎··` with `redirectUri:·string,·state:·string·|·null·=·null`","line":255,"column":32,"nodeType":null,"messageId":"replace","endLine":258,"endColumn":3,"fix":{"range":[6483,6543],"text":"redirectUri: string, state: string | null = null"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········`微信API错误:·${response.data.errcode}·-·${response.data.errmsg}`⏎········` with ``微信API错误:·${response.data.errcode}·-·${response.data.errmsg}``","line":595,"column":25,"nodeType":null,"messageId":"replace","endLine":597,"endColumn":9,"fix":{"range":[15960,16041],"text":"`微信API错误: ${response.data.errcode} - ${response.data.errmsg}`"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········`微信API错误:·${response.data.errcode}·-·${response.data.errmsg}`⏎········` with ``微信API错误:·${response.data.errcode}·-·${response.data.errmsg}``","line":662,"column":25,"nodeType":null,"messageId":"replace","endLine":664,"endColumn":9,"fix":{"range":[17856,17937],"text":"`微信API错误: ${response.data.errcode} - ${response.data.errmsg}`"}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `⏎··········`微信API错误:·${response.data.errcode}·-·${response.data.errmsg}`⏎········` with ``微信API错误:·${response.data.errcode}·-·${response.data.errmsg}``","line":696,"column":25,"nodeType":null,"messageId":"replace","endLine":698,"endColumn":9,"fix":{"range":[18789,18870],"text":"`微信API错误: ${response.data.errcode} - ${response.data.errmsg}`"}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎······`","line":857,"column":17,"nodeType":null,"messageId":"insert","endLine":857,"endColumn":17,"fix":{"range":[22746,22746],"text":"\n      "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":858,"column":1,"nodeType":null,"messageId":"insert","endLine":858,"endColumn":1,"fix":{"range":[22760,22760],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `····},·30·*·60·*·1000` with `······},⏎······30·*·60·*·1000⏎····`","line":859,"column":1,"nodeType":null,"messageId":"replace","endLine":859,"endColumn":22,"fix":{"range":[22793,22814],"text":"      },\n      30 * 60 * 1000\n    "}}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":7,"fixableWarningCount":0,"source":"import axios from 'axios';\nimport crypto from 'crypto';\nimport { v4 as uuidv4 } from 'uuid';\nimport NodeCache from 'node-cache';\nimport logger from '../utils/logger.js';\nimport { db } from '../config/database.js';\nimport wechatConfig from '../config/wechat.config.js';\nimport cacheService from './cache.service.js';\nimport tokenService from './token.service.js';\nimport type {\n  WechatLoginPlatform,\n  WechatUserInfo,\n  OAuthCallbackResult,\n  TokenData,\n  UserLoginData,\n  MiniProgramLoginResult,\n  TokenPair,\n  WechatBindings,\n  AuthUrlResult,\n  ProcessLoginResult,\n  SessionCacheData,\n  LoginStats,\n  StateData\n} from '../types/wechat-login.types.js';\n\n/**\n * 微信登录服务类\n *\n * 支持多种微信登录方式：\n * - 微信公众号OAuth登录\n * - 微信小程序登录\n * - 微信开放平台扫码登录\n * - 微信用户信息获取\n * - 统一用户身份绑定\n */\nclass WechatLoginService {\n  private initialized: boolean;\n\n  private accessTokenCache: NodeCache;\n\n  private jsapiTicketCache: NodeCache;\n\n  private sessionStore: NodeCache;\n\n  private stats: LoginStats;\n\n  constructor() {\n    this.initialized = false;\n\n    // 缓存实例\n    this.accessTokenCache = new NodeCache({ stdTTL: wechatConfig.common.cache.accessTokenTTL });\n    this.jsapiTicketCache = new NodeCache({ stdTTL: wechatConfig.common.cache.jsapiTicketTTL });\n\n    // 会话存储\n    this.sessionStore = new NodeCache({ stdTTL: wechatConfig.common.cache.sessionTTL });\n\n    // 统计信息\n    this.stats = {\n      totalLogins: 0,\n      successfulLogins: 0,\n      failedLogins: 0,\n      newUsers: 0,\n      existingUsers: 0,\n      lastReset: Date.now()\n    };\n  }\n\n  /**\n   * 初始化微信登录服务\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      logger.warn('[WechatLogin] 微信登录服务已初始化');\n      return;\n    }\n\n    try {\n      // 验证配置\n      const platforms: WechatLoginPlatform[] = ['officialAccount', 'miniProgram', 'openPlatform'];\n      for (const platform of platforms) {\n        try {\n          wechatConfig.validateConfig(platform);\n          logger.info(`[WechatLogin] ${platform} 配置验证成功`);\n        } catch (error: unknown) {\n          const err = error as Error;\n          logger.warn(`[WechatLogin] ${platform} 配置验证失败:`, err.message);\n        }\n      }\n\n      // 清理过期数据\n      this.startCleanupJob();\n\n      this.initialized = true;\n      logger.info('[WechatLogin] 微信登录服务初始化成功');\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 微信登录服务初始化失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 生成微信公众号OAuth授权URL\n   * @param redirectUri - 回调地址\n   * @param scope - 授权范围\n   * @param state - 状态参数\n   * @returns 授权URL\n   */\n  generateOfficialOAuthUrl(\n    redirectUri: string,\n    scope: string = 'snsapi_userinfo',\n    state: string | null = null\n  ): AuthUrlResult {\n    try {\n      const config = wechatConfig.getConfig('officialAccount');\n\n      // 生成state参数\n      const finalState = state || wechatConfig.generateState();\n\n      // 存储state和回调地址\n      const stateData: StateData = {\n        redirectUri,\n        platform: 'officialAccount',\n        createdAt: Date.now()\n      };\n      this.sessionStore.set(`state:${finalState}`, stateData);\n\n      const params: Record<string, string> = {\n        appid: config.appId,\n        redirect_uri: encodeURIComponent(redirectUri),\n        response_type: 'code',\n        scope: scope,\n        state: finalState\n      };\n\n      const queryString = Object.entries(params)\n        .map(([key, value]) => `${key}=${value}`)\n        .join('&');\n\n      const authUrl = `${config.domains.official}/connect/oauth2/authorize?${queryString}`;\n\n      logger.info(`[WechatLogin] 生成微信公众号授权URL: ${authUrl.substring(0, 100)}...`);\n\n      return {\n        authUrl,\n        state: finalState\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 生成微信公众号授权URL失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 处理微信公众号OAuth回调\n   * @param code - 授权码\n   * @param state - 状态参数\n   * @returns 登录结果\n   */\n  async handleOfficialOAuthCallback(code: string, state: string): Promise<OAuthCallbackResult> {\n    try {\n      // 验证state参数\n      const stateData = this.sessionStore.get(`state:${state}`) as StateData | undefined;\n      if (!stateData) {\n        throw new Error('无效的state参数或已过期');\n      }\n\n      if (!wechatConfig.verifyState(state)) {\n        throw new Error('state参数验证失败');\n      }\n\n      // 获取access_token\n      const tokenData = await this.getOfficialAccessToken(code);\n\n      // 获取用户信息\n      const userInfo = await this.getOfficialUserInfo(tokenData.access_token, tokenData.openid);\n\n      // 处理用户登录\n      const loginResult = await this.processWechatUserLogin(userInfo, 'officialAccount');\n\n      // 清理state\n      this.sessionStore.del(`state:${state}`);\n\n      logger.info(\n        `[WechatLogin] 微信公众号登录成功: openid=${userInfo.openid}, userId=${loginResult.userId}`\n      );\n\n      return {\n        success: true,\n        user: loginResult.user,\n        tokens: loginResult.tokens,\n        isNewUser: loginResult.isNewUser,\n        platform: 'officialAccount'\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 处理微信公众号OAuth回调失败:', err);\n      this.stats.failedLogins++;\n      throw error;\n    }\n  }\n\n  /**\n   * 微信小程序登录\n   * @param code - 小程序登录凭证\n   * @param userInfo - 用户信息\n   * @returns 登录结果\n   */\n  async handleMiniProgramLogin(\n    code: string,\n    userInfo: Record<string, unknown> = {}\n  ): Promise<MiniProgramLoginResult> {\n    try {\n      // 获取session_key和openid\n      const sessionData = await this.getMiniProgramSession(code);\n\n      // 构建用户数据\n      const wechatUser: WechatUserInfo = {\n        openid: sessionData.openid,\n        unionid: sessionData.unionid,\n        platform: 'miniProgram',\n        ...userInfo\n      };\n\n      // 处理用户登录\n      const loginResult = await this.processWechatUserLogin(wechatUser, 'miniProgram');\n\n      logger.info(\n        `[WechatLogin] 微信小程序登录成功: openid=${sessionData.openid}, userId=${loginResult.userId}`\n      );\n\n      return {\n        success: true,\n        user: loginResult.user,\n        tokens: loginResult.tokens,\n        isNewUser: loginResult.isNewUser,\n        platform: 'miniProgram',\n        sessionKey: sessionData.session_key || ''\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 微信小程序登录失败:', err);\n      this.stats.failedLogins++;\n      throw error;\n    }\n  }\n\n  /**\n   * 微信开放平台扫码登录\n   * @param redirectUri - 回调地址\n   * @param state - 状态参数\n   * @returns 授权URL\n   */\n  generateOpenPlatformOAuthUrl(\n    redirectUri: string,\n    state: string | null = null\n  ): AuthUrlResult {\n    try {\n      const config = wechatConfig.getConfig('openPlatform');\n\n      // 生成state参数\n      const finalState = state || wechatConfig.generateState();\n\n      // 存储state和回调地址\n      const stateData: StateData = {\n        redirectUri,\n        platform: 'openPlatform',\n        createdAt: Date.now()\n      };\n      this.sessionStore.set(`state:${finalState}`, stateData);\n\n      const params: Record<string, string> = {\n        appid: config.appId,\n        redirect_uri: encodeURIComponent(redirectUri),\n        response_type: 'code',\n        scope: 'snsapi_login',\n        state: finalState\n      };\n\n      const queryString = Object.entries(params)\n        .map(([key, value]) => `${key}=${value}`)\n        .join('&');\n\n      const authUrl = `${config.domains.open}/connect/qrconnect?${queryString}`;\n\n      logger.info(`[WechatLogin] 生成微信开放平台授权URL: ${authUrl.substring(0, 100)}...`);\n\n      return {\n        authUrl,\n        state: finalState\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 生成微信开放平台授权URL失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 处理微信开放平台扫码回调\n   * @param code - 授权码\n   * @param state - 状态参数\n   * @returns 登录结果\n   */\n  async handleOpenPlatformCallback(code: string, state: string): Promise<OAuthCallbackResult> {\n    try {\n      // 验证state参数\n      const stateData = this.sessionStore.get(`state:${state}`) as StateData | undefined;\n      if (!stateData) {\n        throw new Error('无效的state参数或已过期');\n      }\n\n      // 获取access_token\n      const tokenData = await this.getOpenPlatformAccessToken(code);\n\n      // 获取用户信息\n      const userInfo = await this.getOpenPlatformUserInfo(tokenData.access_token, tokenData.openid);\n\n      // 处理用户登录\n      const loginResult = await this.processWechatUserLogin(userInfo, 'openPlatform');\n\n      // 清理state\n      this.sessionStore.del(`state:${state}`);\n\n      logger.info(\n        `[WechatLogin] 微信开放平台登录成功: openid=${userInfo.openid}, userId=${loginResult.userId}`\n      );\n\n      return {\n        success: true,\n        user: loginResult.user,\n        tokens: loginResult.tokens,\n        isNewUser: loginResult.isNewUser,\n        platform: 'openPlatform'\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 处理微信开放平台扫码回调失败:', err);\n      this.stats.failedLogins++;\n      throw error;\n    }\n  }\n\n  /**\n   * 处理微信用户登录\n   * @param wechatUser - 微信用户信息\n   * @param platform - 登录平台\n   * @returns 登录结果\n   * @private\n   */\n  async processWechatUserLogin(\n    wechatUser: WechatUserInfo,\n    platform: WechatLoginPlatform\n  ): Promise<ProcessLoginResult> {\n    try {\n      const { openid, unionid } = wechatUser;\n\n      // 查找现有用户\n      let user: UserLoginData | null = null;\n      let isNewUser = false;\n\n      if (unionid) {\n        // 优先通过unionid查找用户\n        const foundUser = await db('users').where('wechat_unionid', unionid).first();\n        user = foundUser as UserLoginData | undefined;\n      }\n\n      if (!user && openid) {\n        // 通过openid查找用户\n        const foundUser = await db('users').where('wechat_openid', openid).first();\n        user = foundUser as UserLoginData | undefined;\n      }\n\n      if (!user) {\n        // 创建新用户\n        user = await this.createNewWechatUser(wechatUser, platform);\n        isNewUser = true;\n        this.stats.newUsers++;\n      } else {\n        // 更新现有用户信息\n        await this.updateWechatUser(user.id, wechatUser, platform);\n        this.stats.existingUsers++;\n      }\n\n      // 生成JWT令牌\n      const tokens = tokenService.generateTokenPair(user);\n\n      // 更新最后登录时间\n      await db('users').where('id', user.id).update({\n        last_login_at: new Date(),\n        last_login_platform: platform,\n        updated_at: new Date()\n      });\n\n      // 缓存用户会话\n      const sessionKey = `wechat_session:${user.id}`;\n      const sessionData: SessionCacheData = {\n        openid,\n        unionid,\n        platform,\n        loginAt: Date.now()\n      };\n      await cacheService.set(sessionKey, sessionData, wechatConfig.common.cache.sessionTTL);\n\n      this.stats.totalLogins++;\n      this.stats.successfulLogins++;\n\n      return {\n        user,\n        tokens,\n        userId: user.id,\n        isNewUser\n      };\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 处理微信用户登录失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 创建新的微信用户\n   * @param wechatUser - 微信用户信息\n   * @param platform - 登录平台\n   * @returns 用户信息\n   * @private\n   */\n  async createNewWechatUser(\n    wechatUser: WechatUserInfo,\n    platform: WechatLoginPlatform\n  ): Promise<UserLoginData> {\n    try {\n      const userId = uuidv4().replace(/-/g, '');\n      const now = new Date();\n\n      interface UserData {\n        id: string;\n        email: string;\n        username: string;\n        wechat_openid: string;\n        wechat_unionid?: string;\n        wechat_nickname: string | null;\n        wechat_avatar: string | null;\n        wechat_sex: number | null;\n        wechat_province: string | null;\n        wechat_city: string | null;\n        wechat_country: string | null;\n        auth_type: string;\n        status: string;\n        is_verified: boolean;\n        isMember: boolean;\n        quota_remaining: number;\n        role: string;\n        created_at: Date;\n        updated_at: Date;\n        last_login_at: Date;\n        last_login_platform: WechatLoginPlatform;\n      }\n\n      const userData: UserData = {\n        id: userId,\n        email: `wechat_${wechatUser.openid}@placeholder.com`,\n        username: `wx_${wechatUser.openid?.substr(0, 10) || 'user'}_${Date.now()}`,\n        wechat_openid: wechatUser.openid,\n        wechat_unionid: wechatUser.unionid,\n        wechat_nickname: wechatUser.nickname || null,\n        wechat_avatar: wechatUser.headimgurl || wechatUser.avatarUrl || null,\n        wechat_sex: wechatUser.sex || null,\n        wechat_province: wechatUser.province || null,\n        wechat_city: wechatUser.city || null,\n        wechat_country: wechatUser.country || null,\n        auth_type: 'wechat',\n        status: 'active',\n        is_verified: true,\n        isMember: false,\n        quota_remaining: 5,\n        role: 'user',\n        created_at: now,\n        updated_at: now,\n        last_login_at: now,\n        last_login_platform: platform\n      };\n\n      await db('users').insert(userData);\n\n      // 创建用户配置记录\n      await db('user_configs').insert({\n        user_id: userId,\n        auto_renew: false,\n        quality_threshold: 0.8,\n        max_daily_tasks: 10,\n        created_at: now,\n        updated_at: now\n      });\n\n      logger.info(`[WechatLogin] 创建新微信用户: userId=${userId}, openid=${wechatUser.openid}`);\n\n      const result: UserLoginData = {\n        id: userId,\n        email: userData.email,\n        username: userData.username,\n        wechat_nickname: userData.wechat_nickname,\n        wechat_avatar: userData.wechat_avatar,\n        role: userData.role,\n        isMember: userData.isMember,\n        quota_remaining: userData.quota_remaining,\n        created_at: userData.created_at\n      };\n\n      return result;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 创建新微信用户失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 更新微信用户信息\n   * @param userId - 用户ID\n   * @param wechatUser - 微信用户信息\n   * @param platform - 登录平台\n   * @private\n   */\n  async updateWechatUser(\n    userId: string,\n    wechatUser: WechatUserInfo,\n    platform: WechatLoginPlatform\n  ): Promise<void> {\n    try {\n      interface UpdateData {\n        last_login_platform: WechatLoginPlatform;\n        updated_at: Date;\n        wechat_openid?: string;\n        wechat_unionid?: string;\n        wechat_nickname?: string;\n        wechat_avatar?: string;\n      }\n\n      const updateData: UpdateData = {\n        last_login_platform: platform,\n        updated_at: new Date()\n      };\n\n      // 更新微信相关信息（如果有的话）\n      if (wechatUser.openid && !wechatUser.unionid) {\n        updateData.wechat_openid = wechatUser.openid;\n      }\n\n      if (wechatUser.unionid) {\n        updateData.wechat_unionid = wechatUser.unionid;\n        updateData.wechat_openid = wechatUser.openid;\n      }\n\n      if (wechatUser.nickname || wechatUser.nickName) {\n        updateData.wechat_nickname = wechatUser.nickname || (wechatUser.nickName as string);\n      }\n\n      if (wechatUser.headimgurl || wechatUser.avatarUrl) {\n        updateData.wechat_avatar = wechatUser.headimgurl || (wechatUser.avatarUrl as string);\n      }\n\n      await db('users').where('id', userId).update(updateData);\n\n      logger.debug(`[WechatLogin] 更新微信用户信息: userId=${userId}`);\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 更新微信用户信息失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取微信公众号access_token\n   * @param code - 授权码\n   * @returns token数据\n   * @private\n   */\n  async getOfficialAccessToken(code: string): Promise<TokenData> {\n    try {\n      const config = wechatConfig.getConfig('officialAccount');\n      const tokenUrl = wechatConfig.getApiUrl('officialAccount', '/sns/oauth2/access_token');\n\n      const params: Record<string, string> = {\n        appid: config.appId,\n        secret: config.appSecret,\n        code: code,\n        grant_type: 'authorization_code'\n      };\n\n      const response = await axios.get<TokenData>(tokenUrl, { params, timeout: 10000 });\n\n      if (response.data.errcode) {\n        throw new Error(\n          `微信API错误: ${response.data.errcode} - ${response.data.errmsg}`\n        );\n      }\n\n      return response.data;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取微信公众号access_token失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取微信公众号用户信息\n   * @param accessToken - 访问令牌\n   * @param openid - 用户openid\n   * @returns 用户信息\n   * @private\n   */\n  async getOfficialUserInfo(accessToken: string, openid: string): Promise<WechatUserInfo> {\n    try {\n      const userInfoUrl = wechatConfig.getApiUrl('officialAccount', '/sns/userinfo');\n\n      const params: Record<string, string> = {\n        access_token: accessToken,\n        openid: openid,\n        lang: 'zh_CN'\n      };\n\n      const response = await axios.get<WechatUserInfo>(userInfoUrl, { params, timeout: 10000 });\n\n      if (response.data.errcode !== undefined) {\n        const errCode = response.data.errcode as unknown;\n        const errMsg = response.data.errmsg as unknown;\n        throw new Error(`微信API错误: ${errCode} - ${errMsg}`);\n      }\n\n      return response.data;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取微信公众号用户信息失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取小程序session\n   * @param code - 登录凭证\n   * @returns session数据\n   * @private\n   */\n  async getMiniProgramSession(code: string): Promise<TokenData> {\n    try {\n      const config = wechatConfig.getConfig('miniProgram');\n      const sessionUrl = wechatConfig.getApiUrl('officialAccount', '/sns/jscode2session');\n\n      const params: Record<string, string> = {\n        appid: config.appId,\n        secret: config.appSecret,\n        js_code: code,\n        grant_type: 'authorization_code'\n      };\n\n      const response = await axios.get<TokenData>(sessionUrl, { params, timeout: 10000 });\n\n      if (response.data.errcode) {\n        throw new Error(\n          `微信API错误: ${response.data.errcode} - ${response.data.errmsg}`\n        );\n      }\n\n      return response.data;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取小程序session失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取开放平台access_token\n   * @param code - 授权码\n   * @returns token数据\n   * @private\n   */\n  async getOpenPlatformAccessToken(code: string): Promise<TokenData> {\n    try {\n      const config = wechatConfig.getConfig('openPlatform');\n      const tokenUrl = wechatConfig.getApiUrl('openPlatform', '/sns/oauth2/access_token');\n\n      const params: Record<string, string> = {\n        appid: config.appId,\n        secret: config.appSecret,\n        code: code,\n        grant_type: 'authorization_code'\n      };\n\n      const response = await axios.get<TokenData>(tokenUrl, { params, timeout: 10000 });\n\n      if (response.data.errcode) {\n        throw new Error(\n          `微信API错误: ${response.data.errcode} - ${response.data.errmsg}`\n        );\n      }\n\n      return response.data;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取开放平台access_token失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取开放平台用户信息\n   * @param accessToken - 访问令牌\n   * @param openid - 用户openid\n   * @returns 用户信息\n   * @private\n   */\n  async getOpenPlatformUserInfo(accessToken: string, openid: string): Promise<WechatUserInfo> {\n    try {\n      const userInfoUrl = wechatConfig.getApiUrl('openPlatform', '/sns/userinfo');\n\n      const params: Record<string, string> = {\n        access_token: accessToken,\n        openid: openid\n      };\n\n      const response = await axios.get<WechatUserInfo>(userInfoUrl, {\n        params,\n        timeout: 10000\n      });\n\n      if (response.data.errcode !== undefined) {\n        const errCode = response.data.errcode as unknown;\n        const errMsg = response.data.errmsg as unknown;\n        throw new Error(`微信API错误: ${errCode} - ${errMsg}`);\n      }\n\n      return response.data;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取开放平台用户信息失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取用户微信绑定信息\n   * @param userId - 用户ID\n   * @returns 绑定信息\n   */\n  async getUserWechatBindings(userId: string): Promise<WechatBindings> {\n    try {\n      interface UserBindingData {\n        wechat_openid?: string;\n        wechat_unionid?: string;\n        wechat_nickname?: string;\n        wechat_avatar?: string;\n        last_login_platform?: WechatLoginPlatform;\n      }\n\n      const user = await db('users')\n        .where('id', userId)\n        .first([\n          'wechat_openid',\n          'wechat_unionid',\n          'wechat_nickname',\n          'wechat_avatar',\n          'last_login_platform'\n        ]);\n\n      if (!user) {\n        throw new Error('用户不存在');\n      }\n\n      const bindingData = user as UserBindingData;\n      const bindings: WechatBindings = {};\n\n      if (bindingData.wechat_openid) {\n        bindings.openid = bindingData.wechat_openid;\n      }\n\n      if (bindingData.wechat_unionid) {\n        bindings.unionid = bindingData.wechat_unionid;\n      }\n\n      if (bindingData.wechat_nickname) {\n        bindings.nickname = bindingData.wechat_nickname;\n      }\n\n      if (bindingData.wechat_avatar) {\n        bindings.avatar = bindingData.wechat_avatar;\n      }\n\n      if (bindingData.last_login_platform) {\n        bindings.lastLoginPlatform = bindingData.last_login_platform;\n      }\n\n      return bindings;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 获取用户微信绑定信息失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 解除微信绑定\n   * @param userId - 用户ID\n   * @returns 是否成功\n   */\n  async unbindWechat(userId: string): Promise<boolean> {\n    try {\n      await db('users').where('id', userId).update({\n        wechat_openid: null,\n        wechat_unionid: null,\n        wechat_nickname: null,\n        wechat_avatar: null,\n        updated_at: new Date()\n      });\n\n      // 清除缓存\n      const sessionKey = `wechat_session:${userId}`;\n      await cacheService.delete(sessionKey);\n\n      logger.info(`[WechatLogin] 解除微信绑定: userId=${userId}`);\n\n      return true;\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 解除微信绑定失败:', err);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取统计信息\n   * @returns 统计数据\n   */\n  getStats(): LoginStats {\n    const now = Date.now();\n    const uptime = now - this.stats.lastReset;\n\n    return {\n      ...this.stats,\n      uptime,\n      activeSessions: this.sessionStore.keys().length,\n      cachedAccessTokens: this.accessTokenCache.keys().length,\n      cachedJsapiTickets: this.jsapiTicketCache.keys().length,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * 启动清理任务\n   * @private\n   */\n  private startCleanupJob(): void {\n    // 每30分钟清理一次过期数据\n    setInterval((): void => {\n      this.cleanupExpiredData();\n    }, 30 * 60 * 1000);\n\n    logger.info('[WechatLogin] 清理任务已启动');\n  }\n\n  /**\n   * 清理过期数据\n   * @private\n   */\n  private cleanupExpiredData(): void {\n    try {\n      const now = Date.now();\n      const maxAge = 10 * 60 * 1000; // 10分钟\n\n      // 清理过期的state数据\n      const stateKeys = this.sessionStore.keys().filter((key) => key.startsWith('state:'));\n      let cleanedStates = 0;\n\n      for (const key of stateKeys) {\n        const data = this.sessionStore.get(key) as StateData | undefined;\n        if (data && now - data.createdAt > maxAge) {\n          this.sessionStore.del(key);\n          cleanedStates++;\n        }\n      }\n\n      logger.debug(`[WechatLogin] 清理过期数据完成: ${cleanedStates}个state`);\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 清理过期数据失败:', err);\n    }\n  }\n\n  /**\n   * 关闭微信登录服务\n   */\n  async close(): Promise<void> {\n    try {\n      // 清空所有缓存\n      this.accessTokenCache.flushAll();\n      this.jsapiTicketCache.flushAll();\n      this.sessionStore.flushAll();\n\n      this.initialized = false;\n      logger.info('[WechatLogin] 微信登录服务已关闭');\n    } catch (error: unknown) {\n      const err = error as Error;\n      logger.error('[WechatLogin] 关闭微信登录服务失败:', err);\n    }\n  }\n}\n\nconst wechatLoginService: WechatLoginService = new WechatLoginService();\n\nexport default wechatLoginService;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/cms-feature.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/cms-provider.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/cos-nodejs-sdk-v5.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":2,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[50,53],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[50,53],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module 'cos-nodejs-sdk-v5' {\n  const COS: any;\n  export default COS;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/cos-storage-service.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/file.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/generator.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/kms.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/mcp-endpoint.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/multer.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[82,85],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[82,85],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[132,135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[132,135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[201,204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[201,204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[238,241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[238,241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module 'multer' {\n  interface MulterInstance {\n    single(field: string): any;\n    array(field: string, maxCount?: number): any;\n    fields(fields: Array<{ name: string; maxCount?: number }>): any;\n  }\n  function multer(options?: any): MulterInstance;\n  export default multer;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/nodemailer.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/payment.types.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `userId:·string,·data:·CreatePaymentOrderRequest` with `⏎····userId:·string,⏎····data:·CreatePaymentOrderRequest⏎··`","line":189,"column":22,"nodeType":null,"messageId":"replace","endLine":189,"endColumn":69,"fix":{"range":[3140,3187],"text":"\n    userId: string,\n    data: CreatePaymentOrderRequest\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `data:·Record<string,·unknown>` with `⏎····data:·Record<string,·unknown>⏎··`","line":191,"column":24,"nodeType":null,"messageId":"replace","endLine":191,"endColumn":53,"fix":{"range":[3336,3365],"text":"\n    data: Record<string, unknown>\n  "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\n * Payment 类型定义\n * 艹！这个SB文件定义支付管理的所有类型，消除any！\n *\n * @author 老王\n */\n\nimport type { AuthRequest } from '../middlewares/auth.middleware.js';\n\n/**\n * 支付方式\n */\nexport type PaymentMethod = 'alipay' | 'wechat' | 'balance';\n\n/**\n * 订单状态\n */\nexport type OrderStatus = 'pending' | 'paid' | 'cancelled' | 'refunded' | 'failed';\n\n/**\n * 退款状态\n */\nexport type RefundStatus = 'pending' | 'success' | 'failed' | 'rejected';\n\n/**\n * 产品类型\n */\nexport type ProductType = 'quota' | 'membership' | 'feature' | 'other';\n\n/**\n * 创建支付订单请求\n */\nexport interface CreatePaymentOrderRequest {\n  productType: ProductType;\n  productId?: string;\n  productName: string;\n  productDescription?: string;\n  amount: number;\n  paymentMethod: PaymentMethod;\n  returnUrl?: string;\n  notifyUrl?: string;\n}\n\n/**\n * 支付订单数据库模型\n */\nexport interface PaymentOrder {\n  id: string;\n  order_no: string;\n  user_id: string;\n  product_type: ProductType;\n  product_id?: string;\n  product_name: string;\n  product_description?: string;\n  amount: number;\n  payment_method: PaymentMethod;\n  status: OrderStatus;\n  paid_at?: Date | string | null;\n  created_at: Date | string;\n  updated_at: Date | string;\n}\n\n/**\n * 创建支付订单响应\n */\nexport interface CreatePaymentOrderResponse {\n  orderId: string;\n  orderNo: string;\n  paymentUrl?: string;\n  qrCode?: string;\n  amount: number;\n  expiresAt?: string;\n}\n\n/**\n * 创建退款请求\n */\nexport interface CreateRefundRequest {\n  orderId: string;\n  refundAmount?: number;\n  refundReason: string;\n}\n\n/**\n * 退款记录数据库模型\n */\nexport interface RefundRecord {\n  id: string;\n  order_id: string;\n  user_id: string;\n  refund_no: string;\n  refund_amount: number;\n  refund_reason: string;\n  status: RefundStatus;\n  refunded_at?: Date | string | null;\n  created_at: Date | string;\n  updated_at: Date | string;\n}\n\n/**\n * 创建退款响应\n */\nexport interface CreateRefundResponse {\n  refundId: string;\n  refundNo: string;\n  status: RefundStatus;\n  refundAmount: number;\n}\n\n/**\n * 订单状态响应\n */\nexport interface OrderStatusResponse {\n  orderId: string;\n  orderNo: string;\n  status: OrderStatus;\n  amount: number;\n  productName: string;\n  paymentMethod: PaymentMethod;\n  paidAt?: string | null;\n  createdAt: string;\n}\n\n/**\n * 支付记录查询参数\n */\nexport interface PaymentRecordsQuery {\n  page?: string;\n  limit?: string;\n  status?: OrderStatus;\n  paymentMethod?: PaymentMethod;\n}\n\n/**\n * 退款记录查询参数\n */\nexport interface RefundRecordsQuery {\n  page?: string;\n  limit?: string;\n  status?: RefundStatus;\n}\n\n/**\n * 分页响应\n */\nexport interface PaginationInfo {\n  page: number;\n  limit: number;\n  total: number;\n  pages: number;\n}\n\n/**\n * 支付记录列表响应\n */\nexport interface PaymentRecordsResponse {\n  orders: PaymentOrder[];\n  pagination: PaginationInfo;\n}\n\n/**\n * 退款记录列表响应\n */\nexport interface RefundRecordsResponse {\n  refunds: RefundRecord[];\n  pagination: PaginationInfo;\n}\n\n/**\n * 支付统计响应\n */\nexport interface PaymentStatsResponse {\n  totalOrders: number;\n  paidOrders: number;\n  totalAmount: number;\n  totalRefunds: number;\n  refundAmount: number;\n}\n\n/**\n * 认证后的请求（沿用公共中间件的定义）\n */\nexport type AuthenticatedRequest = AuthRequest;\n\n/**\n * 支付服务接口（用于controller调用）\n */\nexport interface PaymentService {\n  createPaymentOrder(userId: string, data: CreatePaymentOrderRequest): Promise<CreatePaymentOrderResponse>;\n  handleAlipayCallback(data: Record<string, unknown>): Promise<{ success: boolean }>;\n  handleWechatCallback(data: Record<string, unknown>): Promise<{ success: boolean; message?: string }>;\n  createRefund(\n    orderId: string,\n    userId: string,\n    data: { refundAmount?: number; refundReason: string }\n  ): Promise<CreateRefundResponse>;\n  getOrderStatus(orderId: string, userId?: string): Promise<OrderStatusResponse>;\n}\n\n/**\n * 数据库查询结果类型\n */\nexport interface CountResult {\n  count: number;\n}\n\nexport interface SumResult {\n  total: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/prompt-template.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/qcloud-cos-sts.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/swagger-jsdoc.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":2,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[64,67],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[64,67],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":2,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[72,75],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[72,75],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module 'swagger-jsdoc' {\n  const swaggerJsdoc: (config: any) => any;\n  export default swaggerJsdoc;\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/task.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/types/wechat-login.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/AppError.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `code` with `⏎····code⏎··`","line":174,"column":99,"nodeType":null,"messageId":"replace","endLine":174,"endColumn":103,"fix":{"range":[4303,4307],"text":"\n    code\n  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `⏎·····`","line":204,"column":20,"nodeType":null,"messageId":"insert","endLine":204,"endColumn":20,"fix":{"range":[5331,5331],"text":"\n     "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"import {\n  ERROR_CODES,\n  ERROR_METADATA,\n  type ErrorCategory,\n  type ErrorCode,\n  type ErrorSeverity\n} from '../config/error-codes.js';\nimport {\n  DEFAULT_LANGUAGE,\n  SUPPORTED_LANGUAGES,\n  type LocaleMessages,\n  type SupportedLanguageCode\n} from '../config/i18n-messages.js';\n\nexport interface AppErrorOptions {\n  isOperational?: boolean;\n  shouldLog?: boolean;\n  shouldNotify?: boolean;\n}\n\nexport type AppErrorContext = Record<string, unknown>;\n\nexport interface AppErrorJSON {\n  success: false;\n  error: {\n    code: ErrorCode;\n    message: string;\n    timestamp: string;\n  };\n  metadata: {\n    category: ErrorCategory;\n    severity: ErrorSeverity;\n  };\n  requestId?: string | null;\n  debug?: {\n    context: AppErrorContext;\n    stack?: string;\n    statusCode: number;\n  };\n}\n\nconst DEFAULT_METADATA: {\n  category: ErrorCategory;\n  severity: ErrorSeverity;\n} = {\n  category: 'unknown' as ErrorCategory,\n  severity: 'medium' as ErrorSeverity\n};\n\nconst SYSTEM_ERROR_CODES = new Set<ErrorCode>([\n  ERROR_CODES.INTERNAL_SERVER_ERROR,\n  ERROR_CODES.DATABASE_ERROR,\n  ERROR_CODES.CACHE_ERROR,\n  ERROR_CODES.QUEUE_ERROR,\n  ERROR_CODES.EXTERNAL_SERVICE_ERROR,\n  ERROR_CODES.LOGIN_ATTEMPTS_EXCEEDED,\n  ERROR_CODES.TASK_PROCESSOR_UNAVAILABLE,\n  ERROR_CODES.PAYMENT_GATEWAY_ERROR,\n  ERROR_CODES.COMMISSION_CALCULATION_FAILED,\n  ERROR_CODES.DATABASE_MIGRATION_FAILED,\n  ERROR_CODES.ENVIRONMENT_VARIABLE_MISSING,\n  ERROR_CODES.CONNECTION_FAILED,\n  ERROR_CODES.REQUEST_TIMEOUT,\n  ERROR_CODES.DNS_RESOLUTION_FAILED,\n  ERROR_CODES.SSL_VERIFICATION_FAILED,\n  ERROR_CODES.PROXY_ERROR,\n  ERROR_CODES.BANDWIDTH_LIMIT_EXCEEDED,\n  ERROR_CODES.WEBSOCKET_CONNECTION_FAILED,\n  ERROR_CODES.NOTIFICATION_SEND_FAILED,\n  ERROR_CODES.RATE_LIMIT_CONFIG_INVALID,\n  ERROR_CODES.CACHE_VERSION_CONFLICT\n] as ErrorCode[]);\n\nconst mapStatusCode = (code: ErrorCode): number => {\n  if (code === ERROR_CODES.SUCCESS) return 200;\n  if (code >= 1000 && code < 1999) {\n    switch (code) {\n      case ERROR_CODES.INVALID_REQUEST:\n      case ERROR_CODES.MISSING_PARAMETERS:\n      case ERROR_CODES.INVALID_PARAMETERS:\n        return 400;\n      case ERROR_CODES.RATE_LIMIT_EXCEEDED:\n        return 429;\n      case ERROR_CODES.INTERNAL_SERVER_ERROR:\n      case ERROR_CODES.DATABASE_ERROR:\n      case ERROR_CODES.CACHE_ERROR:\n      case ERROR_CODES.QUEUE_ERROR:\n        return 500;\n      case ERROR_CODES.EXTERNAL_SERVICE_ERROR:\n        return 502;\n      default:\n        return 500;\n    }\n  }\n\n  if (code >= 2000 && code < 2999) {\n    switch (code) {\n      case ERROR_CODES.UNAUTHORIZED:\n      case ERROR_CODES.INVALID_TOKEN:\n      case ERROR_CODES.TOKEN_EXPIRED:\n      case ERROR_CODES.TOKEN_BLACKLISTED:\n      case ERROR_CODES.INVALID_CREDENTIALS:\n      case ERROR_CODES.LOGIN_REQUIRED:\n        return 401;\n      case ERROR_CODES.PERMISSION_DENIED:\n      case ERROR_CODES.INSUFFICIENT_PERMISSIONS:\n      case ERROR_CODES.ADMIN_REQUIRED:\n        return 403;\n      default:\n        return 401;\n    }\n  }\n\n  if (code >= 3000 && code < 3999) {\n    switch (code) {\n      case ERROR_CODES.USER_NOT_FOUND:\n        return 404;\n      case ERROR_CODES.USER_ALREADY_EXISTS:\n      case ERROR_CODES.EMAIL_ALREADY_EXISTS:\n      case ERROR_CODES.PHONE_ALREADY_EXISTS:\n        return 409;\n      default:\n        return 400;\n    }\n  }\n\n  if (code >= 4000 && code < 4999) {\n    switch (code) {\n      case ERROR_CODES.TASK_NOT_FOUND:\n      case ERROR_CODES.FILE_NOT_FOUND:\n        return 404;\n      case ERROR_CODES.FILE_TOO_LARGE:\n      case ERROR_CODES.FILE_TYPE_NOT_SUPPORTED:\n        return 400;\n      default:\n        return 500;\n    }\n  }\n\n  if (code >= 5000 && code < 5999) {\n    switch (code) {\n      case ERROR_CODES.PAYMENT_REQUIRED:\n        return 402;\n      case ERROR_CODES.PAYMENT_FAILED:\n      case ERROR_CODES.PAYMENT_TIMEOUT:\n        return 400;\n      case ERROR_CODES.ORDER_NOT_FOUND:\n        return 404;\n      default:\n        return 500;\n    }\n  }\n\n  if (code >= 6000 && code < 6999) {\n    return 400;\n  }\n\n  if (code >= 7000 && code < 7999) {\n    return 500;\n  }\n\n  if (code >= 8000 && code < 8999) {\n    return 500;\n  }\n\n  if (code >= 9000 && code < 9999) {\n    return 400;\n  }\n\n  return 500;\n};\n\nconst resolveMetadata = (code: ErrorCode) => {\n  const metadataEntry = (ERROR_METADATA as unknown as Record<ErrorCode, typeof DEFAULT_METADATA>)[code];\n  return metadataEntry ?? DEFAULT_METADATA;\n};\n\nconst getMessagesForLanguage = (language: SupportedLanguageCode): LocaleMessages => {\n  const messages = SUPPORTED_LANGUAGES[language]?.messages;\n  if (messages) {\n    return messages;\n  }\n  return SUPPORTED_LANGUAGES[DEFAULT_LANGUAGE as SupportedLanguageCode].messages;\n};\n\nexport class AppError extends Error {\n  public readonly code: ErrorCode;\n  public readonly metadata: ReturnType<typeof resolveMetadata>;\n  public readonly context: AppErrorContext;\n  public readonly timestamp: string;\n  public readonly requestId: string | null;\n  public readonly userId: string | null;\n  public readonly options: Required<AppErrorOptions>;\n  public readonly statusCode: number;\n  public readonly exposeToClient: boolean;\n\n  constructor(\n    code: ErrorCode,\n    customMessage: string | null = null,\n    context: AppErrorContext = {},\n    options: AppErrorOptions = {}\n  ) {\n    const messages = getMessagesForLanguage(DEFAULT_LANGUAGE as SupportedLanguageCode);\n    const message = customMessage ?? (messages as unknown as Record<ErrorCode, string>)[code] ?? '未知错误';\n    super(message);\n\n    this.name = 'AppError';\n    this.code = code;\n    this.metadata = resolveMetadata(code);\n    this.context = context;\n    this.timestamp = new Date().toISOString();\n    this.requestId = (context.requestId as string | undefined) ?? null;\n    this.userId = (context.userId as string | undefined) ?? null;\n    this.options = {\n      isOperational: true,\n      shouldLog: true,\n      shouldNotify: false,\n      ...options\n    };\n    this.statusCode = mapStatusCode(code);\n    this.exposeToClient = !SYSTEM_ERROR_CODES.has(code);\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AppError);\n    }\n  }\n\n  public getDefaultMessage(\n    language: SupportedLanguageCode = DEFAULT_LANGUAGE as SupportedLanguageCode\n  ): string {\n    const messages = getMessagesForLanguage(language);\n    return (messages as unknown as Record<ErrorCode, string>)[this.code] ?? this.message;\n  }\n\n  public getLocalizedMessage(language: SupportedLanguageCode): string {\n    return this.getDefaultMessage(language);\n  }\n\n  public toJSON(\n    language: SupportedLanguageCode = DEFAULT_LANGUAGE as SupportedLanguageCode\n  ): AppErrorJSON {\n    const response: AppErrorJSON = {\n      success: false,\n      error: {\n        code: this.code,\n        message: this.getLocalizedMessage(language),\n        timestamp: this.timestamp\n      },\n      metadata: {\n        category: this.metadata.category,\n        severity: this.metadata.severity\n      }\n    };\n\n    if (this.requestId) {\n      response.requestId = this.requestId;\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      response.debug = {\n        context: this.context,\n        stack: this.stack,\n        statusCode: this.statusCode\n      };\n    }\n\n    return response;\n  }\n\n  public toLogFormat(): Record<string, unknown> {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n      category: this.metadata.category,\n      severity: this.metadata.severity,\n      context: this.context,\n      requestId: this.requestId,\n      userId: this.userId,\n      timestamp: this.timestamp,\n      stack: this.stack\n    };\n  }\n\n  public static create(\n    code: ErrorCode,\n    context: AppErrorContext = {},\n    options: AppErrorOptions = {}\n  ): AppError {\n    return new AppError(code, null, context, options);\n  }\n\n  public static custom(\n    code: ErrorCode,\n    message: string,\n    context: AppErrorContext = {},\n    options: AppErrorOptions = {}\n  ): AppError {\n    return new AppError(code, message, context, options);\n  }\n\n  public static fromError(\n    error: unknown,\n    fallbackCode: ErrorCode = ERROR_CODES.UNKNOWN_ERROR,\n    context: AppErrorContext = {}\n  ): AppError {\n    if (error instanceof AppError) {\n      return error;\n    }\n\n    const originalError = error as Error;\n\n    const enhancedContext: AppErrorContext = {\n      originalError: originalError?.name,\n      originalMessage: originalError?.message,\n      ...context\n    };\n\n    return new AppError(fallbackCode, originalError?.message ?? '未知错误', enhancedContext, {\n      shouldLog: true,\n      isOperational: false\n    });\n  }\n\n  public static isAppError(error: unknown): error is AppError {\n    return error instanceof AppError;\n  }\n}\n\nexport default AppError;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/cacheInvalidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/crypto.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `·?·JSON.parse(obj[field]·as·string)` with `⏎············?·JSON.parse(obj[field]·as·string)⏎···········`","line":269,"column":41,"nodeType":null,"messageId":"replace","endLine":269,"endColumn":76,"fix":{"range":[6125,6160],"text":"\n            ? JSON.parse(obj[field] as string)\n           "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 凭证加密工具（AES-256-GCM）\n * 艹，这个tm必须安全！明文凭证绝不落库！\n *\n * 功能：\n * - AES-256-GCM加密/解密\n * - 密钥版本管理与轮换\n * - 篡改检测（GCM自带认证）\n * - 随机IV（每次加密都不同）\n */\n\nimport crypto from 'crypto';\n\n/**\n * 加密算法配置\n */\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 12; // GCM推荐12字节IV\nconst AUTH_TAG_LENGTH = 16; // GCM认证标签16字节\nconst KEY_LENGTH = 32; // AES-256需要32字节key\n\n/**\n * 密钥版本配置\n * 艹，支持密钥轮换，旧密钥保留用于解密历史数据\n */\ninterface KeyVersion {\n  version: number;\n  key: Buffer;\n  createdAt: Date;\n}\n\n/**\n * 加密结果\n */\nexport interface EncryptedData {\n  /** 密文（Base64编码） */\n  ciphertext: string;\n  /** 初始化向量（Base64编码） */\n  iv: string;\n  /** 认证标签（Base64编码） */\n  authTag: string;\n  /** 密钥版本号 */\n  keyVersion: number;\n}\n\n/**\n * 密钥管理器\n * 艹，这个类管理所有密钥版本\n */\nclass KeyManager {\n  private keys: Map<number, KeyVersion> = new Map();\n  private currentVersion: number = 1;\n\n  constructor() {\n    // 从环境变量读取主密钥\n    this.loadMasterKey();\n  }\n\n  /**\n   * 从环境变量加载主密钥\n   * 格式：MASTER_KEY=base64编码的32字节密钥\n   */\n  private loadMasterKey(): void {\n    const masterKeyEnv = process.env.MASTER_KEY;\n\n    if (!masterKeyEnv) {\n      // 艹，开发环境生成临时密钥（生产环境必须配置！）\n      if (process.env.NODE_ENV === 'production') {\n        throw new Error('生产环境必须配置MASTER_KEY环境变量！这tm是安全红线！');\n      }\n\n      console.warn('[CRYPTO] 警告：未配置MASTER_KEY，使用临时密钥（仅用于开发）');\n      const tempKey = crypto.randomBytes(KEY_LENGTH);\n      this.addKey(1, tempKey);\n      return;\n    }\n\n    try {\n      // 解析Base64编码的密钥\n      const keyBuffer = Buffer.from(masterKeyEnv, 'base64');\n\n      if (keyBuffer.length !== KEY_LENGTH) {\n        throw new Error(`MASTER_KEY长度错误：期望${KEY_LENGTH}字节，实际${keyBuffer.length}字节`);\n      }\n\n      this.addKey(1, keyBuffer);\n      console.log('[CRYPTO] 主密钥加载成功 (版本: 1)');\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      throw new Error(`加载MASTER_KEY失败: ${err.message}`);\n    }\n  }\n\n  /**\n   * 添加密钥版本\n   * @param version - 版本号\n   * @param key - 密钥Buffer\n   */\n  public addKey(version: number, key: Buffer): void {\n    if (key.length !== KEY_LENGTH) {\n      throw new Error(`密钥长度必须是${KEY_LENGTH}字节`);\n    }\n\n    this.keys.set(version, {\n      version,\n      key,\n      createdAt: new Date()\n    });\n\n    // 更新当前版本\n    if (version > this.currentVersion) {\n      this.currentVersion = version;\n    }\n  }\n\n  /**\n   * 获取当前密钥\n   */\n  public getCurrentKey(): { version: number; key: Buffer } {\n    const keyVersion = this.keys.get(this.currentVersion);\n    if (!keyVersion) {\n      throw new Error('当前密钥不存在！这tm不应该发生！');\n    }\n    return { version: keyVersion.version, key: keyVersion.key };\n  }\n\n  /**\n   * 根据版本号获取密钥\n   * @param version - 版本号\n   */\n  public getKey(version: number): Buffer {\n    const keyVersion = this.keys.get(version);\n    if (!keyVersion) {\n      throw new Error(`密钥版本${version}不存在！可能需要配置历史密钥`);\n    }\n    return keyVersion.key;\n  }\n\n  /**\n   * 获取所有密钥版本列表\n   */\n  public getVersions(): number[] {\n    return Array.from(this.keys.keys()).sort((a, b) => b - a);\n  }\n}\n\n// 全局密钥管理器实例\nconst keyManager = new KeyManager();\n\n/**\n * 加密数据\n * @param plaintext - 明文（字符串或对象）\n * @param keyVersion - 密钥版本（可选，默认使用当前版本）\n * @returns EncryptedData - 加密结果\n */\nexport function encrypt(plaintext: string | object, keyVersion?: number): EncryptedData {\n  // 转换为字符串\n  const plaintextStr = typeof plaintext === 'string' ? plaintext : JSON.stringify(plaintext);\n\n  // 获取密钥\n  const { version, key } =\n    keyVersion !== undefined\n      ? { version: keyVersion, key: keyManager.getKey(keyVersion) }\n      : keyManager.getCurrentKey();\n\n  // 生成随机IV（艹，每次加密都不同，增强安全性）\n  const iv = crypto.randomBytes(IV_LENGTH);\n\n  // 创建加密器\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n  // 加密\n  let ciphertext = cipher.update(plaintextStr, 'utf8', 'base64');\n  ciphertext += cipher.final('base64');\n\n  // 获取认证标签（GCM模式）\n  const authTag = cipher.getAuthTag();\n\n  return {\n    ciphertext,\n    iv: iv.toString('base64'),\n    authTag: authTag.toString('base64'),\n    keyVersion: version\n  };\n}\n\n/**\n * 解密数据\n * @param encryptedData - 加密数据\n * @returns string - 明文\n * @throws Error - 解密失败或数据被篡改\n */\nexport function decrypt(encryptedData: EncryptedData): string {\n  const { ciphertext, iv, authTag, keyVersion } = encryptedData;\n\n  // 获取对应版本的密钥\n  let key: Buffer;\n  try {\n    key = keyManager.getKey(keyVersion);\n  } catch (error: unknown) {\n    const err = error instanceof Error ? error : new Error(String(error));\n    throw new Error(`解密失败：密钥版本${keyVersion}不存在。${err.message}`);\n  }\n\n  // 转换Base64为Buffer\n  const ivBuffer = Buffer.from(iv, 'base64');\n  const authTagBuffer = Buffer.from(authTag, 'base64');\n\n  // 创建解密器\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, ivBuffer);\n\n  // 设置认证标签（艹，这个tm很重要，用于验证数据完整性）\n  decipher.setAuthTag(authTagBuffer);\n\n  try {\n    // 解密\n    let plaintext = decipher.update(ciphertext, 'base64', 'utf8');\n    plaintext += decipher.final('utf8');\n    return plaintext;\n  } catch (error: unknown) {\n    // 艹，GCM解密失败通常意味着数据被篡改或密钥错误\n    const err = error instanceof Error ? error : new Error(String(error));\n    throw new Error(`解密失败：数据可能被篡改或密钥错误。${err.message}`);\n  }\n}\n\n/**\n * 加密对象中的敏感字段\n * @param obj - 原始对象\n * @param sensitiveFields - 敏感字段列表（白名单）\n * @returns 加密后的对象\n */\nexport function encryptFields(\n  obj: Record<string, unknown>,\n  sensitiveFields: string[]\n): Record<string, unknown> {\n  const result: Record<string, unknown> = { ...obj };\n\n  for (const field of sensitiveFields) {\n    if (obj[field] !== undefined && obj[field] !== null) {\n      // 加密该字段\n      const encrypted = encrypt(obj[field]);\n\n      // 存储为JSON字符串（方便数据库存储）\n      result[field] = JSON.stringify(encrypted);\n    }\n  }\n\n  return result;\n}\n\n/**\n * 解密对象中的敏感字段\n * @param obj - 加密后的对象\n * @param sensitiveFields - 敏感字段列表\n * @returns 解密后的对象\n */\nexport function decryptFields(\n  obj: Record<string, unknown>,\n  sensitiveFields: string[]\n): Record<string, unknown> {\n  const result: Record<string, unknown> = { ...obj };\n\n  for (const field of sensitiveFields) {\n    if (obj[field] !== undefined && obj[field] !== null) {\n      try {\n        // 解析JSON并解密\n        const encryptedData: EncryptedData =\n          typeof obj[field] === 'string' ? JSON.parse(obj[field] as string) : (obj[field] as EncryptedData);\n\n        result[field] = decrypt(encryptedData);\n\n        // 尝试解析为JSON对象（如果原始数据是对象）\n        try {\n          result[field] = JSON.parse(result[field] as string);\n        } catch {\n          // 不是JSON，保持字符串\n        }\n      } catch (error: unknown) {\n        const err = error instanceof Error ? error : new Error(String(error));\n        console.error(`[CRYPTO] 解密字段\"${field}\"失败: ${err.message}`);\n        // 保留加密数据（不要丢失）\n        result[field] = obj[field];\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * 生成新的主密钥（用于密钥轮换）\n * 艹，生产环境慎用！需要配合数据迁移！\n * @returns Base64编码的密钥\n */\nexport function generateMasterKey(): string {\n  const key = crypto.randomBytes(KEY_LENGTH);\n  return key.toString('base64');\n}\n\n/**\n * 添加新密钥版本（用于密钥轮换）\n * @param version - 版本号\n * @param keyBase64 - Base64编码的密钥\n */\nexport function addKeyVersion(version: number, keyBase64: string): void {\n  const key = Buffer.from(keyBase64, 'base64');\n  keyManager.addKey(version, key);\n}\n\n/**\n * 获取当前密钥版本号\n */\nexport function getCurrentKeyVersion(): number {\n  return keyManager.getCurrentKey().version;\n}\n\n/**\n * 获取所有可用密钥版本\n */\nexport function getAvailableKeyVersions(): number[] {\n  return keyManager.getVersions();\n}\n\n/**\n * 重新加密数据（用于密钥轮换）\n * @param encryptedData - 旧密钥加密的数据\n * @param newKeyVersion - 新密钥版本（可选，默认使用当前版本）\n * @returns EncryptedData - 新密钥加密的数据\n */\nexport function reencrypt(encryptedData: EncryptedData, newKeyVersion?: number): EncryptedData {\n  // 1. 用旧密钥解密\n  const plaintext = decrypt(encryptedData);\n\n  // 2. 用新密钥加密\n  return encrypt(plaintext, newKeyVersion);\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/db-metrics.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":184,"column":9,"nodeType":null,"messageId":"insert","endLine":184,"endColumn":9,"fix":{"range":[3399,3399],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":185,"column":1,"nodeType":null,"messageId":"insert","endLine":185,"endColumn":1,"fix":{"range":[3434,3434],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":186,"column":9,"nodeType":null,"messageId":"insert","endLine":186,"endColumn":9,"fix":{"range":[3483,3483],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":187,"column":1,"nodeType":null,"messageId":"insert","endLine":187,"endColumn":1,"fix":{"range":[3519,3519],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":188,"column":11,"nodeType":null,"messageId":"insert","endLine":188,"endColumn":11,"fix":{"range":[3580,3580],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":189,"column":1,"nodeType":null,"messageId":"insert","endLine":189,"endColumn":1,"fix":{"range":[3617,3617],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":190,"column":9,"nodeType":null,"messageId":"insert","endLine":190,"endColumn":9,"fix":{"range":[3673,3673],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":191,"column":1,"nodeType":null,"messageId":"insert","endLine":191,"endColumn":1,"fix":{"range":[3677,3677],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":193,"column":7,"nodeType":null,"messageId":"insert","endLine":193,"endColumn":7,"fix":{"range":[3694,3694],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":194,"column":1,"nodeType":null,"messageId":"insert","endLine":194,"endColumn":1,"fix":{"range":[3740,3740],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":195,"column":9,"nodeType":null,"messageId":"insert","endLine":195,"endColumn":9,"fix":{"range":[3791,3791],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":196,"column":1,"nodeType":null,"messageId":"insert","endLine":196,"endColumn":1,"fix":{"range":[3824,3824],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":197,"column":11,"nodeType":null,"messageId":"insert","endLine":197,"endColumn":11,"fix":{"range":[3878,3878],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":198,"column":1,"nodeType":null,"messageId":"insert","endLine":198,"endColumn":1,"fix":{"range":[3919,3919],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":199,"column":9,"nodeType":null,"messageId":"insert","endLine":199,"endColumn":9,"fix":{"range":[3973,3973],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":200,"column":1,"nodeType":null,"messageId":"replace","endLine":200,"endColumn":7,"fix":{"range":[3977,3983],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":202,"column":1,"nodeType":null,"messageId":"insert","endLine":202,"endColumn":1,"fix":{"range":[3988,3988],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":203,"column":1,"nodeType":null,"messageId":"replace","endLine":203,"endColumn":9,"fix":{"range":[4040,4048],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":204,"column":1,"nodeType":null,"messageId":"insert","endLine":204,"endColumn":1,"fix":{"range":[4082,4082],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··········` with `············`","line":205,"column":1,"nodeType":null,"messageId":"replace","endLine":205,"endColumn":11,"fix":{"range":[4125,4135],"text":"            "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":206,"column":9,"nodeType":null,"messageId":"insert","endLine":206,"endColumn":9,"fix":{"range":[4181,4181],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":207,"column":1,"nodeType":null,"messageId":"replace","endLine":207,"endColumn":7,"fix":{"range":[4185,4191],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":209,"column":1,"nodeType":null,"messageId":"insert","endLine":209,"endColumn":1,"fix":{"range":[4196,4196],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":210,"column":1,"nodeType":null,"messageId":"replace","endLine":210,"endColumn":9,"fix":{"range":[4229,4237],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":211,"column":9,"nodeType":null,"messageId":"insert","endLine":211,"endColumn":9,"fix":{"range":[4281,4281],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `··········` with `············`","line":212,"column":1,"nodeType":null,"messageId":"replace","endLine":212,"endColumn":11,"fix":{"range":[4316,4326],"text":"            "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":213,"column":9,"nodeType":null,"messageId":"insert","endLine":213,"endColumn":9,"fix":{"range":[4376,4376],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `······` with `········`","line":214,"column":1,"nodeType":null,"messageId":"replace","endLine":214,"endColumn":7,"fix":{"range":[4380,4386],"text":"        "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":216,"column":1,"nodeType":null,"messageId":"insert","endLine":216,"endColumn":1,"fix":{"range":[4391,4391],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `········` with `··········`","line":217,"column":1,"nodeType":null,"messageId":"replace","endLine":217,"endColumn":9,"fix":{"range":[4424,4432],"text":"          "}},{"ruleId":"prettier/prettier","severity":2,"message":"Insert `··`","line":218,"column":1,"nodeType":null,"messageId":"insert","endLine":218,"endColumn":1,"fix":{"range":[4468,4468],"text":"  "}},{"ruleId":"prettier/prettier","severity":2,"message":"Replace `row:·Record<string,·unknown>` with `⏎····row:·Record<string,·unknown>⏎··`","line":437,"column":35,"nodeType":null,"messageId":"replace","endLine":437,"endColumn":63,"fix":{"range":[10017,10045],"text":"\n    row: Record<string, unknown>\n  "}}],"suppressedMessages":[],"errorCount":32,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":32,"fixableWarningCount":0,"source":"/**\n * 数据库连接池监控工具\n * 艹，这个工具负责监控数据库性能，包括连接池状态、慢查询分析、EXPLAIN分析！\n *\n * 功能：\n * - 连接池状态监控（active/idle/waiting connections）\n * - 慢查询检测与记录（超过1秒的查询）\n * - EXPLAIN分析与优化建议\n * - 健康检查与问题诊断\n */\n\nimport { db } from '../config/database.js';\nimport logger from './logger.js';\nimport type { Knex } from 'knex';\n\n/**\n * 连接池指标\n */\nexport interface ConnectionMetrics {\n  active: number;\n  idle: number;\n  total: number;\n  waiting: number;\n}\n\n/**\n * 慢查询记录\n */\nexport interface SlowQuery {\n  sql: string;\n  params: unknown[];\n  duration: number;\n  timestamp: Date;\n}\n\n/**\n * 性能指标\n */\ninterface PerformanceMetrics {\n  slowQueries: SlowQuery[];\n  avgResponseTime: number;\n  totalQueries: number;\n  failedQueries: number;\n}\n\n/**\n * EXPLAIN分析结果\n */\nexport interface ExplainAnalysis extends Record<string, unknown> {\n  id: number;\n  select_type: string;\n  table: string;\n  type: string;\n  possible_keys: string | null;\n  key: string | null;\n  key_len: number | null;\n  ref: string | null;\n  rows: number;\n  filtered: number | null;\n  extra: string | null;\n  // 分析结果\n  queryType: string;\n  indexUsage: {\n    usingIndex: boolean;\n    efficiency: 'excellent' | 'good' | 'medium' | 'poor';\n    indexName?: string;\n    keyLen?: number;\n    reason?: string;\n  };\n  performance: {\n    level: 'excellent' | 'good' | 'fair' | 'poor';\n    estimatedRows?: number;\n    reason?: string;\n  };\n  recommendations: Array<{\n    priority: 'high' | 'medium' | 'low';\n    message: string;\n    suggestion: string;\n  }>;\n}\n\n/**\n * EXPLAIN基线查询\n */\ninterface BaselineQuery {\n  sql: string;\n  explain: ExplainAnalysis;\n  timestamp: Date;\n}\n\n/**\n * EXPLAIN指标\n */\ninterface ExplainMetrics {\n  baselineQueries: Map<number, BaselineQuery>;\n  lastAnalysis: Date | null;\n}\n\n/**\n * 连接池状态\n */\nexport interface PoolStatus extends ConnectionMetrics {\n  healthy: boolean;\n  utilization: string;\n}\n\n/**\n * 健康问题\n */\nexport interface HealthIssue {\n  type: string;\n  severity: 'high' | 'medium' | 'low';\n  message: string;\n}\n\n/**\n * 指标报告\n */\nexport interface MetricsReport {\n  timestamp: Date;\n  pool: PoolStatus;\n  performance: {\n    slowQueries: SlowQuery[];\n    avgResponseTime: number;\n    totalQueries: number;\n    failedQueries: number;\n    slowQueriesCount: number;\n  };\n  explain: {\n    baselineCount: number;\n    lastAnalysis: Date | null;\n  };\n  health: {\n    status: 'healthy' | 'warning' | 'unhealthy';\n    issues: HealthIssue[];\n  };\n}\n\n/**\n * 数据库监控指标类\n * 艹，这个类负责所有数据库性能监控！\n */\nclass DatabaseMetrics {\n  private metrics: {\n    connections: ConnectionMetrics;\n    performance: PerformanceMetrics;\n    explain: ExplainMetrics;\n  };\n\n  constructor() {\n    this.metrics = {\n      connections: {\n        active: 0,\n        idle: 0,\n        total: 0,\n        waiting: 0\n      },\n      performance: {\n        slowQueries: [],\n        avgResponseTime: 0,\n        totalQueries: 0,\n        failedQueries: 0\n      },\n      explain: {\n        baselineQueries: new Map(),\n        lastAnalysis: null\n      }\n    };\n\n    this.setupEventListeners();\n  }\n\n  /**\n   * 设置连接池事件监听\n   */\n  private setupEventListeners(): void {\n    const knexClient = db as unknown;\n    if (knexClient && typeof knexClient === 'object' && 'client' in knexClient) {\n      const client = (knexClient as { client?: { pool?: unknown } }).client;\n      if (client && 'pool' in client && client.pool) {\n        const pool = client.pool;\n\n        pool.on('acquire', (connection: unknown) => {\n        this.metrics.connections.active++;\n        this.metrics.connections.idle--;\n        logger.debug('[DB Metrics] 连接获取', {\n          active: this.metrics.connections.active,\n          idle: this.metrics.connections.idle,\n          total: this.metrics.connections.total\n        });\n      });\n\n      pool.on('release', (connection: unknown) => {\n        this.metrics.connections.active--;\n        this.metrics.connections.idle++;\n        logger.debug('[DB Metrics] 连接释放', {\n          active: this.metrics.connections.active,\n          idle: this.metrics.connections.idle\n        });\n      });\n\n      pool.on('destroy', (connection: unknown) => {\n        this.metrics.connections.total--;\n        logger.info('[DB Metrics] 连接销毁', {\n          total: this.metrics.connections.total\n        });\n      });\n\n      pool.on('enqueue', () => {\n        this.metrics.connections.waiting++;\n        logger.warn('[DB Metrics] 连接等待', {\n          waiting: this.metrics.connections.waiting\n        });\n      });\n\n      pool.on('dequeue', () => {\n        this.metrics.connections.waiting--;\n      });\n      }\n    }\n  }\n\n  /**\n   * 获取连接池状态\n   */\n  getPoolStatus(): PoolStatus {\n    const { active, idle, total, waiting } = this.metrics.connections;\n    return {\n      active,\n      idle,\n      total,\n      waiting,\n      healthy: waiting === 0,\n      utilization: total > 0 ? ((active / total) * 100).toFixed(2) + '%' : '0%'\n    };\n  }\n\n  /**\n   * 分析查询性能\n   * @param sql - SQL语句\n   * @param params - 查询参数\n   * @param duration - 执行时间（毫秒）\n   */\n  recordQuery(sql: string, params: unknown[], duration: number): void {\n    this.metrics.performance.totalQueries++;\n\n    // 更新平均响应时间\n    this.metrics.performance.avgResponseTime =\n      (this.metrics.performance.avgResponseTime * (this.metrics.performance.totalQueries - 1) +\n        duration) /\n      this.metrics.performance.totalQueries;\n\n    // 记录慢查询（超过1秒）\n    if (duration > 1000) {\n      this.metrics.performance.slowQueries.push({\n        sql: this.sanitizeSQL(sql),\n        params,\n        duration,\n        timestamp: new Date()\n      });\n\n      // 只保留最近100个慢查询\n      if (this.metrics.performance.slowQueries.length > 100) {\n        this.metrics.performance.slowQueries = this.metrics.performance.slowQueries.slice(-100);\n      }\n\n      logger.warn('[DB Metrics] 慢查询检测', {\n        sql: this.sanitizeSQL(sql),\n        duration: `${duration}ms`\n      });\n    }\n  }\n\n  /**\n   * 清理SQL语句中的敏感信息\n   * @param sql - SQL语句\n   */\n  private sanitizeSQL(sql: string): string {\n    // 移除可能的敏感数据\n    return (\n      sql\n        .replace(/'.*?'/g, \"'?\") // 替换字符串字面量\n        .replace(/\\d{4}-\\d{2}-\\d{2}/g, 'YYYY-MM-DD') // 替换日期\n        .replace(/\\b\\d{13,}\\b/g, 'BIGINT') // 替换大整数（时间戳等）\n        .substring(0, 200) + (sql.length > 200 ? '...' : '')\n    );\n  }\n\n  /**\n   * 执行EXPLAIN分析\n   * @param sql - SQL语句\n   * @param params - 查询参数\n   */\n  async analyzeQuery(sql: string, params: unknown[] = []): Promise<ExplainAnalysis> {\n    try {\n      const explainSQL = `EXPLAIN ${sql}`;\n      const result = await db.raw(explainSQL, params);\n\n      const analysis = this.analyzeExplainResult(result[0][0]);\n\n      // 存储基线结果\n      const queryHash = this.hashSQL(sql);\n      this.metrics.explain.baselineQueries.set(queryHash, {\n        sql: this.sanitizeSQL(sql),\n        explain: analysis,\n        timestamp: new Date()\n      });\n\n      this.metrics.explain.lastAnalysis = new Date();\n\n      logger.info('[DB Metrics] EXPLAIN分析完成', {\n        queryType: analysis.queryType,\n        table: analysis.table,\n        type: analysis.type,\n        rows: analysis.rows\n      });\n\n      return analysis;\n    } catch (error: unknown) {\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('[DB Metrics] EXPLAIN分析失败', {\n        sql: this.sanitizeSQL(sql),\n        error: err.message\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * 分析EXPLAIN结果\n   * @param row - EXPLAIN查询结果\n   */\n  private analyzeExplainResult(row: Record<string, unknown>): ExplainAnalysis {\n    return {\n      id: row.id,\n      select_type: row.select_type,\n      table: row.table,\n      type: row.type,\n      possible_keys: row.possible_keys,\n      key: row.key,\n      key_len: row.key_len,\n      ref: row.ref,\n      rows: row.rows,\n      filtered: row.filtered,\n      extra: row.extra,\n      // 分析结果\n      queryType: this.classifyQuery(row),\n      indexUsage: this.analyzeIndexUsage(row),\n      performance: this.analyzePerformance(row),\n      recommendations: this.generateRecommendations(row)\n    };\n  }\n\n  /**\n   * 分类查询类型\n   */\n  private classifyQuery(row: Record<string, unknown>): string {\n    const extra = row.extra || '';\n\n    if (extra.includes('Using where') && extra.includes('Using index')) {\n      return 'index-lookup';\n    } else if (extra.includes('Using filesort')) {\n      return 'filesort';\n    } else if (extra.includes('Using temporary')) {\n      return 'temporary-table';\n    } else if (row.type === 'ALL') {\n      return 'full-scan';\n    } else if (row.key) {\n      return 'index-scan';\n    } else {\n      return 'unknown';\n    }\n  }\n\n  /**\n   * 分析索引使用情况\n   */\n  private analyzeIndexUsage(row: Record<string, unknown>): ExplainAnalysis['indexUsage'] {\n    if (!row.key) {\n      return {\n        usingIndex: false,\n        efficiency: 'poor',\n        reason: 'no-index-used'\n      };\n    }\n\n    const efficiency = row.key_len ? row.key_len / this.getExpectedKeyLength(row) : 1;\n\n    return {\n      usingIndex: true,\n      efficiency:\n        efficiency > 0.8\n          ? 'excellent'\n          : efficiency > 0.5\n            ? 'good'\n            : efficiency > 0.3\n              ? 'medium'\n              : 'poor',\n      indexName: row.key,\n      keyLen: row.key_len\n    };\n  }\n\n  /**\n   * 估算期望的键长度\n   */\n  private getExpectedKeyLength(row: Record<string, unknown>): number {\n    // 简单的启发式估算\n    if (row.table === 'users') return 20;\n    if (row.table === 'tasks') return 32;\n    if (row.table === 'orders') return 32;\n    return 20;\n  }\n\n  /**\n   * 分析性能\n   */\n  private analyzePerformance(row: Record<string, unknown>): ExplainAnalysis['performance'] {\n    const estimatedRows = parseInt(row.rows) || 0;\n\n    if (estimatedRows === 0) {\n      return { level: 'excellent', reason: 'empty-result' };\n    } else if (estimatedRows < 100) {\n      return { level: 'excellent', estimatedRows };\n    } else if (estimatedRows < 1000) {\n      return { level: 'good', estimatedRows };\n    } else if (estimatedRows < 10000) {\n      return { level: 'fair', estimatedRows };\n    } else {\n      return { level: 'poor', estimatedRows };\n    }\n  }\n\n  /**\n   * 生成优化建议\n   */\n  private generateRecommendations(row: Record<string, unknown>): ExplainAnalysis['recommendations'] {\n    const recommendations: ExplainAnalysis['recommendations'] = [];\n    const extra = row.extra || '';\n\n    // 全表扫描建议\n    if (row.type === 'ALL') {\n      recommendations.push({\n        priority: 'high',\n        message: '存在全表扫描，建议添加索引',\n        suggestion: `在WHERE条件涉及的列上创建索引`\n      });\n    }\n\n    // 文件排序建议\n    if (extra.includes('Using filesort')) {\n      recommendations.push({\n        priority: 'medium',\n        message: '需要文件排序，影响性能',\n        suggestion: '在ORDER BY子句的列上创建索引或优化查询'\n      });\n    }\n\n    // 临时表建议\n    if (extra.includes('Using temporary')) {\n      recommendations.push({\n        priority: 'medium',\n        message: '使用了临时表，影响性能',\n        suggestion: '优化查询逻辑，避免临时表创建'\n      });\n    }\n\n    // 索引使用效率低\n    if (row.key && row.key_len && row.key_len < 10) {\n      recommendations.push({\n        priority: 'low',\n        message: '索引使用率可能不高',\n        suggestion: '检查索引是否被有效利用'\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * 生成SQL哈希\n   */\n  private hashSQL(sql: string): number {\n    // 简单的哈希函数\n    return sql\n      .replace(/\\s+/g, ' ')\n      .trim()\n      .split('')\n      .reduce((acc, char) => {\n        return ((acc << 5) - acc + char.charCodeAt(0)) & 0xffffffff;\n      }, 0);\n  }\n\n  /**\n   * 获取完整的指标报告\n   */\n  getMetricsReport(): MetricsReport {\n    return {\n      timestamp: new Date(),\n      pool: this.getPoolStatus(),\n      performance: {\n        ...this.metrics.performance,\n        slowQueriesCount: this.metrics.performance.slowQueries.length\n      },\n      explain: {\n        baselineCount: this.metrics.explain.baselineQueries.size,\n        lastAnalysis: this.metrics.explain.lastAnalysis\n      },\n      health: {\n        status: this.getHealthStatus(),\n        issues: this.getHealthIssues()\n      }\n    };\n  }\n\n  /**\n   * 获取健康状态\n   */\n  private getHealthStatus(): 'healthy' | 'warning' | 'unhealthy' {\n    const poolStatus = this.getPoolStatus();\n    const slowQueryRate =\n      this.metrics.performance.totalQueries > 0\n        ? (this.metrics.performance.slowQueries.length / this.metrics.performance.totalQueries) *\n          100\n        : 0;\n\n    if (poolStatus.waiting > 0 || slowQueryRate > 5) {\n      return 'unhealthy';\n    } else if (slowQueryRate > 1 || parseFloat(poolStatus.utilization) > 80) {\n      return 'warning';\n    } else {\n      return 'healthy';\n    }\n  }\n\n  /**\n   * 获取健康问题\n   */\n  private getHealthIssues(): HealthIssue[] {\n    const issues: HealthIssue[] = [];\n    const poolStatus = this.getPoolStatus();\n\n    if (poolStatus.waiting > 0) {\n      issues.push({\n        type: 'pool_waiting',\n        severity: 'high',\n        message: `有 ${poolStatus.waiting} 个连接在等待`\n      });\n    }\n\n    const slowQueryRate =\n      this.metrics.performance.totalQueries > 0\n        ? (this.metrics.performance.slowQueries.length / this.metrics.performance.totalQueries) *\n          100\n        : 0;\n\n    if (slowQueryRate > 5) {\n      issues.push({\n        type: 'slow_queries',\n        severity: 'high',\n        message: `慢查询率过高: ${slowQueryRate.toFixed(2)}%`\n      });\n    }\n\n    if (parseFloat(poolStatus.utilization) > 90) {\n      issues.push({\n        type: 'pool_utilization',\n        severity: 'medium',\n        message: `连接池利用率过高: ${poolStatus.utilization}`\n      });\n    }\n\n    return issues;\n  }\n\n  /**\n   * 获取最近的慢查询\n   */\n  public getRecentSlowQueries(limit = 20): SlowQuery[] {\n    return this.metrics.performance.slowQueries.slice(-limit);\n  }\n\n  /**\n   * 对外暴露的SQL脱敏方法\n   */\n  public publicSanitize(sql: string): string {\n    return this.sanitizeSQL(sql);\n  }\n\n  /**\n   * 对外暴露的SQL哈希方法\n   */\n  public publicHash(sql: string): number {\n    return this.hashSQL(sql);\n  }\n}\n\n// 创建全局实例\nconst dbMetrics = new DatabaseMetrics();\n\nexport default dbMetrics;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/encryption.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/utils/encryption.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare const encryptionUtils: {\n  encryptIdCard(idCard: string): string | null;\n  decryptIdCard(encryptedIdCard: string): string | null;\n  maskIdCard(idCard: string): string | null;\n  decryptAndMaskIdCard(encryptedIdCard: string): string;\n};\n\nexport default encryptionUtils;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/encryption.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/generator.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): src/utils/generator.d.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export declare function generateId(length?: number): string;\nexport declare function generateSeed(): number;\nexport declare function generateCode(length?: number): string;\nexport declare function generateOrderId(): string;\nexport declare function generateTaskId(): string;\n\ndeclare const generator: {\n  generateId: typeof generateId;\n  generateSeed: typeof generateSeed;\n  generateCode: typeof generateCode;\n  generateOrderId: typeof generateOrderId;\n  generateTaskId: typeof generateTaskId;\n};\n\nexport default generator;\n","usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/jwt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/rbac.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/redis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/response.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/ctyun/桌面/fashion-ai-saas/backend/src/utils/template.ts","messages":[{"ruleId":"prettier/prettier","severity":2,"message":"Replace `(template·as·Record<string,·unknown>)[key],·variables,·options` with `⏎··········(template·as·Record<string,·unknown>)[key],⏎··········variables,⏎··········options⏎········`","line":120,"column":40,"nodeType":null,"messageId":"replace","endLine":120,"endColumn":102,"fix":{"range":[2780,2842],"text":"\n          (template as Record<string, unknown>)[key],\n          variables,\n          options\n        "}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * 模板变量替换工具\n * 艹，这个工具只替换{{var}}，绝不允许执行任意表达式！\n * 安全第一，防止代码注入！\n */\n\n/**\n * 变量替换选项\n */\nexport interface TemplateOptions {\n  /** 是否对未找到的变量抛出错误（默认false，替换为空字符串） */\n  throwOnMissing?: boolean;\n  /** 是否转义HTML特殊字符（默认true） */\n  escapeHtml?: boolean;\n}\n\n/**\n * 从对象中提取嵌套值\n * 支持点路径，如：user.profile.name\n * @param obj - 数据对象\n * @param path - 点路径\n * @returns 提取的值，不存在返回undefined\n */\nexport function extractValue(obj: unknown, path: string): unknown {\n  if (!obj || typeof obj !== 'object') {\n    return undefined;\n  }\n\n  // 艹，支持点路径（如 user.profile.name）\n  const keys = path.split('.');\n  let result = obj;\n\n  for (const key of keys) {\n    if (result == null || typeof result !== 'object') {\n      return undefined;\n    }\n    result = result[key];\n  }\n\n  return result;\n}\n\n/**\n * HTML转义（防止XSS）\n * @param str - 输入字符串\n * @returns 转义后的字符串\n */\nexport function escapeHtml(str: string): string {\n  const htmlEscapeMap: Record<string, string> = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;'\n  };\n\n  return String(str).replace(/[&<>\"'\\/]/g, (match) => htmlEscapeMap[match]);\n}\n\n/**\n * 模板变量替换\n * 仅替换{{var}}格式的占位符，不支持表达式执行\n *\n * @param template - 模板字符串（可以是字符串、对象或数组）\n * @param variables - 变量对象\n * @param options - 替换选项\n * @returns 替换后的结果\n *\n * @example\n * ```typescript\n * const template = \"Hello {{user.name}}, your age is {{user.age}}\";\n * const variables = { user: { name: \"老王\", age: 35 } };\n * const result = replaceVariables(template, variables);\n * // => \"Hello 老王, your age is 35\"\n * ```\n */\nexport function replaceVariables(\n  template: unknown,\n  variables: Record<string, unknown>,\n  options: TemplateOptions = {}\n): unknown {\n  const { throwOnMissing = false, escapeHtml: shouldEscape = false } = options;\n\n  // 艹，如果template是字符串，直接替换\n  if (typeof template === 'string') {\n    // 匹配 {{varName}} 格式，不允许空格和特殊字符（安全考虑）\n    return template.replace(/\\{\\{([a-zA-Z0-9_.]+)\\}\\}/g, (match, varPath) => {\n      const value = extractValue(variables, varPath);\n\n      if (value === undefined || value === null) {\n        if (throwOnMissing) {\n          throw new Error(`变量 \"${varPath}\" 未定义`);\n        }\n        return ''; // 默认替换为空字符串\n      }\n\n      // 转换为字符串\n      let result = String(value);\n\n      // 可选的HTML转义\n      if (shouldEscape) {\n        result = escapeHtml(result);\n      }\n\n      return result;\n    });\n  }\n\n  // 如果template是数组，递归替换每个元素\n  if (Array.isArray(template)) {\n    return template.map((item) => replaceVariables(item, variables, options));\n  }\n\n  // 如果template是对象，递归替换每个值\n  if (template !== null && typeof template === 'object') {\n    const result: Record<string, unknown> = {};\n    for (const key in template) {\n      if ((template as Record<string, unknown>).hasOwnProperty(key)) {\n        result[key] = replaceVariables((template as Record<string, unknown>)[key], variables, options);\n      }\n    }\n    return result;\n  }\n\n  // 其他类型（数字、布尔等）直接返回\n  return template;\n}\n\n/**\n * 检查模板中的变量引用\n * 返回所有{{var}}引用的变量名列表\n * @param template - 模板字符串或对象\n * @returns 变量名数组\n */\nexport function extractVariableReferences(template: unknown): string[] {\n  const references = new Set<string>();\n\n  function scan(value: unknown): void {\n    if (typeof value === 'string') {\n      // 匹配所有 {{varName}}\n      const matches = value.matchAll(/\\{\\{([a-zA-Z0-9_.]+)\\}\\}/g);\n      for (const match of matches) {\n        references.add(match[1]);\n      }\n    } else if (Array.isArray(value)) {\n      value.forEach(scan);\n    } else if (value !== null && typeof value === 'object') {\n      Object.values(value).forEach(scan);\n    }\n  }\n\n  scan(template);\n  return Array.from(references);\n}\n\n/**\n * 验证模板中的所有变量是否已定义\n * @param template - 模板字符串或对象\n * @param variables - 变量对象\n * @returns 缺失的变量名数组，如果全部存在则返回空数组\n */\nexport function validateVariables(template: unknown, variables: Record<string, unknown>): string[] {\n  const references = extractVariableReferences(template);\n  const missing: string[] = [];\n\n  for (const varPath of references) {\n    const value = extractValue(variables, varPath);\n    if (value === undefined || value === null) {\n      missing.push(varPath);\n    }\n  }\n\n  return missing;\n}\n","usedDeprecatedRules":[]}]
