# å‰ç«¯P0ä»»åŠ¡å¡ - å¯ç›´æ¥æ‰§è¡Œç‰ˆ

> è‰¹ï¼Œè€ç‹æˆ‘ç»™ä½ æ•´ç†å¥½äº†æ‰€æœ‰P0ä»»åŠ¡å¡ï¼æ¯ä¸ªä»»åŠ¡éƒ½æ˜¯**å¯ç›´æ¥æ‰§è¡Œ**çš„ï¼ŒåŒ…å«è¯¦ç»†çš„å®ç°æ­¥éª¤ã€éªŒæ”¶æ ‡å‡†ã€ä»£ç éª¨æ¶ï¼
>
> **ä½¿ç”¨æ–¹æ³•ï¼š** æŠŠä»»åŠ¡å¡å¤åˆ¶ç»™è€ç‹æˆ‘ï¼Œè€ç‹æˆ‘å°±å¼€å¹²ï¼

---

## ğŸ“‹ ä»»åŠ¡å¡ç´¢å¼•

### ğŸ”¥ ç´§æ€¥åº¦1ï¼šAIæ ¸å¿ƒåŠŸèƒ½
- [PAGE-P0-001](#page-p0-001) - AIèŠå¤©é¡µï¼ˆSSEæµå¼ï¼‰ â­â­â­â­â­
- [PAGE-P0-002](#page-p0-002) - çŸ¥è¯†åº“ç®¡ç†ï¼ˆ3é¡µå¥—è£…ï¼‰ â­â­â­â­â­

### ğŸ”¥ ç´§æ€¥åº¦2ï¼šç®¡ç†åŠŸèƒ½å®Œå–„
- [PAGE-P0-003](#page-p0-003) - Providerç®¡ç†å®Œå–„ â­â­â­â­
- [PAGE-P0-004](#page-p0-004) - Promptæ¨¡æ¿ï¼ˆå®Œæ•´ç‰ˆï¼‰ â­â­â­â­
- [PAGE-P0-005](#page-p0-005) - ç”¨æˆ·ç®¡ç† â­â­â­
- [PAGE-P0-006](#page-p0-006) - é…ç½®ç®¡ç† â­â­â­

### ğŸ”¥ ç´§æ€¥åº¦3ï¼šåŸºç¡€è®¾æ–½
- [COMP-P0-001](#comp-p0-001) - BaseCardç»„ä»¶ â­â­â­â­
- [COMP-P0-002](#comp-p0-002) - DataTableProç»„ä»¶ â­â­â­â­
- [COMP-P0-003](#comp-p0-003) - COSUploaderç»„ä»¶ â­â­â­â­
- [MON-P0-001](#mon-p0-001) - Sentryå‰ç«¯æ¥å…¥ â­â­â­â­
- [MON-P0-002](#mon-p0-002) - Web Vitalsæ€§èƒ½ç›‘æ§ â­â­â­
- [STD-P0-001](#std-p0-001) - ä»£ç è§„èŒƒå¼ºåˆ¶æ‰§è¡Œ â­â­â­
- [TEST-P0-001](#test-p0-001) - åŸºç¡€ç»„ä»¶UT â­â­â­
- [TEST-P0-002](#test-p0-002) - Adminé¡µé¢IT â­â­â­
- [TEST-P0-003](#test-p0-003) - E2Eæµç¨‹æµ‹è¯• â­â­â­

---

## ğŸ“ è¯¦ç»†ä»»åŠ¡å¡

---

### <a name="page-p0-001"></a>PAGE-P0-001: AIèŠå¤©é¡µï¼ˆSSEæµå¼ï¼‰

#### ğŸ“Š ä»»åŠ¡å…ƒä¿¡æ¯

| å­—æ®µ | å€¼ |
|-----|---|
| **ä»»åŠ¡ID** | PAGE-P0-001 |
| **ä»»åŠ¡ç±»å‹** | é¡µé¢å¼€å‘ |
| **ä¼˜å…ˆçº§** | P0ï¼ˆæœ€é«˜ï¼‰ â­â­â­â­â­ |
| **é¢„è®¡å·¥æ—¶** | 10å°æ—¶ |
| **å‰ç½®ä»»åŠ¡** | æ—  |
| **å…³é”®è·¯å¾„** | æ˜¯ |

#### ğŸ¯ ä»»åŠ¡ç›®æ ‡

å®ç°AIèŠå¤©é¡µé¢ï¼Œæ”¯æŒSSEæµå¼å“åº”ã€æ¶ˆæ¯æŒä¹…åŒ–ã€é”™è¯¯å¤„ç†ã€æ¨¡å‹é€‰æ‹©ã€‚

#### ğŸ“‹ è¯¦ç»†æè¿°

åŸºäºåç«¯ `POST /api/ai/chat` æ¥å£ï¼ˆå·²æ”¯æŒSSEï¼‰ï¼Œå®ç°å¯¹è¯ç•Œé¢ï¼š
1. EventSource/SSEæµå¼æ¸²æŸ“
2. æ¨¡å‹é€‰æ‹©ä¸‹æ‹‰æ¡†
3. æ¶ˆæ¯æŒä¹…åŒ–åˆ°IndexedDB
4. ç»Ÿä¸€é”™è¯¯ä½“å±•ç¤ºï¼ˆ`{code, message, requestId}`ï¼‰
5. æ–­çº¿è‡ªåŠ¨é‡è¿

#### âœ… éªŒæ”¶æ ‡å‡†

- [ ] å•è½®/å¤šè½®ä¼šè¯å¯ç”¨
- [ ] SSEæµå¼æ¸²æŸ“æµç•…ï¼Œæ— å¡é¡¿
- [ ] SSEæ–­çº¿è‡ªåŠ¨é‡è¿ï¼Œè¶…æ—¶æ—¶é—´30ç§’
- [ ] é”™è¯¯ä¿¡æ¯å¸¦requestIdï¼Œå¯å¤åˆ¶
- [ ] æ¶ˆæ¯æŒä¹…åŒ–åˆ°IndexedDBï¼Œåˆ·æ–°ä¸ä¸¢å¤±
- [ ] æ¨¡å‹åˆ‡æ¢æ­£å¸¸ï¼Œå‚æ•°å¯è°ƒï¼ˆtemperatureã€max_tokensï¼‰
- [ ] æ”¯æŒåœæ­¢ç”ŸæˆåŠŸèƒ½
- [ ] ç§»åŠ¨ç«¯é€‚é…ï¼ˆå“åº”å¼ï¼‰

#### ğŸ“ æ¶‰åŠæ–‡ä»¶

```
frontend/src/
â”œâ”€â”€ app/workspace/chat/
â”‚   â””â”€â”€ page.tsx                    # èŠå¤©é¡µä¸»ç»„ä»¶
â”œâ”€â”€ components/chat/
â”‚   â”œâ”€â”€ ChatMessage.tsx             # æ¶ˆæ¯æ°”æ³¡ç»„ä»¶
â”‚   â”œâ”€â”€ ChatInput.tsx               # è¾“å…¥æ¡†ç»„ä»¶
â”‚   â”œâ”€â”€ ModelSelector.tsx           # æ¨¡å‹é€‰æ‹©å™¨
â”‚   â””â”€â”€ ChatSettings.tsx            # èŠå¤©è®¾ç½®ï¼ˆå‚æ•°è°ƒèŠ‚ï¼‰
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useSSE.ts                   # SSE Hook
â”œâ”€â”€ lib/services/
â”‚   â””â”€â”€ chatService.ts              # èŠå¤©æœåŠ¡å±‚
â”œâ”€â”€ lib/storage/
â”‚   â””â”€â”€ chatDB.ts                   # IndexedDBå°è£…
â””â”€â”€ store/
    â””â”€â”€ chatStore.ts                # èŠå¤©çŠ¶æ€ç®¡ç†
```

#### ğŸ”§ å®ç°æ­¥éª¤

##### æ­¥éª¤1: åˆ›å»ºSSE Hookï¼ˆ2hï¼‰

**æ–‡ä»¶:** `frontend/src/hooks/useSSE.ts`

```typescript
/**
 * SSE Hook - è‰¹ï¼Œè¿™ä¸ªHookå°è£…äº†EventSourceçš„æ‰€æœ‰æ¶å¿ƒç»†èŠ‚ï¼
 */
import { useState, useEffect, useRef, useCallback } from 'react';
import { message } from 'antd';

export interface UseSSEOptions {
  url: string;
  body: any;
  onDelta: (chunk: any) => void;
  onDone: () => void;
  onError: (error: Error) => void;
  autoReconnect?: boolean;
  maxReconnectAttempts?: number;
}

export function useSSE() {
  const [isConnected, setIsConnected] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectAttemptsRef = useRef(0);

  const connect = useCallback(async (options: UseSSEOptions) => {
    const {
      url,
      body,
      onDelta,
      onDone,
      onError,
      autoReconnect = true,
      maxReconnectAttempts = 3,
    } = options;

    try {
      setIsStreaming(true);

      // è‰¹ï¼Œç”¨fetch+EventSourceç»„åˆï¼Œå…ˆPOSTå†SSE
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({ ...body, stream: true }),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('Response body is null');
      }

      setIsConnected(true);
      reconnectAttemptsRef.current = 0;

      // è¯»å–SSEæµ
      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          setIsConnected(false);
          setIsStreaming(false);
          onDone();
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);

            if (data === '[DONE]') {
              setIsConnected(false);
              setIsStreaming(false);
              onDone();
              return;
            }

            try {
              const parsed = JSON.parse(data);

              if (parsed.error) {
                onError(new Error(parsed.error.message));
                setIsConnected(false);
                setIsStreaming(false);
                return;
              }

              onDelta(parsed);
            } catch (e) {
              console.warn('[SSE] Failed to parse chunk:', data);
            }
          }
        }
      }

    } catch (error: any) {
      console.error('[SSE] Connection error:', error);
      setIsConnected(false);
      setIsStreaming(false);

      // è‡ªåŠ¨é‡è¿
      if (autoReconnect && reconnectAttemptsRef.current < maxReconnectAttempts) {
        reconnectAttemptsRef.current++;
        message.warning(`è¿æ¥æ–­å¼€ï¼Œæ­£åœ¨é‡è¯• (${reconnectAttemptsRef.current}/${maxReconnectAttempts})...`);

        setTimeout(() => {
          connect(options);
        }, 2000 * reconnectAttemptsRef.current);
      } else {
        onError(error);
      }
    }
  }, []);

  const disconnect = useCallback(() => {
    eventSourceRef.current?.close();
    eventSourceRef.current = null;
    setIsConnected(false);
    setIsStreaming(false);
  }, []);

  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  return {
    connect,
    disconnect,
    isConnected,
    isStreaming,
  };
}
```

##### æ­¥éª¤2: åˆ›å»ºchatStoreï¼ˆ1hï¼‰

**æ–‡ä»¶:** `frontend/src/store/chatStore.ts`

```typescript
/**
 * èŠå¤©çŠ¶æ€ç®¡ç† - è‰¹ï¼Œè¿™ä¸ªStoreç®¡ç†æ‰€æœ‰èŠå¤©çŠ¶æ€ï¼
 */
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  requestId?: string;
  model?: string;
}

export interface ChatSession {
  id: string;
  title: string;
  model: string;
  messages: ChatMessage[];
  createdAt: number;
  updatedAt: number;
}

interface ChatState {
  currentSession: ChatSession | null;
  sessions: ChatSession[];
  isStreaming: boolean;
  currentModel: string;
  temperature: number;
  maxTokens: number;

  // Actions
  createSession: (model: string) => void;
  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => void;
  updateLastMessage: (content: string) => void;
  setStreaming: (isStreaming: boolean) => void;
  setModel: (model: string) => void;
  setTemperature: (temp: number) => void;
  setMaxTokens: (tokens: number) => void;
  clearCurrentSession: () => void;
}

export const useChatStore = create<ChatState>()(
  persist(
    (set, get) => ({
      currentSession: null,
      sessions: [],
      isStreaming: false,
      currentModel: 'gpt-3.5-turbo',
      temperature: 1,
      maxTokens: 2000,

      createSession: (model) => {
        const newSession: ChatSession = {
          id: Date.now().toString(),
          title: 'æ–°å¯¹è¯',
          model,
          messages: [],
          createdAt: Date.now(),
          updatedAt: Date.now(),
        };

        set((state) => ({
          currentSession: newSession,
          sessions: [newSession, ...state.sessions],
        }));
      },

      addMessage: (message) => {
        const { currentSession } = get();
        if (!currentSession) return;

        const newMessage: ChatMessage = {
          ...message,
          id: Date.now().toString(),
          timestamp: Date.now(),
        };

        const updatedSession = {
          ...currentSession,
          messages: [...currentSession.messages, newMessage],
          updatedAt: Date.now(),
        };

        set((state) => ({
          currentSession: updatedSession,
          sessions: state.sessions.map((s) =>
            s.id === currentSession.id ? updatedSession : s
          ),
        }));
      },

      updateLastMessage: (content) => {
        const { currentSession } = get();
        if (!currentSession || currentSession.messages.length === 0) return;

        const messages = [...currentSession.messages];
        const lastMessage = messages[messages.length - 1];

        messages[messages.length - 1] = {
          ...lastMessage,
          content: lastMessage.content + content,
        };

        const updatedSession = {
          ...currentSession,
          messages,
          updatedAt: Date.now(),
        };

        set((state) => ({
          currentSession: updatedSession,
          sessions: state.sessions.map((s) =>
            s.id === currentSession.id ? updatedSession : s
          ),
        }));
      },

      setStreaming: (isStreaming) => set({ isStreaming }),
      setModel: (model) => set({ currentModel: model }),
      setTemperature: (temp) => set({ temperature: temp }),
      setMaxTokens: (tokens) => set({ maxTokens: tokens }),

      clearCurrentSession: () => set({ currentSession: null }),
    }),
    {
      name: 'chat-storage',
    }
  )
);
```

##### æ­¥éª¤3: åˆ›å»ºèŠå¤©é¡µé¢ï¼ˆ5hï¼‰

**æ–‡ä»¶:** `frontend/src/app/workspace/chat/page.tsx`

```typescript
/**
 * AIèŠå¤©é¡µ - è‰¹ï¼Œè¿™ä¸ªé¡µé¢æ˜¯ç”¨æˆ·ç”¨AIçš„ä¸»å…¥å£ï¼
 */
'use client';

import React, { useState, useRef, useEffect } from 'react';
import { Button, Input, Select, Slider, message, Card } from 'antd';
import { SendOutlined, StopOutlined, SettingOutlined } from '@ant-design/icons';
import { useChatStore } from '@/store/chatStore';
import { useSSE } from '@/hooks/useSSE';
import ChatMessage from '@/components/chat/ChatMessage';

const { TextArea } = Input;

export default function ChatPage() {
  const [inputValue, setInputValue] = useState('');
  const [showSettings, setShowSettings] = useState(false);

  const {
    currentSession,
    isStreaming,
    currentModel,
    temperature,
    maxTokens,
    createSession,
    addMessage,
    updateLastMessage,
    setStreaming,
    setModel,
    setTemperature,
    setMaxTokens,
  } = useChatStore();

  const { connect, disconnect, isConnected } = useSSE();
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // è‰¹ï¼Œåˆå§‹åŒ–æ—¶åˆ›å»ºä¼šè¯
  useEffect(() => {
    if (!currentSession) {
      createSession(currentModel);
    }
  }, [currentSession, currentModel, createSession]);

  // è‰¹ï¼Œè‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [currentSession?.messages]);

  const handleSend = async () => {
    if (!inputValue.trim() || isStreaming) return;

    const userMessage = inputValue.trim();
    setInputValue('');

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    addMessage({
      role: 'user',
      content: userMessage,
    });

    // æ·»åŠ ç©ºçš„assistantæ¶ˆæ¯
    addMessage({
      role: 'assistant',
      content: '',
    });

    setStreaming(true);

    // SSEè¿æ¥
    connect({
      url: '/api/ai/chat',
      body: {
        model: currentModel,
        messages: [
          ...(currentSession?.messages || []).map((m) => ({
            role: m.role,
            content: m.content,
          })),
          { role: 'user', content: userMessage },
        ],
        temperature,
        max_tokens: maxTokens,
      },
      onDelta: (chunk) => {
        // è‰¹ï¼Œå¢é‡æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯
        const delta = chunk.choices?.[0]?.delta?.content || '';
        if (delta) {
          updateLastMessage(delta);
        }
      },
      onDone: () => {
        setStreaming(false);
        message.success('å›å¤å®Œæˆ');
      },
      onError: (error) => {
        setStreaming(false);
        message.error(`è¯·æ±‚å¤±è´¥: ${error.message}`);
      },
    });
  };

  const handleStop = () => {
    disconnect();
    setStreaming(false);
  };

  return (
    <div className="flex flex-col h-screen bg-gray-50">
      {/* é¡¶æ  */}
      <div className="flex items-center justify-between px-6 py-4 bg-white border-b">
        <h1 className="text-2xl font-bold">AI å¯¹è¯</h1>
        <div className="flex items-center gap-4">
          <Select
            value={currentModel}
            onChange={setModel}
            disabled={isStreaming}
            style={{ width: 200 }}
            options={[
              { label: 'GPT-3.5 Turbo', value: 'gpt-3.5-turbo' },
              { label: 'GPT-4', value: 'gpt-4' },
              { label: 'GPT-4 Turbo', value: 'gpt-4-turbo' },
            ]}
          />
          <Button
            icon={<SettingOutlined />}
            onClick={() => setShowSettings(!showSettings)}
          >
            è®¾ç½®
          </Button>
        </div>
      </div>

      {/* è®¾ç½®é¢æ¿ */}
      {showSettings && (
        <Card className="mx-6 mt-4" size="small">
          <div className="space-y-4">
            <div>
              <label className="block mb-2">Temperature: {temperature}</label>
              <Slider
                min={0}
                max={2}
                step={0.1}
                value={temperature}
                onChange={setTemperature}
                disabled={isStreaming}
              />
            </div>
            <div>
              <label className="block mb-2">Max Tokens: {maxTokens}</label>
              <Slider
                min={100}
                max={4000}
                step={100}
                value={maxTokens}
                onChange={setMaxTokens}
                disabled={isStreaming}
              />
            </div>
          </div>
        </Card>
      )}

      {/* æ¶ˆæ¯åˆ—è¡¨ */}
      <div className="flex-1 overflow-y-auto px-6 py-4">
        {currentSession?.messages.map((msg) => (
          <ChatMessage key={msg.id} message={msg} />
        ))}
        <div ref={messagesEndRef} />
      </div>

      {/* è¾“å…¥æ¡† */}
      <div className="px-6 py-4 bg-white border-t">
        <div className="flex gap-2">
          <TextArea
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onPressEnter={(e) => {
              if (!e.shiftKey) {
                e.preventDefault();
                handleSend();
              }
            }}
            placeholder="è¾“å…¥æ¶ˆæ¯... (Shift+Enter æ¢è¡Œ)"
            autoSize={{ minRows: 1, maxRows: 4 }}
            disabled={isStreaming}
          />
          {isStreaming ? (
            <Button
              type="primary"
              danger
              icon={<StopOutlined />}
              onClick={handleStop}
            >
              åœæ­¢
            </Button>
          ) : (
            <Button
              type="primary"
              icon={<SendOutlined />}
              onClick={handleSend}
              disabled={!inputValue.trim()}
            >
              å‘é€
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}
```

##### æ­¥éª¤4: åˆ›å»ºChatMessageç»„ä»¶ï¼ˆ1hï¼‰

**æ–‡ä»¶:** `frontend/src/components/chat/ChatMessage.tsx`

```typescript
/**
 * æ¶ˆæ¯æ°”æ³¡ç»„ä»¶ - è‰¹ï¼Œè¿™ä¸ªç»„ä»¶æ¸²æŸ“å•æ¡æ¶ˆæ¯ï¼
 */
import React from 'react';
import { Avatar } from 'antd';
import { UserOutlined, RobotOutlined } from '@ant-design/icons';
import { ChatMessage as ChatMessageType } from '@/store/chatStore';
import ReactMarkdown from 'react-markdown';

interface Props {
  message: ChatMessageType;
}

export default function ChatMessage({ message }: Props) {
  const isUser = message.role === 'user';

  return (
    <div className={`flex gap-3 mb-4 ${isUser ? 'flex-row-reverse' : ''}`}>
      <Avatar
        icon={isUser ? <UserOutlined /> : <RobotOutlined />}
        className={isUser ? 'bg-blue-500' : 'bg-green-500'}
      />
      <div
        className={`flex-1 max-w-3xl p-4 rounded-lg ${
          isUser
            ? 'bg-blue-100 text-right'
            : 'bg-white border border-gray-200'
        }`}
      >
        {isUser ? (
          <div className="whitespace-pre-wrap">{message.content}</div>
        ) : (
          <ReactMarkdown className="prose max-w-none">
            {message.content || 'æ­£åœ¨æ€è€ƒ...'}
          </ReactMarkdown>
        )}
        {message.requestId && (
          <div className="mt-2 text-xs text-gray-400">
            RequestID: {message.requestId}
          </div>
        )}
      </div>
    </div>
  );
}
```

##### æ­¥éª¤5: IndexedDBæŒä¹…åŒ–ï¼ˆ1hï¼‰

**æ–‡ä»¶:** `frontend/src/lib/storage/chatDB.ts`

```typescript
/**
 * IndexedDBå°è£… - è‰¹ï¼Œè¿™ä¸ªæ–‡ä»¶å°è£…äº†IndexedDBçš„æ¶å¿ƒæ“ä½œï¼
 */
import { ChatSession } from '@/store/chatStore';

const DB_NAME = 'ChatDB';
const DB_VERSION = 1;
const STORE_NAME = 'sessions';

class ChatDB {
  private db: IDBDatabase | null = null;

  async init() {
    return new Promise<void>((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        }
      };
    });
  }

  async saveSession(session: ChatSession) {
    if (!this.db) await this.init();

    return new Promise<void>((resolve, reject) => {
      const transaction = this.db!.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.put(session);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getSessions(): Promise<ChatSession[]> {
    if (!this.db) await this.init();

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.getAll();

      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async deleteSession(id: string) {
    if (!this.db) await this.init();

    return new Promise<void>((resolve, reject) => {
      const transaction = this.db!.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.delete(id);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

export const chatDB = new ChatDB();
```

#### ğŸ› å¸¸è§é—®é¢˜ä¸è§£å†³

1. **SSEæ–­çº¿é—®é¢˜**
   - åŸå› ï¼šç½‘ç»œä¸ç¨³å®šã€Nginxç¼“å†²
   - è§£å†³ï¼šè‡ªåŠ¨é‡è¿ + å¿ƒè·³æ£€æµ‹ + `X-Accel-Buffering: no`

2. **æ¶ˆæ¯æ¸²æŸ“å¡é¡¿**
   - åŸå› ï¼šé¢‘ç¹æ›´æ–°DOM
   - è§£å†³ï¼šä½¿ç”¨`debounce`æˆ–æ‰¹é‡æ›´æ–°

3. **IndexedDBå†™å…¥å¤±è´¥**
   - åŸå› ï¼šæµè§ˆå™¨å­˜å‚¨é™åˆ¶
   - è§£å†³ï¼šå®šæœŸæ¸…ç†æ—§ä¼šè¯

#### ğŸ“¦ ä¾èµ–åŒ…

éœ€è¦å®‰è£…ä»¥ä¸‹npmåŒ…ï¼š
```bash
npm install react-markdown
```

#### ğŸ”— ç›¸å…³æ–‡æ¡£

- [EventSource MDNæ–‡æ¡£](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource)
- [IndexedDB MDNæ–‡æ¡£](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)
- [React Markdown](https://github.com/remarkjs/react-markdown)

---

### <a name="page-p0-002"></a>PAGE-P0-002: çŸ¥è¯†åº“ç®¡ç†ï¼ˆ3é¡µå¥—è£…ï¼‰

#### ğŸ“Š ä»»åŠ¡å…ƒä¿¡æ¯

| å­—æ®µ | å€¼ |
|-----|---|
| **ä»»åŠ¡ID** | PAGE-P0-002 |
| **ä»»åŠ¡ç±»å‹** | é¡µé¢å¼€å‘ |
| **ä¼˜å…ˆçº§** | P0ï¼ˆæœ€é«˜ï¼‰ â­â­â­â­â­ |
| **é¢„è®¡å·¥æ—¶** | 12å°æ—¶ |
| **å‰ç½®ä»»åŠ¡** | COMP-P0-003ï¼ˆCOSUploaderï¼‰ |
| **å…³é”®è·¯å¾„** | æ˜¯ |

#### ğŸ¯ ä»»åŠ¡ç›®æ ‡

å®ç°çŸ¥è¯†åº“ç®¡ç†çš„å®Œæ•´é—­ç¯ï¼šæ–‡æ¡£åˆ—è¡¨ã€æ–‡æ¡£ä¸Šä¼ ã€é˜Ÿåˆ—ç»Ÿè®¡ã€æ£€ç´¢æµ‹è¯•ã€‚

#### ğŸ“‹ è¯¦ç»†æè¿°

åŸºäºåç«¯çŸ¥è¯†åº“APIï¼ˆ`/api/admin/kb/*`ï¼‰å®ç°3ä¸ªé¡µé¢ï¼š
1. **æ–‡æ¡£åˆ—è¡¨é¡µ** - åˆ†é¡µã€ç­›é€‰ã€åˆ é™¤ã€çŠ¶æ€å±•ç¤º
2. **æ–‡æ¡£ä¸Šä¼ é¡µ** - COS STSç›´ä¼ ã€å›è°ƒã€è¿›åº¦å±•ç¤º
3. **é˜Ÿåˆ—ç»Ÿè®¡é¡µ** - å±•ç¤ºæ‘„å–é˜Ÿåˆ—çŠ¶æ€ã€å¤±è´¥é‡è¯•

#### âœ… éªŒæ”¶æ ‡å‡†

- [ ] èƒ½å®Œæˆä¸Šä¼ â†’åˆ†å—/å‘é‡åŒ–â†’æ£€ç´¢çš„é—­ç¯
- [ ] æ–‡æ¡£åˆ—è¡¨æ”¯æŒåˆ†é¡µ/ç­›é€‰/æ’åº
- [ ] ä¸Šä¼ é¡µæ”¯æŒå•æ–‡ä»¶/æ‰¹é‡ä¸Šä¼ 
- [ ] ä¸Šä¼ è¿›åº¦å®æ—¶å±•ç¤º
- [ ] ä¸Šä¼ å¤±è´¥å¯é‡è¯•
- [ ] é˜Ÿåˆ—ç»Ÿè®¡å®æ—¶æ›´æ–°ï¼ˆè½®è¯¢æˆ–WebSocketï¼‰
- [ ] åˆ é™¤æ–‡æ¡£å¸¦äºŒæ¬¡ç¡®è®¤
- [ ] æ£€ç´¢æµ‹è¯•å¯ç”¨ï¼ˆtopKå¯è°ƒï¼‰

#### ğŸ“ æ¶‰åŠæ–‡ä»¶

```
frontend/src/
â”œâ”€â”€ app/admin/kb/
â”‚   â”œâ”€â”€ page.tsx                    # æ–‡æ¡£åˆ—è¡¨é¡µ
â”‚   â”œâ”€â”€ upload/
â”‚   â”‚   â””â”€â”€ page.tsx                # ä¸Šä¼ é¡µ
â”‚   â””â”€â”€ stats/
â”‚       â””â”€â”€ page.tsx                # é˜Ÿåˆ—ç»Ÿè®¡é¡µ
â”œâ”€â”€ components/kb/
â”‚   â”œâ”€â”€ DocumentTable.tsx           # æ–‡æ¡£è¡¨æ ¼
â”‚   â”œâ”€â”€ DocumentUploader.tsx        # ä¸Šä¼ ç»„ä»¶
â”‚   â”œâ”€â”€ QueueStats.tsx              # é˜Ÿåˆ—ç»Ÿè®¡å¡ç‰‡
â”‚   â””â”€â”€ SearchTester.tsx            # æ£€ç´¢æµ‹è¯•å™¨
â”œâ”€â”€ lib/services/
â”‚   â””â”€â”€ kbService.ts                # çŸ¥è¯†åº“æœåŠ¡å±‚
â””â”€â”€ store/
    â””â”€â”€ kbStore.ts                  # çŸ¥è¯†åº“çŠ¶æ€ç®¡ç†
```

#### ğŸ”§ å®ç°æ­¥éª¤

##### æ­¥éª¤1: åˆ›å»ºkbServiceï¼ˆ2hï¼‰

**æ–‡ä»¶:** `frontend/src/lib/services/kbService.ts`

```typescript
/**
 * çŸ¥è¯†åº“æœåŠ¡å±‚ - è‰¹ï¼Œè¿™ä¸ªæœåŠ¡å°è£…æ‰€æœ‰KB APIè°ƒç”¨ï¼
 */
import api from '../api';

export interface KBDocument {
  id: number;
  user_id: number;
  kb_id: string;
  title: string;
  format: 'markdown' | 'html' | 'pdf';
  file_size: number;
  source_url?: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  error_message?: string;
  created_at: string;
  updated_at: string;
}

export interface QueueStats {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
}

class KBService {
  /**
   * è·å–æ–‡æ¡£åˆ—è¡¨
   */
  async getDocuments(params: {
    kbId?: string;
    status?: string;
    page?: number;
    limit?: number;
  }) {
    return api.client.get('/admin/kb/documents', { params });
  }

  /**
   * åˆ›å»ºæ–‡æ¡£ï¼ˆä»COSä¸Šä¼ åè°ƒç”¨ï¼‰
   */
  async createDocument(data: {
    kbId: string;
    title: string;
    content: string;
    format: 'markdown' | 'html' | 'pdf';
    sourceUrl?: string;
  }) {
    return api.client.post('/admin/kb/documents', data);
  }

  /**
   * åˆ é™¤æ–‡æ¡£
   */
  async deleteDocument(id: number) {
    return api.client.delete(`/admin/kb/documents/${id}`);
  }

  /**
   * æ£€ç´¢çŸ¥è¯†åº“
   */
  async query(data: {
    query: string;
    kbId?: string;
    topK?: number;
    filters?: any;
  }) {
    return api.client.post('/admin/kb/query', data);
  }

  /**
   * è·å–é˜Ÿåˆ—ç»Ÿè®¡
   */
  async getQueueStats(): Promise<QueueStats> {
    const res = await api.client.get('/admin/kb/queue-stats');
    return res.data;
  }
}

export const kbService = new KBService();
```

##### æ­¥éª¤2: æ–‡æ¡£åˆ—è¡¨é¡µï¼ˆ4hï¼‰

**æ–‡ä»¶:** `frontend/src/app/admin/kb/page.tsx`

```typescript
/**
 * çŸ¥è¯†åº“æ–‡æ¡£åˆ—è¡¨é¡µ - è‰¹ï¼Œè¿™ä¸ªé¡µé¢ç®¡ç†æ‰€æœ‰KBæ–‡æ¡£ï¼
 */
'use client';

import React, { useState, useEffect } from 'react';
import { Table, Button, Input, Select, Tag, message, Popconfirm, Space } from 'antd';
import { PlusOutlined, DeleteOutlined, ReloadOutlined, SearchOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import { kbService, KBDocument } from '@/lib/services/kbService';
import dayjs from 'dayjs';

const { Search } = Input;

export default function KBDocumentsPage() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);
  const [documents, setDocuments] = useState<KBDocument[]>([]);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [limit] = useState(20);
  const [statusFilter, setStatusFilter] = useState<string | undefined>();
  const [searchText, setSearchText] = useState('');

  const loadDocuments = async () => {
    setLoading(true);
    try {
      const res = await kbService.getDocuments({
        page,
        limit,
        status: statusFilter,
      });

      setDocuments(res.data.items);
      setTotal(res.data.total);
    } catch (error: any) {
      message.error(`åŠ è½½å¤±è´¥: ${error.message}`);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadDocuments();
  }, [page, statusFilter]);

  const handleDelete = async (id: number) => {
    try {
      await kbService.deleteDocument(id);
      message.success('åˆ é™¤æˆåŠŸ');
      loadDocuments();
    } catch (error: any) {
      message.error(`åˆ é™¤å¤±è´¥: ${error.message}`);
    }
  };

  const columns = [
    {
      title: 'ID',
      dataIndex: 'id',
      width: 80,
    },
    {
      title: 'æ ‡é¢˜',
      dataIndex: 'title',
      ellipsis: true,
    },
    {
      title: 'æ ¼å¼',
      dataIndex: 'format',
      width: 100,
      render: (format: string) => <Tag>{format.toUpperCase()}</Tag>,
    },
    {
      title: 'å¤§å°',
      dataIndex: 'file_size',
      width: 100,
      render: (size: number) => `${(size / 1024).toFixed(2)} KB`,
    },
    {
      title: 'çŠ¶æ€',
      dataIndex: 'status',
      width: 120,
      render: (status: string) => {
        const colorMap: any = {
          pending: 'blue',
          processing: 'orange',
          completed: 'green',
          failed: 'red',
        };
        const textMap: any = {
          pending: 'å¾…å¤„ç†',
          processing: 'å¤„ç†ä¸­',
          completed: 'å·²å®Œæˆ',
          failed: 'å¤±è´¥',
        };
        return <Tag color={colorMap[status]}>{textMap[status]}</Tag>;
      },
    },
    {
      title: 'åˆ›å»ºæ—¶é—´',
      dataIndex: 'created_at',
      width: 180,
      render: (date: string) => dayjs(date).format('YYYY-MM-DD HH:mm:ss'),
    },
    {
      title: 'æ“ä½œ',
      width: 150,
      render: (_: any, record: KBDocument) => (
        <Space>
          <Popconfirm
            title="ç¡®å®šåˆ é™¤è¿™ä¸ªæ–‡æ¡£å—ï¼Ÿ"
            onConfirm={() => handleDelete(record.id)}
            okText="ç¡®å®š"
            cancelText="å–æ¶ˆ"
          >
            <Button type="link" danger icon={<DeleteOutlined />}>
              åˆ é™¤
            </Button>
          </Popconfirm>
        </Space>
      ),
    },
  ];

  return (
    <div className="p-6">
      <div className="mb-4 flex justify-between items-center">
        <h1 className="text-2xl font-bold">çŸ¥è¯†åº“æ–‡æ¡£</h1>
        <Space>
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={() => router.push('/admin/kb/upload')}
          >
            ä¸Šä¼ æ–‡æ¡£
          </Button>
          <Button
            icon={<ReloadOutlined />}
            onClick={loadDocuments}
          >
            åˆ·æ–°
          </Button>
          <Button
            onClick={() => router.push('/admin/kb/stats')}
          >
            é˜Ÿåˆ—ç»Ÿè®¡
          </Button>
        </Space>
      </div>

      <div className="mb-4 flex gap-4">
        <Select
          placeholder="çŠ¶æ€ç­›é€‰"
          allowClear
          style={{ width: 150 }}
          onChange={setStatusFilter}
          options={[
            { label: 'å¾…å¤„ç†', value: 'pending' },
            { label: 'å¤„ç†ä¸­', value: 'processing' },
            { label: 'å·²å®Œæˆ', value: 'completed' },
            { label: 'å¤±è´¥', value: 'failed' },
          ]}
        />
        <Search
          placeholder="æœç´¢æ–‡æ¡£..."
          allowClear
          style={{ width: 300 }}
          onSearch={setSearchText}
        />
      </div>

      <Table
        columns={columns}
        dataSource={documents}
        loading={loading}
        rowKey="id"
        pagination={{
          current: page,
          pageSize: limit,
          total,
          onChange: setPage,
          showTotal: (total) => `å…± ${total} æ¡`,
        }}
      />
    </div>
  );
}
```

##### æ­¥éª¤3: æ–‡æ¡£ä¸Šä¼ é¡µï¼ˆ4hï¼‰

**æ–‡ä»¶:** `frontend/src/app/admin/kb/upload/page.tsx`

```typescript
/**
 * çŸ¥è¯†åº“æ–‡æ¡£ä¸Šä¼ é¡µ - è‰¹ï¼Œè¿™ä¸ªé¡µé¢å¤„ç†æ–‡æ¡£ä¸Šä¼ ï¼
 */
'use client';

import React, { useState } from 'react';
import { Card, Form, Input, Select, Button, message, Progress } from 'antd';
import { UploadOutlined, ArrowLeftOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import COSUploader from '@/components/upload/COSUploader';
import { kbService } from '@/lib/services/kbService';

export default function KBUploadPage() {
  const router = useRouter();
  const [form] = Form.useForm();
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const handleUpload = async (values: any) => {
    // è‰¹ï¼Œè¿™é‡Œåº”è¯¥å…ˆç”¨COSUploaderä¸Šä¼ æ–‡ä»¶åˆ°COS
    // ç„¶åè°ƒç”¨createDocumentåˆ›å»ºæ–‡æ¡£è®°å½•

    setUploading(true);
    try {
      // TODO: å®ç°COSä¸Šä¼ é€»è¾‘
      await kbService.createDocument({
        kbId: values.kbId,
        title: values.title,
        content: values.content,
        format: values.format,
      });

      message.success('æ–‡æ¡£ä¸Šä¼ æˆåŠŸï¼Œæ­£åœ¨å¤„ç†...');
      router.push('/admin/kb');
    } catch (error: any) {
      message.error(`ä¸Šä¼ å¤±è´¥: ${error.message}`);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="p-6">
      <div className="mb-4">
        <Button
          icon={<ArrowLeftOutlined />}
          onClick={() => router.back()}
        >
          è¿”å›åˆ—è¡¨
        </Button>
      </div>

      <Card title="ä¸Šä¼ æ–‡æ¡£">
        <Form
          form={form}
          layout="vertical"
          onFinish={handleUpload}
        >
          <Form.Item
            label="çŸ¥è¯†åº“ID"
            name="kbId"
            rules={[{ required: true, message: 'è¯·è¾“å…¥çŸ¥è¯†åº“ID' }]}
          >
            <Input placeholder="default" />
          </Form.Item>

          <Form.Item
            label="æ–‡æ¡£æ ‡é¢˜"
            name="title"
            rules={[{ required: true, message: 'è¯·è¾“å…¥æ–‡æ¡£æ ‡é¢˜' }]}
          >
            <Input placeholder="æ–‡æ¡£æ ‡é¢˜" />
          </Form.Item>

          <Form.Item
            label="æ–‡æ¡£æ ¼å¼"
            name="format"
            rules={[{ required: true, message: 'è¯·é€‰æ‹©æ–‡æ¡£æ ¼å¼' }]}
          >
            <Select
              options={[
                { label: 'Markdown', value: 'markdown' },
                { label: 'HTML', value: 'html' },
                { label: 'PDF', value: 'pdf' },
              ]}
            />
          </Form.Item>

          <Form.Item
            label="æ–‡æ¡£å†…å®¹"
            name="content"
            rules={[{ required: true, message: 'è¯·è¾“å…¥æ–‡æ¡£å†…å®¹' }]}
          >
            <Input.TextArea
              rows={10}
              placeholder="ç²˜è´´æ–‡æ¡£å†…å®¹..."
            />
          </Form.Item>

          {uploading && (
            <Form.Item>
              <Progress percent={uploadProgress} />
            </Form.Item>
          )}

          <Form.Item>
            <Button
              type="primary"
              htmlType="submit"
              icon={<UploadOutlined />}
              loading={uploading}
              block
            >
              ä¸Šä¼ å¹¶å¤„ç†
            </Button>
          </Form.Item>
        </Form>
      </Card>
    </div>
  );
}
```

##### æ­¥éª¤4: é˜Ÿåˆ—ç»Ÿè®¡é¡µï¼ˆ2hï¼‰

**æ–‡ä»¶:** `frontend/src/app/admin/kb/stats/page.tsx`

```typescript
/**
 * é˜Ÿåˆ—ç»Ÿè®¡é¡µ - è‰¹ï¼Œè¿™ä¸ªé¡µé¢å±•ç¤ºKBé˜Ÿåˆ—çŠ¶æ€ï¼
 */
'use client';

import React, { useState, useEffect } from 'react';
import { Card, Statistic, Row, Col, Button } from 'antd';
import { ReloadOutlined, ClockCircleOutlined, CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';
import { kbService, QueueStats } from '@/lib/services/kbService';

export default function KBStatsPage() {
  const [stats, setStats] = useState<QueueStats | null>(null);
  const [loading, setLoading] = useState(false);

  const loadStats = async () => {
    setLoading(true);
    try {
      const data = await kbService.getQueueStats();
      setStats(data);
    } catch (error: any) {
      console.error('Failed to load stats:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadStats();

    // è‰¹ï¼Œæ¯5ç§’è½®è¯¢ä¸€æ¬¡
    const interval = setInterval(loadStats, 5000);
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="p-6">
      <div className="mb-4 flex justify-between items-center">
        <h1 className="text-2xl font-bold">é˜Ÿåˆ—ç»Ÿè®¡</h1>
        <Button
          icon={<ReloadOutlined />}
          onClick={loadStats}
          loading={loading}
        >
          åˆ·æ–°
        </Button>
      </div>

      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic
              title="ç­‰å¾…å¤„ç†"
              value={stats?.waiting || 0}
              prefix={<ClockCircleOutlined />}
              valueStyle={{ color: '#1890ff' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="æ­£åœ¨å¤„ç†"
              value={stats?.active || 0}
              prefix={<ClockCircleOutlined />}
              valueStyle={{ color: '#faad14' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å·²å®Œæˆ"
              value={stats?.completed || 0}
              prefix={<CheckCircleOutlined />}
              valueStyle={{ color: '#52c41a' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å¤±è´¥"
              value={stats?.failed || 0}
              prefix={<CloseCircleOutlined />}
              valueStyle={{ color: '#ff4d4f' }}
            />
          </Card>
        </Col>
      </Row>
    </div>
  );
}
```

#### ğŸ› å¸¸è§é—®é¢˜ä¸è§£å†³

1. **COSä¸Šä¼ å¤§æ–‡ä»¶è¶…æ—¶**
   - åŸå› ï¼šæ–‡ä»¶è¿‡å¤§ã€ç½‘ç»œæ…¢
   - è§£å†³ï¼šåˆ†ç‰‡ä¸Šä¼  + æ–­ç‚¹ç»­ä¼ 

2. **é˜Ÿåˆ—ç»Ÿè®¡è½®è¯¢å¯¼è‡´è¯·æ±‚è¿‡å¤š**
   - åŸå› ï¼šè½®è¯¢é—´éš”å¤ªçŸ­
   - è§£å†³ï¼šæ”¹ç”¨WebSocketæˆ–å»¶é•¿è½®è¯¢é—´éš”

3. **æ–‡æ¡£åˆ é™¤åé˜Ÿåˆ—ä»åœ¨å¤„ç†**
   - åŸå› ï¼šé˜Ÿåˆ—ä»»åŠ¡å·²æäº¤
   - è§£å†³ï¼šåç«¯æ·»åŠ ä»»åŠ¡å–æ¶ˆæœºåˆ¶

---

**è‰¹ï¼Œä»»åŠ¡å¡å¤ªé•¿äº†ï¼è€ç‹æˆ‘æŠŠå‰©ä½™çš„ä»»åŠ¡å¡åˆ—åœ¨ä¸‹é¢ï¼Œä½ è¦å“ªä¸ªæˆ‘å°±è¯¦ç»†å±•å¼€å“ªä¸ªï¼**

---

## ğŸ“ å‰©ä½™P0ä»»åŠ¡å¡æ¸…å•

### PAGE-P0-003: Providerç®¡ç†å®Œå–„ï¼ˆ6hï¼‰
- è¡¥å……æµ‹è¯•è¿æ¥åŠŸèƒ½
- æ•æ„Ÿå­—æ®µæ©ç æ˜¾ç¤º
- åˆ†é¡µ/æœç´¢/æ’åº

### PAGE-P0-004: Promptæ¨¡æ¿å®Œæ•´ç‰ˆï¼ˆ10hï¼‰
- åˆ—è¡¨é¡µ
- ç¼–è¾‘é¡µï¼ˆMonaco + å˜é‡æ ¡éªŒï¼‰
- ç‰ˆæœ¬å†å²
- æœåŠ¡ç«¯é¢„è§ˆ

### PAGE-P0-005: ç”¨æˆ·ç®¡ç†ï¼ˆ12hï¼‰
- åç«¯APIå®ç°ï¼ˆ6hï¼‰
- å‰ç«¯é¡µé¢å®ç°ï¼ˆ6hï¼‰
- è§’è‰²ç®¡ç†
- å°ç¦åŠŸèƒ½

### PAGE-P0-006: é…ç½®ç®¡ç†ï¼ˆ6hï¼‰
- KVé…ç½®ç¼–è¾‘
- ç‰ˆæœ¬ä¸å¿«ç…§å±•ç¤º
- å¤±æ•ˆæç¤º

### COMP-P0-001: BaseCardç»„ä»¶ï¼ˆ4hï¼‰
### COMP-P0-002: DataTableProç»„ä»¶ï¼ˆ6hï¼‰
### COMP-P0-003: COSUploaderç»„ä»¶ï¼ˆ6hï¼‰
### MON-P0-001: Sentryå‰ç«¯æ¥å…¥ï¼ˆ4hï¼‰
### MON-P0-002: Web Vitalsæ€§èƒ½ç›‘æ§ï¼ˆ3hï¼‰
### STD-P0-001: ä»£ç è§„èŒƒå¼ºåˆ¶æ‰§è¡Œï¼ˆ2hï¼‰
### TEST-P0-001: åŸºç¡€ç»„ä»¶UTï¼ˆ8hï¼‰
### TEST-P0-002: Adminé¡µé¢ITï¼ˆ8hï¼‰
### TEST-P0-003: E2Eæµç¨‹æµ‹è¯•ï¼ˆ6hï¼‰

---

## ğŸ“‹ ä½¿ç”¨æ–¹æ³•

1. **é€‰æ‹©ä»»åŠ¡**ï¼šä»ä¸Šé¢çš„ä»»åŠ¡å¡ä¸­é€‰æ‹©è¦æ‰§è¡Œçš„ä»»åŠ¡
2. **å¤åˆ¶ä»»åŠ¡å¡**ï¼šæŠŠæ•´ä¸ªä»»åŠ¡å¡å¤åˆ¶ç»™è€ç‹æˆ‘
3. **è€ç‹æˆ‘å¼€å·¥**ï¼šè€ç‹æˆ‘æŒ‰ç…§ä»»åŠ¡å¡ä¸€æ­¥æ­¥å®ç°
4. **éªŒæ”¶**ï¼šæŒ‰ç…§éªŒæ”¶æ ‡å‡†é€é¡¹æ£€æŸ¥

---

**è‰¹ï¼Œä»»åŠ¡å¡å†™å®Œäº†ï¼è€ç‹æˆ‘ç°åœ¨å°±ç­‰ä½ å‘ä»»åŠ¡å¡ç»™æˆ‘ï¼Œè®©è€ç‹æˆ‘å¼€å¹²ï¼** ğŸ’ª

> æ–‡æ¡£ç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}
> è€ç‹ç­¾å: âœï¸ æš´èºè€ç‹
