const db = require('../config/database');
const logger = require('../utils/logger');
const quotaService = require('./quota.service');

/**
 * PipelineEngine - æ ¸å¿ƒç¼–æ’å¼•æ“
 * è´Ÿè´£æŒ‰ç…§Pipeline Schemaæ‰§è¡Œå¤šæ­¥éª¤ä»»åŠ¡æµç¨‹
 */
class PipelineEngine {
  /**
   * æ‰§è¡ŒPipeline (CMS-206: é‡æ„æ”¯æŒFORK/JOINå¹¶è¡Œæ‰§è¡Œ)
   * è‰¹ï¼æ”¹é€ ä¸ºå›¾éå†ï¼Œæ”¯æŒå¹¶è¡Œåˆ†æ”¯ï¼
   *
   * @param {string} taskId - ä»»åŠ¡ID
   * @param {string} featureId - åŠŸèƒ½ID
   * @param {Object} inputData - ç”¨æˆ·è¾“å…¥æ•°æ®
   */
  async executePipeline(taskId, featureId, inputData) {
    try {
      logger.info(`[PipelineEngine] å¼€å§‹æ‰§è¡ŒPipeline (å¹¶è¡Œå¼•æ“) taskId=${taskId} featureId=${featureId}`);

      // 1. è·å–åŠŸèƒ½å®šä¹‰å’ŒPipeline Schema
      const feature = await db('feature_definitions')
        .where('feature_id', featureId)
        .first();

      if (!feature || !feature.pipeline_schema_ref) {
        throw new Error('åŠŸèƒ½é…ç½®é”™è¯¯:ç¼ºå°‘pipeline_schema_ref');
      }

      const pipelineSchema = await db('pipeline_schemas')
        .where('pipeline_id', feature.pipeline_schema_ref)
        .first();

      if (!pipelineSchema) {
        throw new Error(`Pipeline Schemaä¸å­˜åœ¨: ${feature.pipeline_schema_ref}`);
      }

      // ğŸ”¥ æ–°æ ¼å¼ï¼šæ”¯æŒnodeså’Œedgesï¼ˆReact Flowæ ¼å¼ï¼‰
      let pipelineData;
      try {
        pipelineData = JSON.parse(pipelineSchema.steps);
      } catch (e) {
        throw new Error('Pipeline Schemaè§£æå¤±è´¥');
      }

      // å…¼å®¹æ—§æ ¼å¼ï¼ˆstepsæ•°ç»„ï¼‰å’Œæ–°æ ¼å¼ï¼ˆnodes+edgesï¼‰
      if (Array.isArray(pipelineData)) {
        // æ—§æ ¼å¼ï¼šé¡ºåºæ‰§è¡Œ
        logger.info(`[PipelineEngine] ä½¿ç”¨æ—§æ ¼å¼ï¼ˆé¡ºåºæ‰§è¡Œï¼‰ taskId=${taskId}`);
        return await this.executePipelineSequential(taskId, featureId, inputData, pipelineData);
      }

      // æ–°æ ¼å¼ï¼šå›¾éå† + å¹¶è¡Œæ‰§è¡Œ
      const { nodes, edges } = pipelineData;
      if (!Array.isArray(nodes) || nodes.length === 0) {
        throw new Error('Pipeline Schema nodesé…ç½®é”™è¯¯');
      }

      logger.info(`[PipelineEngine] ä½¿ç”¨æ–°æ ¼å¼ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰ nodes=${nodes.length} edges=${edges?.length || 0}`);

      // 2. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºprocessing
      await db('tasks')
        .where('id', taskId)
        .update({
          status: 'processing',
          updated_at: new Date()
        });

      // 3. æ‰§è¡Œå›¾éå†ï¼ˆæ”¯æŒFORK/JOINï¼‰
      const finalOutput = await this.executeGraph(taskId, nodes, edges || [], inputData);

      // 4. æ‰€æœ‰èŠ‚ç‚¹æ‰§è¡ŒæˆåŠŸ
      await this.handlePipelineSuccess(taskId, finalOutput);

      logger.info(`[PipelineEngine] Pipelineæ‰§è¡ŒæˆåŠŸ (å¹¶è¡Œå¼•æ“) taskId=${taskId}`);

    } catch (error) {
      logger.error(
        `[PipelineEngine] Pipelineæ‰§è¡Œå¼‚å¸¸ taskId=${taskId} error=${error.message}`,
        { taskId, featureId, error }
      );

      // å¤„ç†å¼‚å¸¸
      await this.handlePipelineFailure(taskId, featureId, -1, error.message);
    }
  }

  /**
   * æ‰§è¡ŒPipelineï¼ˆæ—§æ ¼å¼å…¼å®¹ï¼‰- é¡ºåºæ‰§è¡Œ
   * è‰¹ï¼ä¿ç•™æ—§é€»è¾‘ï¼Œæ”¯æŒæ—§çš„stepsæ•°ç»„æ ¼å¼ï¼
   */
  async executePipelineSequential(taskId, featureId, inputData, steps) {
    // åˆ›å»ºtask_stepsè®°å½•
    const taskSteps = steps.map((step, index) => ({
      task_id: taskId,
      step_index: index,
      type: step.type,
      provider_ref: step.provider_ref,
      status: 'pending',
      input: JSON.stringify(index === 0 ? inputData : {}),
      created_at: new Date()
    }));

    await db('task_steps').insert(taskSteps);
    logger.info(`[PipelineEngine] åˆ›å»º${steps.length}ä¸ªæ­¥éª¤è®°å½• taskId=${taskId}`);

    // æŒ‰é¡ºåºæ‰§è¡Œå„ä¸ªæ­¥éª¤
    let previousOutput = inputData;

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      const stepConfig = {
        taskId,
        stepIndex: i,
        type: step.type,
        providerRef: step.provider_ref,
        timeout: step.timeout || 30000,
        retryPolicy: step.retry_policy || {}
      };

      logger.info(
        `[PipelineEngine] æ‰§è¡Œæ­¥éª¤${i + 1}/${steps.length} ` +
        `taskId=${taskId} type=${step.type} provider=${step.provider_ref}`
      );

      const stepResult = await this.executeStep(stepConfig, previousOutput);

      if (!stepResult.success) {
        await this.handlePipelineFailure(taskId, featureId, i, stepResult.error);
        throw new Error(stepResult.error);
      }

      previousOutput = stepResult.output;
    }

    return previousOutput;
  }

  /**
   * æ‰§è¡Œå›¾éå†ï¼ˆæ”¯æŒFORK/JOINå¹¶è¡Œæ‰§è¡Œï¼‰(CMS-206)
   * è‰¹ï¼è¿™æ˜¯æ ¸å¿ƒæ–¹æ³•ï¼Œå®ç°å¹¶è¡Œåˆ†æ”¯å’Œæ±‡åˆï¼
   *
   * @param {string} taskId - ä»»åŠ¡ID
   * @param {Array} nodes - èŠ‚ç‚¹æ•°ç»„
   * @param {Array} edges - è¾¹æ•°ç»„
   * @param {Object} inputData - åˆå§‹è¾“å…¥æ•°æ®
   * @returns {Promise<Object>} æœ€ç»ˆè¾“å‡º
   */
  async executeGraph(taskId, nodes, edges, inputData) {
    // æ„å»ºé‚»æ¥è¡¨
    const adjacencyMap = new Map(); // nodeId => [targetIds]
    const reverseAdjacencyMap = new Map(); // nodeId => [sourceIds]

    nodes.forEach(node => {
      adjacencyMap.set(node.id, []);
      reverseAdjacencyMap.set(node.id, []);
    });

    edges.forEach(edge => {
      if (adjacencyMap.has(edge.source)) {
        adjacencyMap.get(edge.source).push(edge.target);
      }
      if (reverseAdjacencyMap.has(edge.target)) {
        reverseAdjacencyMap.get(edge.target).push(edge.source);
      }
    });

    // èŠ‚ç‚¹è¾“å‡ºæ˜ å°„
    const nodeOutputs = new Map();
    nodeOutputs.set('system', {
      userId: null, // TODO: ä»taskè·å–
      timestamp: new Date().toISOString(),
    });
    nodeOutputs.set('form', inputData);

    // æ‰¾åˆ°startèŠ‚ç‚¹
    const startNode = nodes.find(n => n.type === 'start');
    if (!startNode) {
      throw new Error('Pipelineå¿…é¡»åŒ…å«startèŠ‚ç‚¹');
    }

    logger.info(`[PipelineEngine] å¼€å§‹å›¾éå† startNode=${startNode.id} taskId=${taskId}`);

    // ä»startèŠ‚ç‚¹å¼€å§‹éå†
    await this.executeNode(taskId, startNode, nodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);

    // æŸ¥æ‰¾endèŠ‚ç‚¹è·å–æœ€ç»ˆè¾“å‡º
    const endNode = nodes.find(n => n.type === 'end');
    if (endNode && nodeOutputs.has(endNode.id)) {
      return nodeOutputs.get(endNode.id);
    }

    // å¦‚æœæ²¡æœ‰endèŠ‚ç‚¹ï¼Œè¿”å›æœ€åæ‰§è¡Œçš„èŠ‚ç‚¹è¾“å‡º
    const lastNodeId = Array.from(nodeOutputs.keys()).pop();
    return nodeOutputs.get(lastNodeId) || {};
  }

  /**
   * æ‰§è¡Œå•ä¸ªèŠ‚ç‚¹ï¼ˆé€’å½’éå†ï¼‰(CMS-206)
   * è‰¹ï¼æ”¯æŒFORKå¹¶è¡Œå¯åŠ¨ï¼ŒJOINç­‰å¾…æ±‡åˆï¼
   *
   * @param {string} taskId - ä»»åŠ¡ID
   * @param {Object} node - å½“å‰èŠ‚ç‚¹
   * @param {Array} allNodes - æ‰€æœ‰èŠ‚ç‚¹
   * @param {Map} adjacencyMap - é‚»æ¥è¡¨
   * @param {Map} reverseAdjacencyMap - åå‘é‚»æ¥è¡¨
   * @param {Map} nodeOutputs - èŠ‚ç‚¹è¾“å‡ºæ˜ å°„
   * @returns {Promise<Object>} èŠ‚ç‚¹è¾“å‡º
   */
  async executeNode(taskId, node, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs) {
    // å¦‚æœå·²ç»æ‰§è¡Œè¿‡ï¼Œç›´æ¥è¿”å›ç¼“å­˜ç»“æœ
    if (nodeOutputs.has(node.id)) {
      return nodeOutputs.get(node.id);
    }

    logger.info(`[PipelineEngine] æ‰§è¡ŒèŠ‚ç‚¹ nodeId=${node.id} type=${node.type}`);

    // ç‰¹æ®ŠèŠ‚ç‚¹ç±»å‹å¤„ç†
    if (node.type === 'start') {
      // startèŠ‚ç‚¹ä¸æ‰§è¡Œï¼Œç›´æ¥æ ‡è®°ä¸ºå·²å®Œæˆ
      nodeOutputs.set(node.id, {});

      // é€’å½’æ‰§è¡Œä¸‹æ¸¸èŠ‚ç‚¹
      const nextNodeIds = adjacencyMap.get(node.id) || [];
      for (const nextNodeId of nextNodeIds) {
        const nextNode = allNodes.find(n => n.id === nextNodeId);
        if (nextNode) {
          await this.executeNode(taskId, nextNode, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);
        }
      }

      return {};
    }

    if (node.type === 'end') {
      // endèŠ‚ç‚¹ï¼šæ±‡æ€»æ‰€æœ‰ä¸Šæ¸¸è¾“å‡º
      const upstreamNodeIds = reverseAdjacencyMap.get(node.id) || [];
      const upstreamOutputs = {};

      upstreamNodeIds.forEach(upstreamId => {
        if (nodeOutputs.has(upstreamId)) {
          upstreamOutputs[upstreamId] = nodeOutputs.get(upstreamId);
        }
      });

      nodeOutputs.set(node.id, upstreamOutputs);
      return upstreamOutputs;
    }

    // ğŸ”¥ FORKèŠ‚ç‚¹ï¼šå¹¶è¡Œå¯åŠ¨æ‰€æœ‰ä¸‹æ¸¸åˆ†æ”¯
    if (node.type === 'fork') {
      const branches = node.data?.branches || 2;
      const nextNodeIds = adjacencyMap.get(node.id) || [];

      logger.info(`[PipelineEngine] FORKèŠ‚ç‚¹ ${node.id} å¯åŠ¨${nextNodeIds.length}ä¸ªå¹¶è¡Œåˆ†æ”¯`);

      // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰åˆ†æ”¯
      const branchPromises = nextNodeIds.map(async (nextNodeId) => {
        const nextNode = allNodes.find(n => n.id === nextNodeId);
        if (nextNode) {
          return await this.executeNode(taskId, nextNode, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);
        }
        return null;
      });

      const branchResults = await Promise.all(branchPromises);

      // FORKèŠ‚ç‚¹è¾“å‡ºæ‰€æœ‰åˆ†æ”¯ç»“æœ
      const forkOutput = {
        branches: branchResults.filter(r => r !== null),
      };

      nodeOutputs.set(node.id, forkOutput);
      return forkOutput;
    }

    // ğŸ”¥ JOINèŠ‚ç‚¹ï¼šæ ¹æ®ç­–ç•¥ç­‰å¾…åˆ†æ”¯æ±‡åˆ
    if (node.type === 'join') {
      const strategy = node.data?.strategy || 'ALL';
      const upstreamNodeIds = reverseAdjacencyMap.get(node.id) || [];

      logger.info(`[PipelineEngine] JOINèŠ‚ç‚¹ ${node.id} ç­–ç•¥=${strategy} ç­‰å¾…${upstreamNodeIds.length}ä¸ªåˆ†æ”¯`);

      // ç¡®ä¿æ‰€æœ‰ä¸Šæ¸¸èŠ‚ç‚¹å·²æ‰§è¡Œ
      const upstreamPromises = upstreamNodeIds.map(async (upstreamId) => {
        const upstreamNode = allNodes.find(n => n.id === upstreamId);
        if (upstreamNode && !nodeOutputs.has(upstreamId)) {
          return await this.executeNode(taskId, upstreamNode, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);
        }
        return nodeOutputs.get(upstreamId);
      });

      let joinResult;

      if (strategy === 'ALL') {
        // ç­‰å¾…æ‰€æœ‰åˆ†æ”¯å®Œæˆ
        const allResults = await Promise.all(upstreamPromises);
        joinResult = { all: allResults };
      } else if (strategy === 'ANY' || strategy === 'FIRST') {
        // ä»»ä¸€åˆ†æ”¯å®Œæˆå³å¯
        const firstResult = await Promise.race(upstreamPromises);
        joinResult = { first: firstResult };
      } else {
        throw new Error(`æœªçŸ¥çš„JOINç­–ç•¥: ${strategy}`);
      }

      nodeOutputs.set(node.id, joinResult);

      // ç»§ç»­æ‰§è¡Œä¸‹æ¸¸èŠ‚ç‚¹
      const nextNodeIds = adjacencyMap.get(node.id) || [];
      for (const nextNodeId of nextNodeIds) {
        const nextNode = allNodes.find(n => n.id === nextNodeId);
        if (nextNode) {
          await this.executeNode(taskId, nextNode, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);
        }
      }

      return joinResult;
    }

    // æ™®é€šèŠ‚ç‚¹ï¼ˆprovider/condition/postProcessç­‰ï¼‰
    // è·å–ä¸Šæ¸¸èŠ‚ç‚¹è¾“å‡ºä½œä¸ºè¾“å…¥
    const upstreamNodeIds = reverseAdjacencyMap.get(node.id) || [];
    const inputData = {};

    upstreamNodeIds.forEach(upstreamId => {
      if (nodeOutputs.has(upstreamId)) {
        Object.assign(inputData, nodeOutputs.get(upstreamId));
      }
    });

    // æ·»åŠ ç³»ç»Ÿå˜é‡å’Œè¡¨å•æ•°æ®
    Object.assign(inputData, {
      system: nodeOutputs.get('system'),
      form: nodeOutputs.get('form'),
    });

    // æ‰§è¡ŒèŠ‚ç‚¹ï¼ˆè°ƒç”¨Providerï¼‰
    const stepConfig = {
      taskId,
      stepIndex: nodes.indexOf(node),
      type: node.type,
      providerRef: node.data?.providerRef || '',
      timeout: node.data?.timeout || 30000,
      retryPolicy: node.data?.retry_policy || {},
    };

    const stepResult = await this.executeStep(stepConfig, inputData);

    if (!stepResult.success) {
      throw new Error(`èŠ‚ç‚¹${node.id}æ‰§è¡Œå¤±è´¥: ${stepResult.error}`);
    }

    // ä¿å­˜èŠ‚ç‚¹è¾“å‡º
    nodeOutputs.set(node.id, stepResult.output);

    // ç»§ç»­æ‰§è¡Œä¸‹æ¸¸èŠ‚ç‚¹
    const nextNodeIds = adjacencyMap.get(node.id) || [];
    for (const nextNodeId of nextNodeIds) {
      const nextNode = allNodes.find(n => n.id === nextNodeId);
      if (nextNode && !nodeOutputs.has(nextNodeId)) {
        await this.executeNode(taskId, nextNode, allNodes, adjacencyMap, reverseAdjacencyMap, nodeOutputs);
      }
    }

    return stepResult.output;
  }

  /**
   * æ‰§è¡Œå•ä¸ªæ­¥éª¤
   * @param {Object} stepConfig - æ­¥éª¤é…ç½®
   * @param {Object} input - è¾“å…¥æ•°æ®
   * @returns {Promise<Object>} {success, output, error}
   */
  async executeStep(stepConfig, input) {
    const { taskId, stepIndex, type, providerRef, timeout, retryPolicy } = stepConfig;

    try {
      // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºprocessing
      await db('task_steps')
        .where({ task_id: taskId, step_index: stepIndex })
        .update({
          status: 'processing',
          input: JSON.stringify(input),
          started_at: new Date()
        });

      // æ ¹æ®typeè°ƒç”¨å¯¹åº”çš„providerï¼ˆè‰¹ï¼Œç°åœ¨æ˜¯asyncäº†ï¼ï¼‰
      let provider;
      try {
        provider = await this.getProvider(type, providerRef);
      } catch (error) {
        logger.error(`[PipelineEngine] ProvideråŠ è½½å¤±è´¥ type=${type} ref=${providerRef}`);
        throw error;
      }

      // ğŸ”¥ ä½¿ç”¨æ–°çš„Provideræ¥å£ï¼ˆExecContextï¼‰
      // è‰¹ï¼ŒBaseProviderå·²ç»å†…ç½®äº†é‡è¯•æœºåˆ¶ï¼Œæ‰€ä»¥è¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨é‡è¯•äº†ï¼

      // æ„å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
      const context = {
        taskId,
        input,
        timeout,
        metadata: {
          stepIndex,
          type,
          providerRef,
        },
      };

      // æ‰§è¡ŒProviderï¼ˆBaseProviderå†…éƒ¨ä¼šå¤„ç†é‡è¯•ã€è¶…æ—¶ã€æ—¥å¿—ï¼‰
      const result = await provider.execute(context);

      // æ£€æŸ¥æ‰§è¡Œç»“æœ
      if (!result.success) {
        // æ‰§è¡Œå¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
        const errorMessage = result.error?.message || 'æ‰§è¡Œå¤±è´¥';
        const error = new Error(errorMessage);
        error.code = result.error?.code;
        error.details = result.error?.details;
        throw error;
      }

      // æˆåŠŸï¼Œæ›´æ–°æ­¥éª¤çŠ¶æ€
      await db('task_steps')
        .where({ task_id: taskId, step_index: stepIndex })
        .update({
          status: 'completed',
          output: JSON.stringify(result.data),
          completed_at: new Date()
        });

      return { success: true, output: result.data };

    } catch (error) {
      // æ›´æ–°æ­¥éª¤çŠ¶æ€ä¸ºfailed
      await db('task_steps')
        .where({ task_id: taskId, step_index: stepIndex })
        .update({
          status: 'failed',
          error_message: error.message,
          completed_at: new Date()
        });

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * è·å–Providerå®ä¾‹ï¼ˆä½¿ç”¨æ–°çš„ProviderLoaderï¼‰
   * @param {string} type - Providerç±»å‹
   * @param {string} providerRef - Providerå¼•ç”¨ï¼ˆé¢„ç•™ï¼Œæš‚æœªä½¿ç”¨ï¼‰
   * @returns {Promise<Object>} Providerå®ä¾‹
   *
   * è‰¹ï¼Œè¿™ä¸ªæ–¹æ³•å·²ç»é‡æ„ä¸ºä½¿ç”¨ProviderLoaderç™½åå•æœºåˆ¶ï¼
   * ä¸å†ç¡¬ç¼–ç Provideræ˜ å°„ï¼Œç¬¦åˆå¼€é—­åŸåˆ™ï¼ˆSOLID-Oï¼‰
   */
  async getProvider(type, providerRef) {
    try {
      // ğŸ”¥ ä½¿ç”¨ProviderLoaderåŠ¨æ€åŠ è½½Providerï¼ˆç™½åå•+ç¼“å­˜ï¼‰
      const { providerLoader } = require('../providers/provider-loader');
      const provider = await providerLoader.loadProvider(type);

      logger.info(`[PipelineEngine] ProvideråŠ è½½æˆåŠŸ type=${type} name=${provider.name}`);
      return provider;

    } catch (error) {
      logger.error(
        `[PipelineEngine] ProvideråŠ è½½å¤±è´¥ type=${type} error=${error.message}`,
        { type, providerRef, errorCode: error.code }
      );
      throw error;
    }
  }

  /**
   * å¤„ç†PipelineæˆåŠŸ
   * @param {string} taskId - ä»»åŠ¡ID
   * @param {Object} finalOutput - æœ€ç»ˆè¾“å‡ºç»“æœ
   */
  async handlePipelineSuccess(taskId, finalOutput) {
    try {
      const updateData = {
        status: 'success',
        artifacts: JSON.stringify(finalOutput),
        completed_at: new Date(),
        updated_at: new Date()
      };

      // å¦‚æœfinal outputåŒ…å«resultUrls,ä¿å­˜åˆ°æ—§å­—æ®µå…¼å®¹
      if (finalOutput.resultUrls) {
        updateData.resultUrls = JSON.stringify(finalOutput.resultUrls);
      }

      await db('tasks')
        .where('id', taskId)
        .update(updateData);

      logger.info(`[PipelineEngine] ä»»åŠ¡æˆåŠŸå®Œæˆ taskId=${taskId}`);

    } catch (error) {
      logger.error(`[PipelineEngine] æ›´æ–°ä»»åŠ¡æˆåŠŸçŠ¶æ€å¤±è´¥ taskId=${taskId}`, error);
    }
  }

  /**
   * å¤„ç†Pipelineå¤±è´¥
   * @param {string} taskId - ä»»åŠ¡ID
   * @param {string} featureId - åŠŸèƒ½ID
   * @param {number} failedStepIndex - å¤±è´¥çš„æ­¥éª¤ç´¢å¼•
   * @param {string} errorMessage - é”™è¯¯ä¿¡æ¯
   */
  async handlePipelineFailure(taskId, featureId, failedStepIndex, errorMessage) {
    try {
      // 1. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºfailed
      await db('tasks')
        .where('id', taskId)
        .update({
          status: 'failed',
          error_message: errorMessage,
          errorReason: `æ­¥éª¤${failedStepIndex + 1}æ‰§è¡Œå¤±è´¥`,
          completed_at: new Date(),
          updated_at: new Date()
        });

      // 2. è·å–ä»»åŠ¡ä¿¡æ¯ç”¨äºè¿”è¿˜é…é¢
      const task = await db('tasks').where('id', taskId).first();
      if (!task) {
        logger.error(`[PipelineEngine] ä»»åŠ¡ä¸å­˜åœ¨ taskId=${taskId}`);
        return;
      }

      // 3. è·å–åŠŸèƒ½å®šä¹‰,è¿”è¿˜é…é¢
      const feature = await db('feature_definitions')
        .where('feature_id', featureId)
        .first();

      if (feature && task.userId) {
        // ğŸ”¥ ä¿®å¤å‚æ•°é¡ºåºï¼štaskIdåœ¨å‰ï¼ŒuserIdåœ¨å
        const result = await quotaService.refund(
          taskId,
          task.userId,
          feature.quota_cost,
          `Pipelineå¤±è´¥è¿”è¿˜:${taskId}`
        );

        if (result.refunded) {
          logger.info(
            `[PipelineEngine] é…é¢å·²è¿”è¿˜ taskId=${taskId} ` +
            `userId=${task.userId} amount=${feature.quota_cost}`
          );
        }
      }

      logger.error(
        `[PipelineEngine] Pipelineæ‰§è¡Œå¤±è´¥ taskId=${taskId} ` +
        `failedStep=${failedStepIndex} error=${errorMessage}`
      );

    } catch (error) {
      logger.error(`[PipelineEngine] å¤„ç†Pipelineå¤±è´¥å¼‚å¸¸ taskId=${taskId}`, error);
    }
  }

  /**
   * è¶…æ—¶Promiseè¾…åŠ©å‡½æ•°
   * @param {number} ms - è¶…æ—¶æ¯«ç§’æ•°
   * @param {string} message - è¶…æ—¶é”™è¯¯ä¿¡æ¯
   */
  timeout(ms, message) {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error(message)), ms);
    });
  }

  /**
   * å»¶è¿Ÿå‡½æ•°
   * @param {number} ms - å»¶è¿Ÿæ¯«ç§’æ•°
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = new PipelineEngine();
